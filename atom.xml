<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2021-06-08T14:18:46.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>程序员进阶书单2021版</title>
    <link href="https://www.howardliu.cn/lists-book-recommendations-2021/"/>
    <id>https://www.howardliu.cn/lists-book-recommendations-2021/</id>
    <published>2021-06-08T14:18:46.000Z</published>
    <updated>2021-06-08T14:18:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/woman-6175010_1920.jpg" alt="程序员进阶书单2021版"></p><p>你好，我是看山。</p><p>今天列一下技术相关的书单，本文是第一版，后续持续更新。</p><a id="more"></a><blockquote><p>文中提到的部分书目我也没有读过，作为todo list，明确接下来一段时间的学习方向。</p></blockquote><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>因为本人属于Java栈，所以主要推荐的还是属于Java领域内的书目。</p><ul><li><a href="https://book.douban.com/subject/34898994/" target="_blank" rel="noopener">《Java核心技术：卷I 基础知识》</a>：本书由拥有20多年教学与研究经验的资深Java技术专家撰写（获Jolt大奖），是程序员的优选Java指南。无论是Java初学者还是有一定经验的Java工程师，这是一本非常不错的值得时常翻阅的技术手册。</li><li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java编程思想》</a>：从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。属于经典书目，可能很多Java栈的程序猿，都是从这本书开始的。</li><li><a href="https://book.douban.com/subject/30133440/" target="_blank" rel="noopener">《Java编程的逻辑》</a>：Java专家撰写，力求透彻讲解每个知识点，逐步建立编程知识图谱。本书以Java语言为例，由基础概念入手，到背后实现原理与逻辑，再到应用实践，融会贯通。</li><li><a href="https://book.douban.com/subject/30412517/" target="_blank" rel="noopener">《Effective Java》</a>：模仿《Effective C++》而成，一共包含90个条目，每个条目讨论Java程序设计中的一条规则。这些规则反映了最有经验的优秀程序员在实践中常用的一些有益的做法。前人的经验之作，想要升阶，这本书一定绕不开。最好是看第三版的，增加了Java 8的规则。</li><li><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java》</a>：完整的面向对象（object-oriented，OO）程序设计和Java的学习指导。此书是根据学习理论所设计的，让你可以从学习程序语言的基础开始一直到包括线程、网络与分布式程序等项目。最重要的，你会学会如何像个面向对象开发者一样去思考。而且不只是读死书，你还会玩游戏、拼图、解谜题以及以意想不到的方式与Java交互。在这些活动中，你会写出一堆真正的Java程序，包括了一个船舰炮战游戏和一个网络聊天程序。</li><li><a href="https://book.douban.com/subject/10484692/" target="_blank" rel="noopener">《Java并发编程实战》</a>：深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。</li><li><a href="https://book.douban.com/subject/26740520/" target="_blank" rel="noopener">《Java性能权威指南》</a>：通过使用JVM和Java平台，以及Java语言和应用程序接口，本书详尽讲解了Java性能调优的相关知识，帮助读者深入理解Java平台性能的各个方面，最终使程序如虎添翼。</li><li><a href="https://book.douban.com/subject/34879022/" target="_blank" rel="noopener">《Java系统性能优化实战》</a>：基于作者在实际工作中遇到的与系统相关的问题及解决之道，通过改善代码来提高系统性能，解决因为代码导致的系统故障。国人写的新书也很好，一些细节，一些过时的传言，作者都用jmh给测了。</li><li><a href="https://book.douban.com/subject/35258148/" target="_blank" rel="noopener">《Java性能优化实践：JVM调优策略、工具与技巧》</a>：本书从实验科学的角度探讨了Java性能优化的方方面面，重点阐述了最新的实用JVM性能调优策略、工具和技巧。通过本书，我们不仅可以了解Java原理和技术如何充分利用现代硬件和操作系统、衡量Java性能的陷阱以及微基准测试的弊端有哪些，还能深入研究可能使团队烦恼的几种性能测试和常见反模式、JVM垃圾收集、JIT编译和Java语言性能技术等。</li><li><a href="https://book.douban.com/subject/34949443/" target="_blank" rel="noopener">《Spring实战》</a>：一本经典而实用的畅销Spring 学习指南。</li><li><a href="https://book.douban.com/subject/26857423/" target="_blank" rel="noopener">《SpringBoot实战》</a>：Spring应用程序开发为中心，全面讲解如何运用Spring Boot提高效率，使应用程序的开发和管理更加轻松有趣。</li><li><a href="https://book.douban.com/subject/26952826/" target="_blank" rel="noopener">《精通Spring 4.x》</a>：虽然现在都已经是Spring 5.x了，但是Spring的基础并没有变，本书把应用和原理都讲的很透彻，IoC和AOP分析的很棒，娓娓道来。</li><li><a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener">《深入理解Java虚拟机》</a>：这是一部从工作原理和工程实践两个维度深入剖析JVM的著作，是计算机领域公认的经典。</li><li><a href="https://book.douban.com/subject/34441840/" target="_blank" rel="noopener">《实战Java虚拟机：JVM故障诊断与性能优化》</a>：本书将通过200余个示例详细介绍JVM中的各种参数配置、故障排查、性能监控及性能优化，帮助Java人突破瓶颈。</li><li><a href="https://book.douban.com/subject/34812818/" target="_blank" rel="noopener">《新一代垃圾回收器ZGC设计与实现》</a>：有了ZGC，就忘记CMS，G1什么的吧。ZGC 所针对的是这些在未来普遍存在的大容量内存：TB 级别的堆容量，具有很低的停顿时间（小于 10 毫秒），对整体应用性能的影响也很小（对吞吐量的影响低于 15％）。ZGC 所采用的机制也可以在未来进行扩展，以支持一些令人兴奋的特性，如多层堆（用于热对象的 DRAM 和用于低频访问对象的 NVMe 闪存）。</li><li><a href="https://book.douban.com/subject/35079283/" target="_blank" rel="noopener">《深入理解JVM字节码》</a>：这是一本揭示JVM字节码“黑科技”的著作，它从原理和应用两个维度深入剖析了JVM字节码。书中内容涉及JVM字节码的大部分应用场景，如Java性能优化、软件防护与破解、APM等，通过大量实战案例讲解了它在这些场景中的实操技巧。</li><li><a href="https://book.douban.com/subject/34895968/" target="_blank" rel="noopener">《Java实战》</a>：现代Java应用充分利用了微服务、反应式架构以及流式数据等创新设计。现代Java特性，譬如Lambda、流以及大家期待已久的Java模块系统让这些设计的实现极其便利。是时候更新技能工具箱了，只有这样，你才能从容应对迎面而来的种种挑战！</li><li><a href="https://book.douban.com/subject/26772632/" target="_blank" rel="noopener">《Java8实战》</a>：本书全面介绍了Java 8 这个里程碑版本的新特性，包括Lambdas、流和函数式编程。有了函数式的编程特性，可以让代码更简洁，同时也能自动化地利用多核硬件。</li><li><a href="https://book.douban.com/subject/30358019/" target="_blank" rel="noopener">《实战Java高并发程序设计》</a>：主要介绍基于Java的并行程序设计基础、思路、方法和实战。第一，立足于并发程序基础，详细介绍Java进行并行程序设计的基本方法。第二，进一步详细介绍了JDK对并行程序的强大支持，帮助读者快速、稳健地进行并行程序开发。第三，详细讨论了“锁”的优化和提高并行程序性能级别的方法和思路。第四，介绍了并行的基本设计模式，以及Java 8/9/10对并行程序的支持和改进。第五，介绍了高并发框架Akka的使用方法。第六，详细介绍了并行程序的调试方法。第七，分析Jetty代码并给出一些其在高并发优化方面的例子。</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener">《深入理解计算机系统》</a>：这本书是程序员必读的一本书，这本书最大的优点是为程序员描述计算机系统的实现细节，帮助其在大脑中构造一个层次型的计算机系统。从最底层的数据在内存中的表示到流水线指令的构成，到虚拟存储器，到编译系统，到动态加载库，到最后的用户态应用。通过掌握程序是如何映射到系统上，以及程序是如何执行的，你能够更好的理解程序的行为为什么是这样的，以及效率底下是如何造成的。</li><li><a href="https://book.douban.com/subject/30280001/" target="_blank" rel="noopener">《计算机网络》</a>：经典的计算机网络教材，采用作者独创的自顶向下方法来讲授计算机网络的原理及其协议。</li><li><a href="https://book.douban.com/subject/25900403/" target="_blank" rel="noopener">《UNIX环境高级编程》</a>：UNIX编程“圣经”</li><li><a href="https://book.douban.com/subject/26434583/" target="_blank" rel="noopener">《UNIX网络编程：卷1》</a>：UNIX编程“圣经”</li><li><a href="https://book.douban.com/subject/4118577/" target="_blank" rel="noopener">《UNIX网络编程：卷2》</a>：UNIX编程“圣经”。可以看到，三本圣经，都是大部头很难啃的书，比较枯燥。修行路就是比较枯燥的。</li><li><a href="https://book.douban.com/subject/26825411/" target="_blank" rel="noopener">《TCP/IP详解 卷1：协议》</a>：本书内容丰富、概念清晰、论述详尽，适合任何希望理解TCP/IP协议实现的人阅读，更是TCP/IP领域研究人员和开发人员的权威参考书。无论是初学者还是功底深厚的网络领域高手，本书都是案头必备。</li><li><a href="https://book.douban.com/subject/30387220/" target="_blank" rel="noopener">《Wireshark数据包分析实战》</a>：从数据包分析与数据包嗅探器的基础知识开始，循序渐进地介绍Wireshark的基本使用方法及其数据包分析功能特性，同时还介绍了针对不同协议层与无线网络的具体实践技术与经验技巧。在此过程中，作者结合大量真实的案例，图文并茂地演示使用Wireshark进行数据包分析的技术方法，使读者能够顺着本书思路逐步掌握网络数据包嗅探与分析技能。</li><li><a href="https://book.douban.com/subject/30359954/" target="_blank" rel="noopener">《鸟哥的Linux私房菜：基础学习篇》</a>：讲解细致，深入浅出。可以对计算机和操作系统，以及Linux有一个非常全面的了解，并能够管理或者操作好一个Linux系统。</li><li><a href="https://book.douban.com/subject/27096665/" target="_blank" rel="noopener">《现代操作系统》</a>：这本书是操作系统领域的经典之作，书中集中讨论了操作系统的基本原理，包括进程、线程、存储管理、文件系统、输入/输出、死锁等，同时还包含了有关计算机安全、多媒体操作系统、掌上计算机操作系统、微内核、多核处理器上的虚拟机以及操作系统设计等方面的内容。</li><li><a href="https://book.douban.com/subject/1148282/" target="_blank" rel="noopener">《计算机程序的构造和解释》</a>：在过去的二十多年里，对于计算机科学的教育计划产生了深刻的影响。</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li><a href="https://book.douban.com/subject/3354490/" target="_blank" rel="noopener">《MySQL必知必会》</a>：书中从介绍简单的数据检索开始，逐步深入一些复杂的内容，包括联结的使用、子查询、正则表达式和基于全文本的搜索、存储过程、游标、触发器、表约束，等等。</li><li><a href="https://book.douban.com/subject/24250054/" target="_blank" rel="noopener">《SQL必知必会》</a>：本书是深受世界各地读者欢迎的SQL经典畅销书，内容丰富，文字简洁明快，针对Oracle、SQL Server、MySQL、DB2、PostgreSQL、SQLite等各种主流数据库提供了大量简明的实例。与其他同类图书不同，它没有过多阐述数据库基础理论，而是专门针对一线软件开发人员，直接从SQL SELECT开始，讲述实际工作环境中最常用和最必需的SQL知识，实用性极强。</li><li><a href="https://book.douban.com/subject/10548379/" target="_blank" rel="noopener">《数据库系统概念》</a>：本书是数据库系统方面的经典教材之一，其内容由浅入深，既包含数据库系统基本概念，又反映数据库技术新进展。它被国际上许多著名大学所采用，包括斯坦福大学、耶鲁大学、得克萨斯大学、康奈尔大学、伊利诺伊大学等。</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul><li><a href="https://book.douban.com/subject/19952400/" target="_blank" rel="noopener">《算法》</a>：算法领域的经典参考书。不但全面介绍了关于算法和数据结构的必备知识，还给出了每位程序员应知应会的50个算法，并提供了实际代码。最不错的是，其深入浅出的算法介绍，让一些比较难的算法也变得容易理解。其中，还有大量的图解，详尽的代码和讲解。</li><li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>：本书示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。</li><li><a href="https://book.douban.com/subject/20432061/" target="_blank" rel="noopener">《算法导论》</a>：本书将严谨性和全面性融为一体，深入讨论各类算法，并着力使这些算法的设计和分析能为各个层次的读者接受。全书各章自成体系，可以作为独立的学习单元；算法以英语和伪代码的形式描述，具备初步程序设计经验的人就能看懂；说明和解释力求浅显易懂，不失深度和数学严谨性。</li><li><a href="https://book.douban.com/subject/26302533/" target="_blank" rel="noopener">《编程珠玑》</a>：历史上最伟大的计算机科学著作之一。在书中，作者选取许多具有典型意义的复杂编程和算法问题，生动描绘了历史上众大师们在探索解决方案中发生的轶事、走过的弯路和不断精益求精的历程，引导读者像真正的程序员和软件工程师那样富于创新性地思考，并透彻阐述和总结了许多独特而精妙的设计原则、思考和解决问题的方法以及实用程序设计技巧。解决方案的代码均以C/C++语言编写，不仅有趣，而且有很大的实战示范意义。每章后所附习题极具挑战性和启发性，书末给出了简洁的解答。</li><li><a href="https://book.douban.com/subject/3351237/" target="_blank" rel="noopener">《数据结构与算法分析：Java语言描述》</a>：是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。</li></ul><h2 id="编程素养"><a href="#编程素养" class="headerlink" title="编程素养"></a>编程素养</h2><ul><li><a href="https://book.douban.com/subject/4199741/" target="_blank" rel="noopener">《代码整洁之道》</a>：代码质量与其整洁度成正比。干净的代码，既在质量上较为可靠，也为后期维护、升级奠定了良好基础。作为编程领域的佼佼者，本书作者给出了一系列行之有效的整洁代码操作实践。这些实践在本书中体现为一条条规则（或称“启示”），并辅以来自现实项目的正、反两面的范例。只要遵循这些规则，就能编写出干净的代码，从而有效提升代码质量。</li><li><a href="https://book.douban.com/subject/35006892/" target="_blank" rel="noopener">《程序员修炼之道》</a>：由一系列的独立的部分组成，涵盖的主题从个人责任、职业发展，直到用于使代码保持灵活、并且易于改编和复用的各种架构技术。</li><li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构 改善既有代码的设计》</a>：重构，一言以蔽之，就是在不改变外部行为的前提下，有条不紊地改善代码。多年前，正是本书原版的出版，使重构终于从编程高手们的小圈子走出，成为众多普通程序员日常开发工作中不可或缺的一部分。本书也因此成为与《设计模式》齐名的经典著作，被译为中、德、俄、日等众多语言，在世界范围内畅销不衰。</li><li><a href="https://book.douban.com/subject/1052241/" target="_blank" rel="noopener">《设计模式》</a>：这本书结合设计实作例从面向对象的设计中精选出23个设计模式，总结了面向对象设计中最有价值的经验，并且用简洁可复用的形式表达出来。书中分类描述了一组设计良好、表达清楚的软件设计模式，这些模式在实用环境下特别有用。此书适合大学计算机专业的学生、研究生及相关人员参考。</li><li><a href="https://book.douban.com/subject/2243615/" target="_blank" rel="noopener">《Head First 设计模式》</a>：一本设计模式入门书籍，用实际的编程案例讲解算法设计中会遇到的各种问题和需求变更，并以此逐步推导出良好的设计模式解决办法。</li><li><a href="https://book.douban.com/subject/35157817/" target="_blank" rel="noopener">《设计模式就该这样学：基于经典框架源码和真实业务场景》</a>：本书从软件架构设计必备的通用技能UML开始，重点介绍常用的类图和时序图；然后介绍软件架构设计常用的七大原则；接着结合JDK、Spring、MyBatis、Tomcat、Netty等经典框架源码对GoF的23种设计模式展开分析，并结合作者多年“踩坑填坑”和“教学答疑”经验，用深刻、全面、通俗、生动、有趣、接地气的方式结合真实业务场景分析每种设计模式，治愈“设计模式选择困难症”；之后介绍4种常用的新设计模式；最后总结软件架构、设计模式与应用框架之间的区别。</li><li><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">《代码大全》</a>：一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。这本书中所论述的技术不仅填补了初级与高级编程技术之间的空白，而且也为程序员们提供了一个有关编程技巧的信息来源。这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。可以说，无论是什么背景的读者，阅读这本书都有助于在更短的时间内、更容易地写出更好的程序。</li><li><a href="https://book.douban.com/subject/35088343/" target="_blank" rel="noopener">《编程的原则：改善代码质量的101个方法》</a>：本书介绍了软件开发领域101个重要的编程原则，涉及编程中的永恒真理，指导方针，编程思想，程序员的视角、习惯和工具，以及编程的反模式等内容。书中以“这个原则是什么”“为什么要遵循这个原则”“具体应该怎么做”为中心，对各个原则进行介绍，简明扼要，通俗易懂。这些原则凝聚了前人的智慧，经过了历史的考验，是指导程序员改善代码、进一步提升编程能力的实用指南。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li><a href="https://book.douban.com/subject/30443578/" target="_blank" rel="noopener">《软件架构设计》</a>：围绕软件架构设计，系统化地梳理技术架构与业务架构的方法论与实践。</li><li><a href="https://book.douban.com/subject/35217473/" target="_blank" rel="noopener">《架构师修炼之道：思维、方法与实践》</a>：作者结合多年的架构学习和项目开发经验，总结出一套架构学习的体系，从技术方法、思维意识、工具等方面讲解做好互联网后端架构设计的相关知识。通过相关知识的学习，读者能够掌握设计稳定、易维护、易扩展的软件架构的方法，也能够提升日常维护已有项目的能力。书中讲解的技术方法具有通用性，在其他非互联网行业的软件开发中，也具有借鉴意义。</li><li><a href="https://book.douban.com/subject/34960995/" target="_blank" rel="noopener">《发布！设计与部署稳定的分布式系统》</a>：作者根据自己的亲身经历和某些大型企业的案例，讲述了如何创建高稳定性的软件系统，分析了设计和实现中导致系统出现问题的原因。</li><li><a href="https://book.douban.com/subject/35178755/" target="_blank" rel="noopener">《可伸缩架构：云环境下的高可用与风险管理》</a>：一本关于现代化软件架构的书。书中介绍了如何构建和更新你的关键应用程序来满足日益苛刻的数字化客户的需求。书中还介绍了如何实现高可用性，如何使用现代化的开发和运维技术来架构应用程序，如何组织开发团队帮助应用程序和业务获得成功，如何将系统扩展到最大规模，以及如何利用云计算的可用资源来迎接上述挑战。</li><li><a href="https://book.douban.com/subject/35030121/" target="_blank" rel="noopener">《携程架构实践》</a>：本书浓缩了携程公司的整个技术架构，可以帮助读者了解支撑一家大型企业所需要的核心技术产品，以及它们的架构和面临的挑战。</li><li><a href="https://book.douban.com/subject/35062026/" target="_blank" rel="noopener">《架构师应该知道的37件事》</a>：本书汇集了一名架构师20多年来在全球各大企业任职的经验，共分为5个部分，分别对应在帮助大型企业进行IT转型的过程中，首席架构师必须高效处理的5个方面：企业或IT架构师的角色和能力、架构工作在大型企业中的价值、与各种干系人的沟通、对组织结构和系统的理解、对传统组织进行转型。本书科学而系统地归纳出软件架构师应该具备的完整能力模型，不仅帮助软件开发人员系统地学习如何掌握这37项技能，而且还能让他们进一步理解软件架构师的角色和本质，使他们最终突破技术“天花板”，成为一名合格的软件架构师。</li><li><a href="https://book.douban.com/subject/26772677/" target="_blank" rel="noopener">《微服务设计》</a>：本书全面介绍了微服务的建模、集成、测试、部署和监控，通过一个虚构的公司讲解了如何建立微服务架构。</li><li><a href="https://book.douban.com/subject/35092430/" target="_blank" rel="noopener">《微服务治理：体系、架构及实践》</a>：在微服务技术流行的当下，企业在实施微服务架构的时候，会对整个研发体系，包括开发、运维、团队组织、协同都带来冲击。因此必须构建起一整套以服务治理为核心、从线下到线上的新的能力体系来支撑这套新的架构技术，否则很难保证微服务架构的顺畅落地。 本书是作者多年服务治理经验总结，希望能够给仍在（微）服务治理迷局中夺路狂奔的计算机技术人员一点启发和指引。</li><li><a href="https://book.douban.com/subject/34801161/" target="_blank" rel="noopener">《企业级业务架构设计：方法论与实践》</a>：作者是一位资深的业务架构师，在金融行业工作超过19年，有丰富的大规模复杂金融系统业务架构设计和落地实施经验。作者在书中倡导“知行合一”的业务架构思想，全书内容围绕“行线”和“知线”两条主线展开。“行线”涵盖企业级业务架构的战略分析、架构设计、架构落地、长期管理的完整过程，“知线”则重点关注架构方法论的持续改良。</li><li><a href="https://book.douban.com/subject/30333919/" target="_blank" rel="noopener">《架构整洁之道》</a>：创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。</li><li><a href="https://book.douban.com/subject/26819666/" target="_blank" rel="noopener">《领域驱动设计：软件核心复杂性应对之道》</a>：全书围绕着设计和开发实践，结合若干真实的项目案例，向读者阐述如何在真实的软件开发中应用领域驱动设计。书中给出了领域驱动设计的系统化方法，并将人们普遍接受的一些最佳实践综合到一起，融入了作者的见解和经验，展现了一些可扩展的设计最佳实践、已验证过的技术以及便于应对复杂领域的软件项目开发的基本原则。</li></ul><h2 id="持续交付"><a href="#持续交付" class="headerlink" title="持续交付"></a>持续交付</h2><ul><li><a href="https://book.douban.com/subject/6862062/" target="_blank" rel="noopener">《持续交付：发布可靠软件的系统方法》</a>：讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。</li><li><a href="https://book.douban.com/subject/30419555/" target="_blank" rel="noopener">《持续交付2.0》</a>：本书重新定义了“持续交付”，增补了组织管理和系统架构两个维度，并辅助以真实案例，对诸多持续交付原则与实践加以解读，并对持续交付过程中的实践取舍之道加以论述。</li><li><a href="https://book.douban.com/subject/26979886/" target="_blank" rel="noopener">《学习敏捷：构建高效团队》</a>：本书以敏捷软件开发为中心，系统阐述了敏捷原则和实践的先进理念和重要意义，并分别讲解了Scrum、极限编程、精益和看板四套敏捷实践的应用。作者从开发团队的日常困境入手，用讲故事的形式展开问题，由表及里，层层讲解，并在每一章最后附上参考书，便于读者进一步查找学习。本书内容生动，语言通俗易懂，集趣味性和实用性于一体，是学习敏捷开发、提升团队效率的极佳参考书。</li><li><a href="https://book.douban.com/subject/26875239/" target="_blank" rel="noopener">《SRE: Google运维解密》</a>：Google SRE的关键成员解释了他们是如何对软件进行生命周期的整体性关注的，以及为什么这样做能够帮助Google成功地构建、部署、监控和运维世界上现存最大的软件系统。</li><li><a href="https://book.douban.com/subject/30219010/" target="_blank" rel="noopener">《进化：运维技术变革与实践探索》</a>：本书依托作者在电信和互联网行业多年的从业经历，结合一线实际工作实践，从应用生命周期的视角，全面详细地介绍了分布式架构体系下，应用运维体系建设的方方面面，涵盖了体系建设方法论指导、持续交付体系建设思路和实践、稳定性体系规划建设，以及故障的科学管理方法等内容，视角新颖且独特，换一个角度看运维，能够带给读者不一样的思考方式。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>左耳朵耗子在《程序员练级攻略》推荐的必读书籍清单，关注【公众号：看山的小屋】，回复“左耳”领取。如果想要付费订阅《左耳听风》，可以点<a href="http://gk.link/a/10sq6" target="_blank" rel="noopener">这里</a>，购买成功的话在公众号留言找我返现。</li><li><a href="https://mp.weixin.qq.com/s/U6CMqnT074__x8BFbZy0_w" target="_blank" rel="noopener">江南白衣的书单</a></li></ul><hr><p>你好，我是看山，公众号：<a href="http://static.howardliu.cn/about/kanshanshuo.png" target="_blank" rel="noopener">看山的小屋</a>，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117727787" target="_blank" rel="noopener">程序员进阶书单2021版</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      今天列一下技术相关的书单，本文是第一版，后续持续更新。
    
    </summary>
    
    
      <category term="书单" scheme="https://www.howardliu.cn/categories/%E4%B9%A6%E5%8D%95/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="书单" scheme="https://www.howardliu.cn/tags/%E4%B9%A6%E5%8D%95/"/>
    
      <category term="技术成长" scheme="https://www.howardliu.cn/tags/%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Geek 青年说北京沙龙分享</title>
    <link href="https://www.howardliu.cn/geek-talk-20210523/"/>
    <id>https://www.howardliu.cn/geek-talk-20210523/</id>
    <published>2021-05-31T06:28:34.000Z</published>
    <updated>2021-05-31T06:28:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/hybrid-6274156_1920.jpg" alt="Geek 青年说北京沙龙分享"></p><p>你好，我是看山。</p><p>5 月 23 号参加了 infoQ 写作平台组织的线下沙龙，瞻仰了很多大佬的英姿。在 Geek 青年说的环节，也壮起胆量上台分享了自己的一些观点。第一次上台，面对台下的大佬们，难免有些紧张。不过思考不易，整理出来，希望能够帮到有相同困惑的同仁们。</p><a id="more"></a><p>@文字君 阿萌提前准备了几个问题，其本意是提供一些分享的思路。奈何，京城的程序猿们比较保守，将这些思路当成了题目，完全打乱了阿萌的计划。下面是几个问题：</p><ol><li>我是如何走上写作之路的？</li><li>坚持写作给我带来了什么（长期收益、隐形投资、短期回报）</li><li>我的技术成长之路（学习策略、可推荐图书）</li><li>一个优秀的程序员的必备素质？（大佬特质有哪些）？</li></ol><p>前两个问题还好，与自身相关。后两个问题具有普遍意义，需要单独开文回答了。</p><h2 id="写作和收益"><a href="#写作和收益" class="headerlink" title="写作和收益"></a>写作和收益</h2><p>很多事情的发生都需要一个契机，就像是扣动扳机一样。</p><p>朋友在研二实习时面试的是百度，面试官看过他写的博客，感觉很好，加上他自身实力不俗，顺利拿到了 offer。</p><p>这对我来说，是一种触动，想着自己也开通一个账号，整理自己的所学所思所感，万一哪天面试用得到呢。于是，第一篇文章就这样诞生了。当时虽有目的，却动力不足，产出比较低，一年才 20 几篇，甚至在 2018 年停了 1 年。</p><p>每个人写作的目的不一样，但是写作带来的收益有一个是相似的，那就是：思考。无论是谁，什么段位，想要写成一篇文章，必然需要思考，思考前因后果。有时候写的不顺利，可能连续很长一段时间都会反复咀嚼反刍。这就是反复思考的过程，也是反复自省的过程。</p><p>我们做程序猿是比较难的，各种新技术层出不穷，很多时候我们会抱怨学不动了。但是我们做程序猿又是比较容易的，只要有一项技术精通摸透了，触类旁通，其他技术也能够很快上手。如果没有思考，很难做到精通。</p><p>我们在工作中有思考和没有思考会产生截然相反的两种结果，就像是送信的马儿和拉磨的驴子，可能它俩走路的长度一样，但是，马儿看过了世界，驴子看到的只是磨盘下的那个圈。</p><h2 id="两个模型"><a href="#两个模型" class="headerlink" title="两个模型"></a>两个模型</h2><p>分享两个模型：</p><ol><li>德雷福斯模型<br><img src="http://static.howardliu.cn/raving/%E5%BE%B7%E9%9B%B7%E7%A6%8F%E6%96%AF%E6%A8%A1%E5%9E%8B.png" alt="德雷福斯模型"></li><li>艾宾浩斯遗忘曲线<br><img src="http://static.howardliu.cn/raving/20200621182354129.png" alt="艾宾浩斯遗忘曲线"></li></ol><h3 id="德雷福斯模型"><a href="#德雷福斯模型" class="headerlink" title="德雷福斯模型"></a>德雷福斯模型</h3><p>德雷福斯模型定义了我们成长的路径：</p><ol><li>新手 Novice<ol><li>严格遵守规则或计划</li><li>几乎无法感知情境</li><li>无法酌情判断</li></ol></li><li>高级新手 Advanced Beginner<ol><li>依赖基于属性或不同侧面的行动准则</li><li>情境感知依然有限</li><li>对工作的不同方面，分开处理并且给予同等重要性</li></ol></li><li>胜任者 Competent<ol><li>能应对多线程活动或丰富的信息量</li><li>能从长期目标角度（至少部分）审视行动</li><li>有意识、刻意地制定计划</li><li>将流程标准化和常规化</li></ol></li><li>精通者 Proficient<ol><li>从整体把握全局，而不是观察各个方面</li><li>了解情境中最重要的事</li><li>感知情境与正常模式的偏差</li><li>决策越来越轻松</li><li>使用原则（maxims）指导行动，其含义因情况而异</li></ol></li><li>专家 Expert<ol><li>不再依赖规则、行动准则、原则</li><li>基于深刻、潜默的直觉把握情境</li><li>出现新情况或发生问题才使用分析法</li><li>看到未来可能的愿景</li></ol></li></ol><p>以做饭举例：</p><ul><li>新手就是必须照着菜谱做饭，甚至会拿出厨房秤，一丝一毫不能差。如果碰到盐少量、醋少量之类的模糊描述，就完全歇菜。</li><li>高级新手也需要菜谱，但是知道盐少量就是少加点是多少了。</li><li>胜任者基本上不需要菜谱了，菜谱就在脑袋中。但也是照本宣科，没有什么创新。</li><li>精通者在某种菜式中游刃有余，不过，还局限在某种范式中。比如：鲁菜、川菜、杭帮菜等。</li><li>专家没有固定套路，不局限于某种菜式。可以根据食材当时的情况，完全发挥其美味，信手拈来。</li></ul><p>我们也可以列出自己的技术栈和技能，然后每一项后面给自己下一个定义，这样就能够知道我们的差距在哪了。</p><h3 id="艾宾浩斯遗忘曲线"><a href="#艾宾浩斯遗忘曲线" class="headerlink" title="艾宾浩斯遗忘曲线"></a>艾宾浩斯遗忘曲线</h3><p>艾宾浩斯遗忘曲线是可以指导我们学习。</p><p>相信大家都会有一个疑惑，为什么考试之后的知识都遗忘了？就是因为这个遗忘曲线，我们的大脑和电脑不同的是，我们的存储会被清除，随着时间的推移，可能留下的记忆少了。</p><p>之前在读书笔记 <a href="https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/">别让非理性思维毁了你的人生</a> 中提过，我们的大脑就是一台克鲁机，很多都是拼凑出来了，而且，由于我们的大脑耗能严重，所以奔着能省则省的原则，凡是不影响生死的记忆行为，都被海马体挡在外面了。</p><p>为了骗过海马体这个看门人，我们需要反复学习加深记忆。这也解释了很多同学的一个疑惑，明明很用功的在看书学习，但是偏偏看过一段时间之后，就忘记了。对学习动力造成很大的打击。其实，只是需要隔一段时间在复习一下。</p><p>通常来说，我们的复习节奏是这样，隔 1 天后、再隔 7 天后、再隔 14 天后、再隔 30 天后。也就是说，我们在 1 号学习的知识，需要在 2 号、9 号、23 号、次月 20 号这 4 天复习。这样我们的记忆会保持很久。</p><p>而且，兴趣是最好的记忆催化剂，我们要保持学习的兴趣。很多同学应该有感触，我们感兴趣的东西，哪怕不重复记忆，也可能过目不忘。但是我们感觉无聊的信息，很可能转头就忘。所以，让我们对这个世界保持兴趣，至少对我们要学习的那些东西保持兴趣。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/">别让非理性思维毁了你的人生</a></li><li><a href="https://www.howardliu.cn/geek-talk-20210523/">Geek 青年说北京沙龙分享</a></li><li><a href="https://www.howardliu.cn/lists-book-recommendations-2021/">程序员进阶书单2021版</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/geek-talk-20210523/">Geek 青年说北京沙龙分享</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117415953" target="_blank" rel="noopener">Geek 青年说北京沙龙分享</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      5 月 23 号参加了 infoQ 写作平台组织的线下沙龙，瞻仰了很多大佬的英姿。在 Geek 青年说的环节，也壮起胆量上台分享了自己的一些观点。第一次上台，面对台下的大佬们，难免有些紧张。不过思考不易，整理出来，希望能够帮到有相同困惑的同仁们。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊，写作，技术成长" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A%EF%BC%8C%E5%86%99%E4%BD%9C%EF%BC%8C%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>一文掌握 Java8 的 Optional 的 6 种操作</title>
    <link href="https://www.howardliu.cn/java-util-optional/"/>
    <id>https://www.howardliu.cn/java-util-optional/</id>
    <published>2021-05-17T06:17:26.000Z</published>
    <updated>2021-05-17T06:17:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/hamburg-5286863_1920.jpg" alt="一文掌握 Java8 的 Optional 的 6 种操作"></p><p>你好，我是看山。</p><p>Java8 中引入了一个特别有意思类：<code>Optional</code>，一个可以让我们更加轻松的避免 NPE（空指针异常，NullPointException）的工具。</p><p>很久很久以前，为了避免 NPE，我们会写很多类似<code>if (obj != null) {}</code>的代码，有时候忘记写，就可能出现 NPE，造成线上故障。在 Java 技术栈中，如果谁的代码出现了 NPE，有极大的可能会被笑话，这个异常被很多人认为是低级错误。<code>Optional</code>的出现，可以让大家更加轻松的避免因为低级错误被嘲讽的概率。</p><a id="more"></a><h2 id="定义示例数据"><a href="#定义示例数据" class="headerlink" title="定义示例数据"></a>定义示例数据</h2><p>先定义待操作对象，万能的<code>Student</code>类和<code>Clazz</code>类（用到了 lombok 和 guava）：</p><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Clazz {    private String id;    private String name;}</code></pre><pre><code class="java">@Data@AllArgsConstructor@NoArgsConstructorpublic class Student {    private String id;    private String name;    private Clazz clazz;}</code></pre><p>然后定义一组测试数据：</p><pre><code class="java">final Clazz clazz1 = new Clazz(&quot;1&quot;, &quot;高一一班&quot;);final Student s1 = new Student(&quot;1&quot;, &quot;张三&quot;, clazz1);final Student s2 = new Student(&quot;2&quot;, &quot;李四&quot;, null);final List&lt;Student&gt; students = Lists.newArrayList(s1, s2);final List&lt;Student&gt; emptyStudents = Lists.newArrayList();final List&lt;Student&gt; nullStudents = null;</code></pre><h2 id="创建实例：of、ofNullable"><a href="#创建实例：of、ofNullable" class="headerlink" title="创建实例：of、ofNullable"></a>创建实例：of、ofNullable</h2><p>为了控制生成实例的方式，也是为了收紧空值<code>Optional</code>的定义，<code>Optional</code>将构造函数定义为<code>private</code>。想要创建<code>Optional</code>实例，可以借助<code>of</code>和<code>ofNullable</code>两个方法实现。</p><p>这两个方法的区别在于：<code>of</code>方法传入的参数不能是<code>null</code>的，否则会抛出<code>NullPointerException</code>。所以，对于可能是<code>null</code>的结果，一定使用<code>ofNullable</code>。</p><p>代码如下：</p><pre><code class="java">Optional.of(students);Optional.of(emptyStudents);Optional.ofNullable(nullStudents);</code></pre><p><code>Optional</code>类中还有一个静态方法：<code>empty</code>，这个方法直接返回了内部定义的一个常量<code>Optional&lt;?&gt; EMPTY = new Optional&lt;&gt;()</code>，这个常量的<code>value</code>是<code>null</code>。<code>ofNullable</code>方法也是借助了<code>empty</code>实现<code>null</code>的包装：</p><pre><code class="java">public static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value) {    return value == null ? empty() : of(value);}</code></pre><p>所以说，对于<code>null</code>的<code>Optional</code>包装类，指向的都是相同的实例对象，<code>Optional.empty() == Optional.ofNullable(null)</code>返回的是<code>true</code>。换句话说，空<code>Optional</code>是单例的。</p><blockquote><p>为了方便描述，下文中对值为<code>null</code>的<code>Optional</code>统称为“<strong>空<code>Optional</code></strong>”。</p></blockquote><h2 id="获取数据：get"><a href="#获取数据：get" class="headerlink" title="获取数据：get"></a>获取数据：get</h2><p><code>Optional</code>的<code>get</code>方法有些坑人，先看下它的源码：</p><pre><code class="java">public T get() {    if (value == null) {        throw new NoSuchElementException(&quot;No value present&quot;);    }    return value;}</code></pre><p>也就是说，<code>Optional</code>值为空时，使用<code>get</code>方法将抛出<code>NoSuchElementException</code>异常。如果不想抛出异常，或者能够 100%确定不是空<code>Optional</code>，或者使用<code>isPresent</code>方法判断。</p><p>如果能 100%确定不是空<code>Optional</code>，那就没有必要使用<code>Optional</code>包装，直接返回即可。如果需要使用<code>isPresent</code>方法，那就和直接判空没有区别了。所以，无论是第一种情况还是第二种情况，都违背了设计这个类的初衷。</p><h2 id="值为空判断：isPresent、ifPresent"><a href="#值为空判断：isPresent、ifPresent" class="headerlink" title="值为空判断：isPresent、ifPresent"></a>值为空判断：isPresent、ifPresent</h2><p><code>isPresent</code>用来判断值是否为空，类似于<code>obj != null</code>，<code>ifPresent</code>可以传入一个<code>Consumer</code>操作，当值不为空的时候，会执行<code>Consumer</code>函数。比如：</p><pre><code class="java">final Optional&lt;List&lt;Student&gt;&gt; nullValue = Optional.ofNullable(nullStudents);if (nullValue.isPresent()) {    System.out.println(&quot;value: &quot; + nullValue.get());}</code></pre><p>上面的方法等价于：</p><pre><code class="java">nullValue.ifPresent(value -&gt; System.out.println(&quot;value: &quot; + value));</code></pre><p><code>isPresent</code>判断的写法上是不是感觉很熟悉，感觉可以直接写为：</p><pre><code class="java">if (nullStudents != null) {    System.out.println(&quot;value: &quot; + nullStudents);}</code></pre><p>对于<code>isPresent</code>，如果是在自己可控的代码范围内，完全没有必要将值封装之后再判空。对于自己不可控的代码，后续的<code>filter</code>或者<code>map</code>方法可能比<code>isPresent</code>更好用一些。</p><p>对于<code>ifPresent</code>，在使用的时候会有一些限制，就是必须是非空<code>Optional</code>的时候，在会执行传入的<code>Consumer</code>函数。</p><h2 id="值处理：map、flatMap"><a href="#值处理：map、flatMap" class="headerlink" title="值处理：map、flatMap"></a>值处理：map、flatMap</h2><p><code>map</code>和<code>flatMap</code>是对<code>Optional</code>的值进行操作的方法，区别在于，<code>map</code>会将结果包装到<code>Optional</code>中返回，<code>flatMap</code>不会。但是两个方法返回值都是<code>Optional</code>类型，这也就要求，<code>flatMap</code>的方法函数返回值需要是<code>Optional</code>类型。</p><p>我们来看看<code>map</code>的实现：</p><pre><code class="java">public&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper) {    Objects.requireNonNull(mapper);    if (!isPresent())        return empty();    else {        return Optional.ofNullable(mapper.apply(value));    }}</code></pre><p>可以看到，如果<code>Optional</code>的值为空，<code>map</code>直接返回<code>Optional.EMPTY</code>，否则会执行函数结果，并使用<code>Optional.ofNullable</code>包装并返回。也即是说，只要类结构允许，我们可以一直<code>map</code>下去，就像是扒洋葱，一层一层，直到核心。</p><p>比如，我们要获取<code>s2</code>所在班级名称，在定义的时候，我们将<code>s2</code>的<code>clazz</code>属性定义为 null，如果以前需要写为：</p><pre><code class="java">String clazzNameOld;if (s2 != null &amp;&amp; s2.getClazz() != null &amp;&amp; s2.getClazz().getName() != null) {    clazzNameOld = s2.getClazz().getName();} else {    clazzNameOld = &quot;DEFAULT_NAME&quot;;}</code></pre><p>现在借助<code>Optional</code>可以写为：</p><pre><code class="java">final String clazzName = Optional.ofNullable(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElse(&quot;DEFAULT_NAME&quot;);</code></pre><p>从代码上似乎没有多大改变，但是如果<code>Clazz</code>内部还有类对象。或者，我们在<code>if</code>判断的时候，少写一层检查呢？而且，<code>map</code>的精巧还在于它的返回值永远是<code>Optional</code>，这样，我们可以重复调用<code>map</code>方法，而不需要中间被打断，增加各种判空逻辑。</p><h2 id="值为空的处理：orElse、orElseGet、orElseThrow"><a href="#值为空的处理：orElse、orElseGet、orElseThrow" class="headerlink" title="值为空的处理：orElse、orElseGet、orElseThrow"></a>值为空的处理：orElse、orElseGet、orElseThrow</h2><p>这几个方法可以与<code>map</code>操作结合，一起完成对象操作。当值为空时，<code>orElse</code>和<code>orElseGet</code>返回默认值，<code>orElseThrow</code>抛出指定的异常。</p><p><code>orElse</code>和<code>orElseGet</code>的区别是，<code>orElse</code>方法传入的参数是明确的默认值，<code>orElseGet</code>方法传入的参数是获取默认值的函数。如果默认值的构造过程比较复杂，需要经过一系列的运算逻辑，那一定要使用<code>orElseGet</code>，因为<code>orElseGet</code>是在值为空的时候，才会执行函数，并返回默认值，如果值不为空，则不会执行函数，相比于<code>orElse</code>而言，减少了一次构造默认值的过程。</p><p>同样以上面的例子：</p><p><code>orElse</code>的写法：</p><pre><code class="java">final String clazzName = Optional.ofNullable(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElse(null);</code></pre><p><code>orElseGet</code>的写法：</p><pre><code class="java">final String clazzName = Optional.of(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElseGet(() -&gt; null);</code></pre><p>如果<code>clazz</code>属性一定不为空，为空则返回异常，可以使用<code>orElseThrow</code>：</p><pre><code class="java">final String clazzName = Optional.of(s2)        .map(Student::getClazz)        .map(Clazz::getName)        .orElseThrow(() -&gt; new IllegalArgumentException(&quot;clazz属性不合法&quot;));</code></pre><h2 id="条件过滤：filter"><a href="#条件过滤：filter" class="headerlink" title="条件过滤：filter"></a>条件过滤：filter</h2><p><code>filter</code>方法提供的是值验证，如果值验证为 true，返回当前值；否则，返回空<code>Optional</code>。比如，我们要遍历<code>students</code>，找到班级属性为空的，打印学生id：</p><pre><code class="java">for (final Student s : students) {    Optional.of(s)            .filter(x -&gt; x.getClazz() == null)            .ifPresent(x -&gt; System.out.println(x.getId()));}</code></pre><h2 id="其他：equals、hashCode、toString"><a href="#其他：equals、hashCode、toString" class="headerlink" title="其他：equals、hashCode、toString"></a>其他：equals、hashCode、toString</h2><p><code>Optional</code>重写了这三个方法。因为<code>Optional</code>可以认为是包装类，所以还是围绕这被包装的值重写这三个方法。下面给出这三个方法的源码：</p><pre><code class="java">public boolean equals(Object obj) {    // 同一对象判断    if (this == obj) {        return true;    }    // 类型判断    if (!(obj instanceof Optional)) {        return false;    }    Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;    // 最终还是值的判断    return Objects.equals(value, other.value);}public int hashCode() {    // 直接返回值的hashCode    return Objects.hashCode(value);}public String toString() {    return value != null        ? String.format(&quot;Optional[%s]&quot;, value) // 用到了值的toString结果        : &quot;Optional.empty&quot;;}</code></pre><p><code>equals</code>方法，<code>Optional.of(s1).equals(Optional.of(s2))</code>完全等价于<code>s1.equals(s2)</code>。</p><p><code>hashCode</code>方法，直接返回的是值的hashCode，如果是空<code>Optional</code>，返回的是0。</p><p><code>toString</code>方法，为了能够识别是<code>Optional</code>，将打印数据包装了一下。如果是空<code>Optional</code>，返回的是字符串“Optional.empty”；如果是非空，返回是是“Optional[值的toString]”。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>NPE 之所以讨厌，就是只要出现 NPE，我们就能够解决。但是一旦出现，都已经是事后，可能已经出现线上故障。偏偏在 Java 语言中，NPE 又很容易出现。<code>Optional</code>提供了模板方法，有效且高效的避免 NPE。</p><p>接下来，我们针对上面的使用，总结一下：</p><ol><li><code>Optional</code>是一个包装类，且不可变，不可序列化</li><li>没有公共构造函数，创建需要使用<code>of</code>、<code>ofNullable</code>方法</li><li>空<code>Optional</code>是单例，都是引用<code>Optional.EMPTY</code></li><li>想要获取<code>Optional</code>的值，可以使用<code>get</code>、<code>orElse</code>、<code>orElseGet</code>、<code>orElseThrow</code></li></ol><p>另外，还有一些实践上的建议：</p><ol><li>使用<code>get</code>方法前，必须使用<code>isPresent</code>检查。但是使用<code>isPresent</code>前，先思考下是否可以使用<code>orElse</code>、<code>orElseGet</code>等方法代替实现。</li><li><code>orElse</code>和<code>orElseGet</code>，优先选择<code>orElseGet</code>，这个是惰性计算</li><li><code>Optional</code>不要作为参数或者类属性，可以作为返回值</li><li>尽量将<code>map</code>、<code>filter</code>的函数参数抽出去作为单独方法，这样能够保持链式调用</li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/117057756" target="_blank" rel="noopener">一文掌握 Java8 的 Optional 的 6 种操作</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一文掌握 Java8 的 Optional 的 6 种操作
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="stream" scheme="https://www.howardliu.cn/tags/stream/"/>
    
      <category term="jdk8" scheme="https://www.howardliu.cn/tags/jdk8/"/>
    
      <category term="optional" scheme="https://www.howardliu.cn/tags/optional/"/>
    
  </entry>
  
  <entry>
    <title>一文掌握 Java8 Stream 中 Collectors 的 24 个操作</title>
    <link href="https://www.howardliu.cn/java-stream-collectors/"/>
    <id>https://www.howardliu.cn/java-stream-collectors/</id>
    <published>2021-05-12T11:49:59.000Z</published>
    <updated>2021-05-12T11:49:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/cover/stadttheater-5002861_1920.jpg" alt="一文掌握 Java8 Stream 中 Collectors 的 24 个操作"></p><p>你好，我是看山。</p><p>Java8 应该算是业界主版本了，版本中重要性很高的一个更新是<code>Stream</code>流处理。关于流处理内容比较多，本文主要是说一下<code>Stream</code>中的<code>Collectors</code>工具类的使用。</p><a id="more"></a><p><code>Collectors</code>是<code>java.util.stream</code>包下的一个工具类，其中各个方法的返回值可以作为<code>java.util.stream.Stream#collect</code>的入参，实现对队列的各种操作，包括：分组、聚合等。官方文档给出一些例子：</p><blockquote><p>Implementations of {@link Collector} that implement various useful reduction operations, such as accumulating elements into collections, summarizing elements according to various criteria, etc.</p><p>The following are examples of using the predefined collectors to perform common mutable reduction tasks:</p><pre><code class="java">// Accumulate names into a ListList&lt;String&gt; list = people.stream().map(Person::getName).collect(Collectors.toList());// Accumulate names into a TreeSetSet&lt;String&gt; set = people.stream().map(Person::getName).collect(Collectors.toCollection(TreeSet::new));// Convert elements to strings and concatenate them, separated by commasString joined = things.stream()        .map(Object::toString)        .collect(Collectors.joining(&quot;, &quot;));// Compute sum of salaries of employeeint total = employees.stream()        .collect(Collectors.summingInt(Employee::getSalary)));// Group employees by departmentMap&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream()        .collect(Collectors.groupingBy(Employee::getDepartment));// Compute sum of salaries by departmentMap&lt;Department, Integer&gt; totalByDept = employees.stream()        .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary)));// Partition students into passing and failingMap&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream()        .collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD));</code></pre></blockquote><h2 id="定义示例数据"><a href="#定义示例数据" class="headerlink" title="定义示例数据"></a>定义示例数据</h2><p>先定义待操作对象，一个万能的<code>Student</code>类（用到了 lombok）：</p><pre><code class="java">@Data@AllArgsConstructorpublic class Student {    private String id;    private String name;    private LocalDate birthday;    private int age;    private double score;}</code></pre><p>然后定义一组测试数据：</p><pre><code class="java">final List&lt;Student&gt; students = Lists.newArrayList();students.add(new Student(&quot;1&quot;, &quot;张三&quot;, LocalDate.of(2009, Month.JANUARY, 1), 12, 12.123));students.add(new Student(&quot;2&quot;, &quot;李四&quot;, LocalDate.of(2010, Month.FEBRUARY, 2), 11, 22.123));students.add(new Student(&quot;3&quot;, &quot;王五&quot;, LocalDate.of(2011, Month.MARCH, 3), 10, 32.123));</code></pre><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><h3 id="元素数量：counting"><a href="#元素数量：counting" class="headerlink" title="元素数量：counting"></a>元素数量：counting</h3><p>这个比较简单，就是统计聚合结果的元素数量：</p><pre><code class="java">// 3students.stream().collect(Collectors.counting())</code></pre><h3 id="平均值：averagingDouble、averagingInt、averagingLong"><a href="#平均值：averagingDouble、averagingInt、averagingLong" class="headerlink" title="平均值：averagingDouble、averagingInt、averagingLong"></a>平均值：averagingDouble、averagingInt、averagingLong</h3><p>这几个方法是计算聚合元素的平均值，区别是输入参数需要是对应的类型。</p><p>比如，求学生的分数平均值，因为分数是<code>double</code>类型，所以在不转类型的情况下，需要使用<code>averagingDouble</code>：</p><pre><code class="java">// 22.123students.stream().collect(Collectors.averagingDouble(Student::getScore))</code></pre><p>如果考虑转换精度，也是可以实现：</p><pre><code class="java">// 22.0students.stream().collect(Collectors.averagingInt(s -&gt; (int)s.getScore()))// 22.0students.stream().collect(Collectors.averagingLong(s -&gt; (long)s.getScore()))</code></pre><p>如果是求学生的平均年龄，因为年龄是<code>int</code>类型，就可以随意使用任何一个函数了：</p><pre><code class="java">// 11.0students.stream().collect(Collectors.averagingInt(Student::getAge))// 11.0students.stream().collect(Collectors.averagingDouble(Student::getAge))// 11.0students.stream().collect(Collectors.averagingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法的返回值都是<code>Double</code>类型。</p></blockquote><h3 id="和：summingDouble、summingInt、summingLong"><a href="#和：summingDouble、summingInt、summingLong" class="headerlink" title="和：summingDouble、summingInt、summingLong"></a>和：summingDouble、summingInt、summingLong</h3><p>这三个方法和上面的平均值方法类似，也是需要注意元素的类型，在需要类型转换时，需要强制转换：</p><pre><code class="java">// 66students.stream().collect(Collectors.summingInt(s -&gt; (int)s.getScore()))// 66.369students.stream().collect(Collectors.summingDouble(Student::getScore))// 66students.stream().collect(Collectors.summingLong(s -&gt; (long)s.getScore()))</code></pre><p>但是对于不需要强制转换的类型，可以随意使用任何一个函数：</p><pre><code class="java">// 33students.stream().collect(Collectors.summingInt(Student::getAge))// 33.0students.stream().collect(Collectors.summingDouble(Student::getAge))// 33students.stream().collect(Collectors.summingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法返回值和平均值的三个方法不一样，<code>summingDouble</code>返回的是<code>Double</code>类型、<code>summingInt</code>返回的是<code>Integer</code>类型，<code>summingLong</code>返回的是<code>Long</code>类型。</p></blockquote><h3 id="最大值-最小值元素：maxBy、minBy"><a href="#最大值-最小值元素：maxBy、minBy" class="headerlink" title="最大值/最小值元素：maxBy、minBy"></a>最大值/最小值元素：maxBy、minBy</h3><p>顾名思义，这两个函数就是求聚合元素中指定比较器中的最大/最小元素。比如，求年龄最大/最小的<code>Student</code>对象：</p><pre><code class="java">// Optional[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)]，注意返回类型是Optionalstudents.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)))// Optional[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]，注意返回类型是Optionalstudents.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)))</code></pre><p>从源码可以看出来，这两个方法算是作者给的福利，用于完善数据统计的结果。内部都是封装了<code>reducing</code>方法和<code>BinaryOperator</code>工具类，这些下面会讲到。</p><pre><code class="java">public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator) {    return reducing(BinaryOperator.maxBy(comparator));}public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? super T&gt; comparator) {    return reducing(BinaryOperator.minBy(comparator));}</code></pre><h3 id="统计结果：summarizingDouble、summarizingInt、summarizingLong"><a href="#统计结果：summarizingDouble、summarizingInt、summarizingLong" class="headerlink" title="统计结果：summarizingDouble、summarizingInt、summarizingLong"></a>统计结果：summarizingDouble、summarizingInt、summarizingLong</h3><p>既然是数据操作，基本上逃不出计数、求平局、求和、最大、最小这几个，所以作者也是很贴心的实现了一组聚合的数据统计方法。</p><p>这组方法与求和、求平均的方法类似，都需要注意方法类型。比如，按照分数统计的话，需要进行类型转换：</p><pre><code class="java">// IntSummaryStatistics{count=3, sum=66, min=12, average=22.000000, max=32}students.stream().collect(Collectors.summarizingInt(s -&gt; (int) s.getScore()))// DoubleSummaryStatistics{count=3, sum=66.369000, min=12.123000, average=22.123000, max=32.123000}students.stream().collect(Collectors.summarizingDouble(Student::getScore))// LongSummaryStatistics{count=3, sum=66, min=12, average=22.000000, max=32}students.stream().collect(Collectors.summarizingLong(s -&gt; (long) s.getScore()))</code></pre><p>如果是用年龄统计的话，三个方法通用：</p><pre><code class="java">// IntSummaryStatistics{count=3, sum=33, min=10, average=11.000000, max=12}students.stream().collect(Collectors.summarizingInt(Student::getAge))// DoubleSummaryStatistics{count=3, sum=33.000000, min=10.000000, average=11.000000, max=12.000000}students.stream().collect(Collectors.summarizingDouble(Student::getAge))// LongSummaryStatistics{count=3, sum=33, min=10, average=11.000000, max=12}students.stream().collect(Collectors.summarizingLong(Student::getAge))</code></pre><blockquote><p>注意：这三个方法返回值不一样，<code>summarizingDouble</code>返回<code>DoubleSummaryStatistics</code>类型，<code>summarizingInt</code>返回<code>IntSummaryStatistics</code>类型，<code>summarizingLong</code>返回<code>LongSummaryStatistics</code>类型。</p></blockquote><h2 id="聚合、分组"><a href="#聚合、分组" class="headerlink" title="聚合、分组"></a>聚合、分组</h2><h3 id="聚合元素：toList、toSet、toCollection"><a href="#聚合元素：toList、toSet、toCollection" class="headerlink" title="聚合元素：toList、toSet、toCollection"></a>聚合元素：toList、toSet、toCollection</h3><p>这几个函数比较简单，是将聚合之后的元素，重新封装到队列中，然后返回。比如，得到所有<code>Student</code>的 ID 列表，只需要根据需要的结果类型使用不同的方法即可：</p><pre><code class="java">// List: [1, 2, 3]final List&lt;String&gt; idList = students.stream().map(Student::getId).collect(Collectors.toList());// Set: [1, 2, 3]final Set&lt;String&gt; idSet = students.stream().map(Student::getId).collect(Collectors.toSet());// TreeSet: [1, 2, 3]final Collection&lt;String&gt; idTreeSet = students.stream().map(Student::getId).collect(Collectors.toCollection(TreeSet::new));</code></pre><blockquote><p>注意：<code>toList</code>方法返回的是<code>List</code>子类，<code>toSet</code>返回的是<code>Set</code>子类，<code>toCollection</code>返回的是<code>Collection</code>子类。我们都知道，<code>Collection</code>的子类包括<code>List</code>、<code>Set</code>等众多子类，所以<code>toCollection</code>更加灵活。</p></blockquote><h3 id="聚合元素：toMap、toConcurrentMap"><a href="#聚合元素：toMap、toConcurrentMap" class="headerlink" title="聚合元素：toMap、toConcurrentMap"></a>聚合元素：toMap、toConcurrentMap</h3><p>这两个方法的作用是将聚合元素，重新组装为<code>Map</code>结构，也就是 k-v 结构。两者用法一样，区别是<code>toMap</code>返回的是<code>Map</code>，<code>toConcurrentMap</code>返回<code>ConcurrentMap</code>，也就是说，<code>toConcurrentMap</code>返回的是线程安全的 Map 结构。</p><p>比如，我们需要聚合<code>Student</code>的 id：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map11 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity()));</code></pre><p>但是，如果 id 有重复的，会抛出<code>java.lang.IllegalStateException: Duplicate key</code>异常，所以，为了保险起见，我们需要借助<code>toMap</code>另一个重载方法：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map2 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity(), (x, y) -&gt; x));</code></pre><p>可以看到，<code>toMap</code>有不同的重载方法，可以实现比较复杂的逻辑。比如，我们需要得到根据 id 分组的<code>Student</code>的姓名：</p><pre><code class="java">// {1=张三, 2=李四, 3=王五}final Map&lt;String, String&gt; map3 = students.stream()    .collect(Collectors.toMap(Student::getId, Student::getName, (x, y) -&gt; x));</code></pre><p>比如，我们需要得到相同年龄得分最高的<code>Student</code>对象集合：</p><pre><code class="java">// {10=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123), 11=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 12=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)}final Map&lt;Integer, Student&gt; map5 = students.stream()    .collect(Collectors.toMap(Student::getAge, Function.identity(), BinaryOperator.maxBy(Comparator.comparing(Student::getScore))));</code></pre><p>所以，<code>toMap</code>可玩性很高。</p><h3 id="分组：groupingBy、groupingByConcurrent"><a href="#分组：groupingBy、groupingByConcurrent" class="headerlink" title="分组：groupingBy、groupingByConcurrent"></a>分组：groupingBy、groupingByConcurrent</h3><p><code>groupingBy</code>与<code>toMap</code>都是将聚合元素进行分组，区别是，<code>toMap</code>结果是 1:1 的 k-v 结构，<code>groupingBy</code>的结果是 1:n 的 k-v 结构。</p><p>比如，我们对<code>Student</code>的年龄分组：</p><pre><code class="java">// List: {10=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], 11=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], 12=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Integer, List&lt;Student&gt;&gt; map1 = students.stream().collect(Collectors.groupingBy(Student::getAge));// Set: {10=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], 11=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], 12=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Integer, Set&lt;Student&gt;&gt; map12 = students.stream().collect(Collectors.groupingBy(Student::getAge, Collectors.toSet()));</code></pre><p>既然<code>groupingBy</code>也是分组，是不是也能够实现与<code>toMap</code>类似的功能，比如，根据 id 分组的<code>Student</code>：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map3 = students.stream()    .collect(Collectors.groupingBy(Student::getId, Collectors.collectingAndThen(Collectors.toList(), list -&gt; list.get(0))));</code></pre><p>为了对比，把<code>toMap</code>的写法放在这：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map2 = students.stream()    .collect(Collectors.toMap(Student::getId, Function.identity(), (x, y) -&gt; x));</code></pre><p>如果想要线程安全的<code>Map</code>，可以使用<code>groupingByConcurrent</code>。</p><h3 id="分组：partitioningBy"><a href="#分组：partitioningBy" class="headerlink" title="分组：partitioningBy"></a>分组：partitioningBy</h3><p><code>partitioningBy</code>与<code>groupingBy</code>的区别在于，<code>partitioningBy</code>借助<code>Predicate</code>断言，可以将集合元素分为<code>true</code>和<code>false</code>两部分。比如，按照年龄是否大于 11 分组：</p><pre><code class="java">// List: {false=[Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)], true=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Boolean, List&lt;Student&gt;&gt; map6 = students.stream().collect(Collectors.partitioningBy(s -&gt; s.getAge() &gt; 11));// Set: {false=[Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123), Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123)], true=[Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123)]}final Map&lt;Boolean, Set&lt;Student&gt;&gt; map7 = students.stream().collect(Collectors.partitioningBy(s -&gt; s.getAge() &gt; 11, Collectors.toSet()));</code></pre><h2 id="链接数据：joining"><a href="#链接数据：joining" class="headerlink" title="链接数据：joining"></a>链接数据：joining</h2><p>这个方法对<code>String</code>类型的元素进行聚合，拼接成一个字符串返回，作用与<code>java.lang.String#join</code>类似，提供了 3 个不同重载方法，可以实现不同的需要。比如：</p><pre><code class="java">// javagosqlStream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining());// java, go, sqlStream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining(&quot;, &quot;));// 【java, go, sql】Stream.of(&quot;java&quot;, &quot;go&quot;, &quot;sql&quot;).collect(Collectors.joining(&quot;, &quot;, &quot;【&quot;, &quot;】&quot;));</code></pre><h2 id="操作链：collectingAndThen"><a href="#操作链：collectingAndThen" class="headerlink" title="操作链：collectingAndThen"></a>操作链：collectingAndThen</h2><p>这个方法在<code>groupingBy</code>的例子中出现过，它是先对集合进行一次聚合操作，然后通过<code>Function</code>定义的函数，对聚合后的结果再次处理。</p><p>比如<code>groupingBy</code>中的例子：</p><pre><code class="java">// {1=Student(id=1, name=张三, birthday=2009-01-01, age=12, score=12.123), 2=Student(id=2, name=李四, birthday=2010-02-02, age=11, score=22.123), 3=Student(id=3, name=王五, birthday=2011-03-03, age=10, score=32.123)}final Map&lt;String, Student&gt; map3 = students.stream()    .collect(Collectors.groupingBy(Student::getId, Collectors.collectingAndThen(Collectors.toList(), list -&gt; list.get(0))));</code></pre><p>显示将结果聚合成<code>List</code>列表，然后取列表的第 0 个元素返回，通过这种方式，实现 1:1 的 map 结构。</p><p>再来一个复杂一些的，找到聚合元素中年龄数据正确的<code>Student</code>列表：</p><pre><code class="java">// []，结果为空，是因为例子中所有人的年龄都是对的students.stream()        .collect(                Collectors.collectingAndThen(Collectors.toList(), (                        list -&gt; list.stream()                                .filter(s -&gt; (LocalDate.now().getYear() - s.getBirthday().getYear()) != s.getAge())                                .collect(Collectors.toList()))                )        );</code></pre><blockquote><p>这个例子纯粹是为了使用<code>collectingAndThen</code>的用法，其实可以简化为：</p><pre><code class="java">students.stream()        .filter(s -&gt; (LocalDate.now().getYear() - s.getBirthday().getYear()) != s.getAge())        .collect(Collectors.toList());</code></pre></blockquote><h2 id="操作后聚合：mapping"><a href="#操作后聚合：mapping" class="headerlink" title="操作后聚合：mapping"></a>操作后聚合：mapping</h2><p><code>mapping</code>先通过<code>Function</code>函数处理数据，然后通过<code>Collector</code>方法聚合元素。比如，获取获取<code>students</code>的姓名列表：</p><pre><code class="java">// [张三, 李四, 王五]students.stream()        .collect(Collectors.mapping(Student::getName, Collectors.toList()));</code></pre><p>这种计算与<code>java.util.stream.Stream#map</code>方式类似：</p><pre><code class="java">// [张三, 李四, 王五]students.stream()        .map(Student::getName)        .collect(Collectors.toList());</code></pre><p>从这点上看，还是通过<code>java.util.stream.Stream#map</code>更清晰一些。</p><h2 id="聚合后操作：reducing"><a href="#聚合后操作：reducing" class="headerlink" title="聚合后操作：reducing"></a>聚合后操作：reducing</h2><p><code>reducing</code>提供了 3 个重载方法：</p><ul><li><code>public static &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; reducing(BinaryOperator&lt;T&gt; op)</code>：直接通过<code>BinaryOperator</code>操作，返回值是<code>Optional</code></li><li><code>public static &lt;T&gt; Collector&lt;T, ?, T&gt; reducing(T identity, BinaryOperator&lt;T&gt; op)</code>：预定默认值，然后通过<code>BinaryOperator</code>操作</li><li><code>public static &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? super T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</code>：预定默认值，通过<code>Function</code>操作元素，然后通过<code>BinaryOperator</code>操作</li></ul><p>比如，计算所有<code>students</code>的得分总数：</p><pre><code class="java">// Optional[66.369]，注意返回类型是Optionalstudents.stream()        .map(Student::getScore)        .collect(Collectors.reducing(Double::sum));// 66.369students.stream()        .map(Student::getScore)        .collect(Collectors.reducing(0.0, Double::sum));// 66.369students.stream()        .collect(Collectors.reducing(0.0, Student::getScore, Double::sum));</code></pre><p>同<code>mapping</code>，<code>reducing</code>的操作与<code>java.util.stream.Stream#reduce</code>方式类似：</p><pre><code class="java">// Optional[66.369]，注意返回类型是Optionalstudents.stream().map(Student::getScore).reduce(Double::sum);// 66.369students.stream().map(Student::getScore).reduce(0.0, Double::sum);</code></pre><p>在上文说到<code>maxBy</code>和<code>minBy</code>时，提到这两个函数就是通过<code>reducing</code>实现的。</p><blockquote><p>对于<code>mapping</code>和<code>reducing</code>，可以参考函数式编程中 map-reduce 的概念。</p></blockquote><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>本文主要讲解了 Java8 Stream 中 Collectors 定义的 24 个方法，这种流式计算逻辑，依靠 Fork/Join 框架，性能方面有很大的优势。如果没有掌握这些用法，可能在后续阅读代码时，会很吃力，毕竟，Java8 基本上已经是业界标杆了。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></li><li><a href="https://www.howardliu.cn/java-util-optional/">一文掌握 Java8 的 Optional 的 6 种操作</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-stream-collectors/">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116762456" target="_blank" rel="noopener">一文掌握 Java8 Stream 中 Collectors 的 24 个操作</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      一文掌握 Java8 Stream 中 Collectors 的 24 个操作。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="JDK8" scheme="https://www.howardliu.cn/tags/JDK8/"/>
    
      <category term="stream" scheme="https://www.howardliu.cn/tags/stream/"/>
    
      <category term="collectors" scheme="https://www.howardliu.cn/tags/collectors/"/>
    
  </entry>
  
  <entry>
    <title>面试真题：无重复字符的最长子串</title>
    <link href="https://www.howardliu.cn/longest-substring-without-repeating-character/"/>
    <id>https://www.howardliu.cn/longest-substring-without-repeating-character/</id>
    <published>2021-05-08T02:46:53.000Z</published>
    <updated>2021-05-08T02:46:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/altorithm/surfing-5628803_1920.jpg" alt="面试真题：无重复字符的最长子串"></p><p>你好，我是看山。</p><p>来一个算法题，面试之后查了一下，是 LeetCode 的第三题，难度中等。居然在面试过程中碰到 LeetCode 真题，事后总结一波。加深印象。</p><a id="more"></a><p>先看一下题目描述：</p><blockquote><p>给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</p><p>输入：s = “abcabcbb”<br>输出：3<br>解释：因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>输入：s = “pwwkew”<br>输出：3<br>解释：因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p></blockquote><p>看过题目之后，我最先想到的是一道数学题：一个线段上有 10 个点，求总共有多少的线段？如果是小朋友解题的话，一般就是，左手固定，右手向右移动，每移动一个点就加一个数，右手移动到末尾后，左手向右移动一个点，以此类推，知道最后一个点。这样就能够数出所有的线段数量，而且还不会乱。</p><p>其实上面这个算法题和我说的这个数学题的解法类似，采用小学生解法，只不过需要在数数的时候加一些判断，比如，线段中的点，有没有相同的。</p><p>来个图例：</p><p><img src="http://static.howardliu.cn/altorithm/WX20210508-115432.png" alt="无重复字符的最长子串"></p><p>根据图例写代码：</p><pre><code class="java">import java.util.HashSet;import java.util.Set;class Solution {    public static int lengthOfLongestSubstring(String s) {        if (s == null || s.isEmpty()) {            return 0;        }        final int len = s.length();        final Set&lt;Character&gt; sets = new HashSet&lt;&gt;();        int i = 0, j = 0, result = 0;        Character tmp ;        while (i &lt; len &amp;&amp; j &lt; len) {            tmp = s.charAt(j);            if (sets.contains(tmp)) {                sets.remove(s.charAt(i++));            } else {                sets.add(tmp);                result = Math.max(result, j++ - i + 1);            }        }        return result;    }}</code></pre><p>如果是面试，这个时候就可以交差了。既然是总结，就得再想一下这个解法有没有通用性。我们所采用的办法是，通过两个变量 i 和 j 指向计算元素，然后与 i 与 j 之间的元素进行判断，这种方式江湖称之为“双指针”。贴心的 LeetCode 也给过定义：</p><blockquote><p>双指针从广义上来说，是指用两个变量在线性结构上遍历而解决的问题。狭义上说，</p><ul><li>对于数组，指两个变量在数组上相向移动解决的问题；</li><li>对于链表，指两个变量在链表上同向移动解决的问题，也称为「快慢指针」问题。</li></ul><p>双指针算法通常不难，是基于暴力解法的优化，<strong>它们是很好的学习算法的入门问题</strong>。</p></blockquote><p>从 <a href="https://leetcode-cn.com/tag/two-pointers/problemset/" target="_blank" rel="noopener">这里</a> 可以找到所有 LeetCode 中关于双指针解法的题目，可以过足瘾。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/longest-substring-without-repeating-character/">面试真题：无重复字符的最长子串</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116545038" target="_blank" rel="noopener">面试真题：无重复字符的最长子串</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      找出不含有重复字符的最长子串的长度。
    
    </summary>
    
    
      <category term="算法" scheme="https://www.howardliu.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://www.howardliu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="双指针" scheme="https://www.howardliu.cn/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
      <category term="滑动窗口" scheme="https://www.howardliu.cn/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</title>
    <link href="https://www.howardliu.cn/spring-request-recorder/"/>
    <id>https://www.howardliu.cn/spring-request-recorder/</id>
    <published>2021-04-29T03:22:51.000Z</published>
    <updated>2021-04-29T03:22:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/spring/kingfisher-6146356_1920.jpg" alt="Spring 实战：自定义 Filter 优雅获取请求参数和响应结果"></p><p>你好，我是看山。</p><a id="more"></a><p>一个系统上线，肯定会或多或少的存在异常情况。为了更快更好的排雷，记录请求参数和响应结果是非常必要的。所以，Nginx 和 Tomcat 之类的 web 服务器，都提供了访问日志，可以帮助我们记录一些请求信息。</p><p>本文是在我们的应用中，定义一个<code>Filter</code>来实现记录请求参数和响应结果的功能。</p><p>有一定经验的都知道，如果我们在<code>Filter</code>中读取了<code>HttpServletRequest</code>或者<code>HttpServletResponse</code>的流，就没有办法再次读取了，这样就会造成请求异常。所以，我们需要借助 Spring 提供的<code>ContentCachingRequestWrapper</code>和<code>ContentCachingRequestWrapper</code>实现数据流的重复读取。</p><h2 id="定义-Filter"><a href="#定义-Filter" class="headerlink" title="定义 Filter"></a>定义 Filter</h2><p>通常来说，我们自定义的<code>Filter</code>是实现<code>Filter</code>接口，然后写一些逻辑，但是既然是在 Spring 中，那就借助 Spring 的一些特性。在我们的实现中，要继承<code>OncePerRequestFilter</code>实现我们的自定义实现。</p><p>从类名上推断，<code>OncePerRequestFilter</code>是每次请求只执行一次，但是，难道<code>Filter</code>在一次请求中还会执行多次吗？Spring 官方也是给出定义这个类的原因：</p><blockquote><p>Filter base class that aims to guarantee a single execution per request dispatch, on any servlet container. It provides a doFilterInternal(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, javax.servlet.FilterChain) method with HttpServletRequest and HttpServletResponse arguments.</p><p>As of Servlet 3.0, a filter may be invoked as part of a REQUEST or ASYNC dispatches that occur in separate threads. A filter can be configured in web.xml whether it should be involved in async dispatches. However, in some cases servlet containers assume different default configuration. Therefore sub-classes can override the method shouldNotFilterAsyncDispatch() to declare statically if they should indeed be invoked, once, during both types of dispatches in order to provide thread initialization, logging, security, and so on. This mechanism complements and does not replace the need to configure a filter in web.xml with dispatcher types.</p><p>Subclasses may use isAsyncDispatch(HttpServletRequest) to determine when a filter is invoked as part of an async dispatch, and use isAsyncStarted(HttpServletRequest) to determine when the request has been placed in async mode and therefore the current dispatch won’t be the last one for the given request.</p><p>Yet another dispatch type that also occurs in its own thread is ERROR. Subclasses can override shouldNotFilterErrorDispatch() if they wish to declare statically if they should be invoked once during error dispatches.</p></blockquote><p>也就是说，Spring 是为了兼容不同的 Web 容器，所以定义了只会执行一次的<code>OncePerRequestFilter</code>。</p><p>接下来开始定义我们的<code>Filter</code>类：</p><pre><code class="java">public class AccessLogFilter extends OncePerRequestFilter {    //... 这里有一些必要的属性    @Override    protected void doFilterInternal(final HttpServletRequest request,                                    final HttpServletResponse response,                                    final FilterChain filterChain)            throws ServletException, IOException {        // 如果是被排除的 uri，不记录 access_log        if (matchExclude(request.getRequestURI())) {            filterChain.doFilter(request, response);            return;        }        final String requestMethod = request.getMethod();        final boolean shouldWrapMethod = StringUtils.equalsIgnoreCase(requestMethod, HttpMethod.PUT.name())                || StringUtils.equalsIgnoreCase(requestMethod, HttpMethod.POST.name());        final boolean isFirstRequest = !isAsyncDispatch(request);        final boolean shouldWrapRequest = isFirstRequest &amp;&amp; !(request instanceof ContentCachingRequestWrapper) &amp;&amp; shouldWrapMethod;        final HttpServletRequest requestToUse = shouldWrapRequest ? new ContentCachingRequestWrapper(request) : request;        final boolean shouldWrapResponse = !(response instanceof ContentCachingResponseWrapper) &amp;&amp; shouldWrapMethod;        final HttpServletResponse responseToUse = shouldWrapResponse ? new ContentCachingResponseWrapper(response) : response;        final long startTime = System.currentTimeMillis();        Throwable t = null;        try {            filterChain.doFilter(requestToUse, responseToUse);        } catch (Exception e) {            t = e;            throw e;        } finally {            doSaveAccessLog(requestToUse, responseToUse, System.currentTimeMillis() - startTime, t);        }    }    // ... 这里是一些必要的方法</code></pre><blockquote><p>这段代码就是整个逻辑的核心所在，其他的内容从源码中找到。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个代码中，整体的逻辑没有特别复杂的地方，只需要注意几个关键点就可以了。</p><ol><li>默认的<code>HttpServletRequest</code>和<code>HttpServletResponse</code>中的流被读取一次之后，再次读取会失败，所以要使用<code>ContentCachingRequestWrapper</code>和<code>ContentCachingResponseWrapper</code>进行包装，实现重复读取。</li><li>既然我们可以自定义<code>Filter</code>，那我们依赖的组件中也可能会自定义<code>Filter</code>，更有可能已经对请求和响应对象进行过封装，所以，一定要先进行一步判断。也就是<code>request instanceof ContentCachingRequestWrapper</code>和<code>response instanceof ContentCachingResponseWrapper</code>。</li></ol><p>只要注意了这两点，剩下的都是这个逻辑的细化实现。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接下来我们就运行一遍，看看结果。先定义几种不同的请求：普通 get 请求、普通 post 请求、上传文件、下载文件，这四个接口几乎可以覆盖绝大部分场景。（因为都是比较简单的写法，源码就不赘述了，可以从文末的源码中找到）</p><p>先启动项目，然后借助 IDEA 的 http 请求工具：</p><pre><code class="script">###普通 get 请求GET http://localhost:8080/index/get?name=howard###普通 post 请求POST http://localhost:8080/index/postContent-Type: application/json{&quot;name&quot;:&quot;howard&quot;}###上传文件POST http://localhost:8080/index/uploadContent-Type: multipart/form-data; boundary=WebAppBoundary--WebAppBoundaryContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;history.txt&quot;Content-Type: multipart/form-data&lt;/Users/liuxh/history.txt--WebAppBoundary--###下载文件GET http://localhost:8080/index/download</code></pre><p>再看看打印的日志：</p><pre><code class="log">2021-04-29 19:44:57.495  INFO 83448 --- [nio-8080-exec-1] c.h.d.s.filter.AccessLogFilter           : time=44ms,ip=127.0.0.1,uri=/index/get,headers=[host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=null,responseContentType=text/plain;charset=UTF-8,params=name=howard,request=,response=2021-04-29 19:44:57.551  INFO 83448 --- [nio-8080-exec-2] c.h.d.s.filter.AccessLogFilter           : time=36ms,ip=127.0.0.1,uri=/index/post,headers=[content-type:application/json,content-length:17,host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=application/json,responseContentType=application/json,params=,request={&quot;name&quot;:&quot;howard&quot;},response={&quot;name&quot;:&quot;howard&quot;,&quot;timestamp&quot;:&quot;1619696697540&quot;}2021-04-29 19:44:57.585  INFO 83448 --- [nio-8080-exec-3] c.h.d.s.filter.AccessLogFilter           : time=20ms,ip=127.0.0.1,uri=/index/upload,headers=[content-type:multipart/form-data; boundary=WebAppBoundary,content-length:232,host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=multipart/form-data; boundary=WebAppBoundary,responseContentType=application/json,params=,request=,response={&quot;contentLength&quot;:&quot;0&quot;,&quot;contentType&quot;:&quot;multipart/form-data&quot;}2021-04-29 19:44:57.626  INFO 83448 --- [nio-8080-exec-4] c.h.d.s.filter.AccessLogFilter           : time=27ms,ip=127.0.0.1,uri=/index/download,headers=[host:localhost:8080,connection:Keep-Alive,user-agent:Apache-HttpClient/4.5.12 (Java/11.0.7),accept-encoding:gzip,deflate],status=200,requestContentType=null,responseContentType=application/octet-stream;charset=utf-8,params=,request=,response=</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>自定义<code>Filter</code>是比较简单的，只要能够注意几个关键点就可以了。不过后续还有扩展的空间，比如：</p><ol><li>定义排除的请求 uri，可以借助<code>AntPathMatcher</code>实现 ant 风格的定义</li><li>将请求日志单独存放，可以借助 logback 或者 log4j2 等框架的的日志配置实现，这样能更加方便的查找日志</li><li>与调用链技术结合，在请求日志中增加调用链的 TraceId 等，可以快速定位待查询的请求日志</li></ol><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>附上源码：<a href="https://github.com/howardliu-cn/effective-spring/tree/main/spring-filter" target="_blank" rel="noopener">https://github.com/howardliu-cn/effective-spring/tree/main/spring-filter</a></p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/spring-request-recorder/">Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116276032" target="_blank" rel="noopener">Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文是在我们的应用中，定义一个 Filter 来实现记录请求参数和响应结果的功能。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/tags/spring/"/>
    
      <category term="filter" scheme="https://www.howardliu.cn/tags/filter/"/>
    
  </entry>
  
  <entry>
    <title>Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</title>
    <link href="https://www.howardliu.cn/spring-beanpostprocessor/"/>
    <id>https://www.howardliu.cn/spring-beanpostprocessor/</id>
    <published>2021-04-25T09:03:15.000Z</published>
    <updated>2021-04-25T09:03:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/spring/pine-5541335_1920.jpg" alt="Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器"></p><p>你好，我是看山。</p><p>在分布式系统中，我们会需要 ID 生成器的组件，这个组件可以实现帮助我们生成顺序的或者带业务含义的 ID。</p><p>目前有很多经典的 ID 生成方式，比如数据库自增列（自增主键或序列）、Snowflake 算法、美团 Leaf 算法等等，所以，会有一些公司级或者业务级的 ID 生成器组件的诞生。本文就是通过 BeanPostProcessor 实现动态注入 ID 生成器的实战。</p><a id="more"></a><p>在 Spring 中，实现注入的方式很多，比如 springboot 的 starter，在自定义的 Configuration 中初始化 ID 生成器的 Bean，业务代码中通过<code>@AutoWired</code>或者<code>@Resource</code>注入即可，开箱即用。这种方式简单直接，但是缺点也是过于简单，缺少了使用方自定义的入口。</p><p>考虑一下实际场景，在同一个业务单据中，要保持 ID 的唯一，但是在不同单据中，可以重复。而且，这些算法在生成 ID 的时候，为了保持多线程返回结果唯一，都会锁定共享资源。如果不同业务，并发情景不同，可能低并发的业务被高并发的业务阻塞获取 ID，造成一些性能的损失。所以，我们要考虑将 ID 生成器，根据业务隔离开，这样 springboot 的 starter 就会显得不够灵活了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>根据上面的需求，我们可以分几步实现我们的逻辑：</p><ol><li>自定义属性注解，用于判断是否需要注入属性对象</li><li>定义 ID 生成器接口、实现类，以及工厂类，工厂类是为了根据定义创建不同的 ID 生成器实现对象</li><li>定义 BeanPostProcessor，查找使用自定义注解定义的属性，实现注入</li></ol><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><p>首先自定义一个注解，可以定义一个<code>value</code>属性，作为隔离业务的标识：</p><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.FIELD, ElementType.METHOD})public @interface IdGeneratorClient {    /**     * ID 生成器名称     *     * @return     */    String value() default &quot;DEFAULT&quot;;}</code></pre><h3 id="定义-ID-生成器"><a href="#定义-ID-生成器" class="headerlink" title="定义 ID 生成器"></a>定义 ID 生成器</h3><p>定义 ID 生成器的接口：</p><pre><code class="java">public interface IdGenerator {    String groupName();    long nextId();}</code></pre><p>实现 ID 生成器接口，偷懒使用<code>AtomicLong</code>实现自增，同时考虑 ID 生成器是分组的，通过<code>ConcurrentHashMap</code>实现 ID 生成器的持有：</p><pre><code class="java">class DefaultIdGenerator implements IdGenerator {    private static final Map&lt;String, AtomicLong&gt; ID_CACHE = new ConcurrentHashMap&lt;&gt;(new HashMap&lt;&gt;());    private final String groupName;    DefaultIdGenerator(final String groupName) {        this.groupName = groupName;        synchronized (ID_CACHE) {            ID_CACHE.computeIfAbsent(groupName, key -&gt; new AtomicLong(1));        }    }    @Override    public String groupName() {        return this.groupName;    }    @Override    public long nextId() {        return ID_CACHE.get(this.groupName).getAndIncrement();    }}</code></pre><p>如前面设计的，我们需要一个工厂类来创建 ID 生成器，示例中使用最简单的实现，我们真正使用的时候，还可以通过更加灵活的 SPI 实现（关于 SPI 的实现，这里挖个坑，后面专门写一篇填坑）：</p><pre><code class="java">public enum IdGeneratorFactory {    INSTANCE;    private static final Map&lt;String, IdGenerator&gt; ID_GENERATOR_MAP = new ConcurrentHashMap&lt;&gt;(new HashMap&lt;&gt;());    public synchronized IdGenerator create(final String groupName) {        return ID_GENERATOR_MAP.computeIfAbsent(groupName, key -&gt; new DefaultIdGenerator(groupName));    }}</code></pre><h3 id="定义-BeanPostProcessor"><a href="#定义-BeanPostProcessor" class="headerlink" title="定义 BeanPostProcessor"></a>定义 BeanPostProcessor</h3><p>前面都是属于基本操作，这里才是扩展的核心。我们的实现逻辑是：</p><ol><li>扫描 bean 的所有属性，然后找到定义了<code>IdGeneratorClient</code>注解的属性</li><li>获取注解的<code>value</code>值，作为 ID 生成器的分组标识</li><li>使用<code>IdGeneratorFactory</code>这个工厂类生成 ID 生成器实例，这里会返回新建的或已经定义的实例</li><li>通过反射将 ID 生成器实例写入 bean</li></ol><pre><code class="java">public class IdGeneratorBeanPostProcessor implements BeanPostProcessor {    @Override    public Object postProcessBeforeInitialization(final Object bean, final String beanName) throws BeansException {        return bean;    }    @Override    public Object postProcessAfterInitialization(final Object bean, final String beanName) throws BeansException {        parseFields(bean);        return bean;    }    private void parseFields(final Object bean) {        if (bean == null) {            return;        }        Class&lt;?&gt; clazz = bean.getClass();        parseFields(bean, clazz);        while (clazz.getSuperclass() != null &amp;&amp; !clazz.getSuperclass().equals(Object.class)) {            clazz = clazz.getSuperclass();            parseFields(bean, clazz);        }    }    private void parseFields(final Object bean, Class&lt;?&gt; clazz) {        if (bean == null || clazz == null) {            return;        }        for (final Field field : clazz.getDeclaredFields()) {            try {                final IdGeneratorClient annotation = AnnotationUtils.getAnnotation(field, IdGeneratorClient.class);                if (annotation == null) {                    continue;                }                final String groupName = annotation.value();                final Class&lt;?&gt; fieldType = field.getType();                if (fieldType.equals(IdGenerator.class)) {                    final IdGenerator idGenerator = IdGeneratorFactory.INSTANCE.create(groupName);                    invokeSetField(bean, field, idGenerator);                    continue;                }                throw new RuntimeException(&quot;未知字段类型无法初始化，bean: &quot; + bean + &quot;，field: &quot; + field);            } catch (Throwable t) {                throw new RuntimeException(&quot;初始化字段失败，bean=&quot; + bean + &quot;，field=&quot; + field, t);            }        }    }    private void invokeSetField(final Object bean, final Field field, final Object param) {        ReflectionUtils.makeAccessible(field);        ReflectionUtils.setField(field, bean, param);    }}</code></pre><p>实现<code>BeanPostProcessor</code>接口需要完成<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>两个方法的定义。下图是 Spring 中 Bean 的实例化过程：</p><p><img src="http://static.howardliu.cn/spring/1350888580_1225.jpg" alt="Spring 中 Bean 的实例化过程图示"></p><p>从图中可以知道，Spring 调用<code>BeanPostProcessor</code>的这两个方法时，bean 已经被实例化，所有能注入的属性都已经被注入了，是一个完整的 bean。而且两个方法的返回值，可以是原来的 bean 实例，也可以是包装后的实例，这就要看我们的定义了。</p><h3 id="测试我们的代码"><a href="#测试我们的代码" class="headerlink" title="测试我们的代码"></a>测试我们的代码</h3><p>写一个测试用例，验证我们的实现是否生效：</p><pre><code class="java">@SpringBootTestclass SpringBeanPostProcessorApplicationTests {    @IdGeneratorClient    private IdGenerator defaultIdGenerator;    @IdGeneratorClient(&quot;group1&quot;)    private IdGenerator group1IdGenerator;    @Test    void contextLoads() {        Assert.notNull(defaultIdGenerator, &quot;注入失败&quot;);        System.out.println(defaultIdGenerator.groupName() + &quot; =&gt; &quot; + defaultIdGenerator.nextId());        Assert.notNull(group1IdGenerator, &quot;注入失败&quot;);        for (int i = 0; i &lt; 5; i++) {            System.out.println(defaultIdGenerator.groupName() + &quot; =&gt; &quot; + defaultIdGenerator.nextId());            System.out.println(group1IdGenerator.groupName() + &quot; =&gt; &quot; + group1IdGenerator.nextId());        }    }}</code></pre><p>运行结果为：</p><pre><code class="log">DEFAULT =&gt; 1DEFAULT =&gt; 2group1 =&gt; 1DEFAULT =&gt; 3group1 =&gt; 2DEFAULT =&gt; 4group1 =&gt; 3DEFAULT =&gt; 5group1 =&gt; 4DEFAULT =&gt; 6group1 =&gt; 5</code></pre><p>可以看到，默认的 ID 生成器与定义名称为 group1 的 ID 生成器是分别生成的，符合预期。</p><h2 id="文末思考"><a href="#文末思考" class="headerlink" title="文末思考"></a>文末思考</h2><p>我们实现了通过<code>BeanPostProcessor</code>实现自动注入自定义的业务对象，上面的实现还比较简单，有很多可以扩展的地方，比如工厂方法实现，可以借助 SPI 的方式更加灵活的创建 ID 生成器对象。同时，考虑到分布式场景，我们还可以在 ID 生成器实现类中，通过注入 rpc 实例，实现远程 ID 生成逻辑。</p><p>玩法无限，就看我们的想象了。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>附上源码：<a href="https://github.com/howardliu-cn/effective-spring/tree/main/spring-beanpostprocessor" target="_blank" rel="noopener">https://github.com/howardliu-cn/effective-spring/tree/main/spring-beanpostprocessor</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://howtodoinjava.com/spring-core/spring-bean-post-processors/" target="_blank" rel="noopener">Spring BeanPostProcessor Example</a></li><li><a href="https://www.baeldung.com/spring-beanpostprocessor" target="_blank" rel="noopener">Spring BeanPostProcessor</a></li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a></li><li><a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a></li><li><a href="https://www.howardliu.cn/spring-beanpostprocessor/">Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></li><li><a href="https://www.howardliu.cn/spring-request-recorder/">Spring 实战：自定义 Filter 优雅获取请求参数和响应结果</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/spring-beanpostprocessor/">Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/116139540" target="_blank" rel="noopener">Spring 实战：通过 BeanPostProcessor 动态注入 ID 生成器</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      本文通过实战的方式，了解 BeanPostProcessor 的作用。
    
    </summary>
    
    
      <category term="spring" scheme="https://www.howardliu.cn/categories/spring/"/>
    
    
      <category term="BeanPostProcessor" scheme="https://www.howardliu.cn/tags/BeanPostProcessor/"/>
    
      <category term="实战" scheme="https://www.howardliu.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发基础（五）：面试实战之多线程顺序打印</title>
    <link href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/"/>
    <id>https://www.howardliu.cn/java-concurrency-ordered-thread-print/</id>
    <published>2021-04-11T08:52:20.000Z</published>
    <updated>2021-04-11T08:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/plant-3263600_1920.jpg" alt="Java 并发基础（五）：面试实战之多线程顺序打印"></p><p>你好，我是看山。</p><p>来个面试题，让大家练练手。这个题在阿里和小米都被问过，所以放在这个抛砖引玉，期望能够得到一个更佳的答案。</p><a id="more"></a><p>实现 3 个线程 A、B、C，A 线程持续打印“A”，B 线程持续打印“B”，C 线程持续打印“C”，启动顺序是线程 C、线程 B、线程 A，打印的结果是：ABC。</p><h2 id="解法一：状态位变量控制"><a href="#解法一：状态位变量控制" class="headerlink" title="解法一：状态位变量控制"></a>解法一：状态位变量控制</h2><p>这个问题考察的是多线程协同顺序执行。也就是第一个线程最先达到执行条件，开始执行，执行完之后，第二个线程达到执行条件，开始执行，以此类推。可以想到的是，通过状态位来表示线程执行的条件，多个线程自旋等待状态位变化。</p><p>线上代码：</p><pre><code class="java">import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ABCThread {    private static final Lock lock = new ReentrantLock();    private static volatile int state = 0;    private static final Thread threadA = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 0) {                    System.out.println(&quot;A&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;A thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    private static final Thread threadB = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 1) {                    System.out.println(&quot;B&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;B thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    private static final Thread threadC = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 2) {                    System.out.println(&quot;C&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;C thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    public static void main(String[] args) {        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>可以看到，状态位<code>state</code>使用<code>volatile</code>修饰，是希望一个线程修改状态位值之后，其他线程可以读取到刚修改的数据，这个属于 Java 内存模型的范围，后续会有单独的章节描述。</p><p>这个可以解题，但是却有很多性能上的损耗。因为每个进程都在自旋检查状态值<code>state</code>是否符合条件，而且自旋过程中会有获取锁的过程，代码中在不符合条件时打印了一些内容，比如：<code>System.out.println(&quot;A thread &amp; state = &quot; + state);</code>，我们可以运行一下看看结果：</p><pre><code class="log">C thread &amp; state = 0...67行C thread &amp; state = 0B thread &amp; state = 0...43行B thread &amp; state = 0AC thread &amp; state = 1...53行C thread &amp; state = 1BC</code></pre><p>可以看到，在A线程获取到锁之前，C线程和B线程自旋了100多次，然后A线程才获取机会获取锁和打印。然后在B线程获取锁之前，C线程又自旋了53次。性能损耗可见一斑。</p><h2 id="解法二：Condition实现条件判断"><a href="#解法二：Condition实现条件判断" class="headerlink" title="解法二：Condition实现条件判断"></a>解法二：Condition实现条件判断</h2><p>既然无条件自旋浪费性能，那就加上条件自旋。</p><p>代码如下：</p><pre><code class="java">import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ABCThread2 {    private static final Lock lock = new ReentrantLock();    private static volatile int state = 0;    private static final Condition conditionA = lock.newCondition();    private static final Condition conditionB = lock.newCondition();    private static final Condition conditionC = lock.newCondition();    private static final Thread threadA = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 0) {                    System.out.println(&quot;A await start&quot;);                    conditionA.await();                    System.out.println(&quot;A await end&quot;);                }                System.out.println(&quot;A&quot;);                state++;                conditionB.signal();                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    private static final Thread threadB = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 1) {                    System.out.println(&quot;B await start&quot;);                    conditionB.await();                    System.out.println(&quot;B await end&quot;);                }                System.out.println(&quot;B&quot;);                state++;                conditionC.signal();                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    private static final Thread threadC = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 2) {                    System.out.println(&quot;C await start&quot;);                    conditionC.await();                    System.out.println(&quot;C await end&quot;);                }                System.out.println(&quot;C&quot;);                state++;                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    public static void main(String[] args) {        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>通过<code>Lock</code>锁的<code>Condition</code>实现有条件自旋，运行结果如下：</p><pre><code class="log">C await startB await startAB await endBC await endC</code></pre><p>可以从运行结果看到，C线程发现自己不符合要求，就通过<code>conditionC.await();</code>释放锁，然后等待条件被唤醒后重新获得锁。然后是B线程，最后是A线程开始执行，发现符合条件，直接运行，然后唤醒B线程的锁条件，依次类推。这种方式其实和信号量很类似。</p><h2 id="解法三：信号量"><a href="#解法三：信号量" class="headerlink" title="解法三：信号量"></a>解法三：信号量</h2><p>先上代码：</p><pre><code class="java">import java.util.concurrent.Semaphore;class ABCThread3 {    private static Semaphore semaphoreA = new Semaphore(1);    private static Semaphore semaphoreB = new Semaphore(1);    private static Semaphore semaphoreC = new Semaphore(1);    private static final Thread threadA = new Thread(() -&gt; {        try {            semaphoreA.acquire();            System.out.println(&quot;A&quot;);            semaphoreB.release();        } catch (InterruptedException e) {            e.printStackTrace();        }    });    private static final Thread threadB = new Thread(() -&gt; {        try {            semaphoreB.acquire();            System.out.println(&quot;B&quot;);            semaphoreC.release();        } catch (InterruptedException e) {            e.printStackTrace();        }    });    private static final Thread threadC = new Thread(() -&gt; {        try {            semaphoreC.acquire();            System.out.println(&quot;C&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }    });    public static void main(String[] args) throws InterruptedException {        semaphoreB.acquire();        semaphoreC.acquire();        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>代码中执行前先执行了<code>semaphoreB.acquire();</code>和<code>semaphoreC.acquire();</code>，是为了将B和C的信号释放，这个时候，就能够阻塞B线程、C线程中信号量的获取，直到顺序获取了信号值。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>这个题是考察大家对线程执行顺序和线程之间协同的理解，文中所实现的三种方式，都能解题，只不过代码复杂度和性能有差异。因为其中涉及很多多线程的内容，后续会单独开文说明每个知识点。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a></li><li><a href="https://www.howardliu.cn/main-thread-waiting-for-the-end-of-subthread/">Java 并发基础（二）：主线程等待子线程结束</a></li><li><a href="https://www.howardliu.cn/talk-about-CountDownLatch-again/">Java 并发基础（三）：再谈 CountDownLatch</a></li><li><a href="https://www.howardliu.cn/talk-about-CyclicBarrier-again/">Java 并发基础（四）：再谈 CyclicBarrier</a></li><li><a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115609160" target="_blank" rel="noopener">Java 并发基础（五）：面试实战之多线程顺序打印</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      实现 3 个线程 A、B、C，A 线程持续打印“A”，B 线程持续打印“B”，C 线程持续打印“C”，启动顺序是线程 C、线程 B、线程 A，打印的结果是：ABC。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="concurrency" scheme="https://www.howardliu.cn/tags/concurrency/"/>
    
      <category term="thread" scheme="https://www.howardliu.cn/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发基础（一）：synchronized 锁同步</title>
    <link href="https://www.howardliu.cn/java-concurrency-synchronized/"/>
    <id>https://www.howardliu.cn/java-concurrency-synchronized/</id>
    <published>2021-03-28T07:55:40.000Z</published>
    <updated>2021-03-28T07:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/seagull-5884998_1920.jpg" alt="Java 并发基础（一）：synchronized 锁同步"></p><p>你好，我是看山。</p><p>synchronized 是 java 内置的同步锁实现，一个关键字实现对共享资源的锁定。synchronized 有 3 种使用场景，场景不同，加锁对象也不同：</p><ol><li>普通方法：锁对象是当前实例对象</li><li>静态方法：锁对象是类的 Class 对象</li><li>方法块：锁对象是 synchronized 括号中的对象</li></ol><a id="more"></a><h2 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h2><p>synchronized 是通过进入和退出 Monitor 对象实现锁机制，代码块通过一对 monitorenter/monitorexit 指令实现。在编译后，monitorenter 指令插入到同步代码块的开始位置，monitorexit 指令插入到方法结束和异常处，JVM 要保证 monitorenter 和 monitorexit 成对出现。任何对象都有一个 Monitor 与之关联，当且仅当一个 Monitor 被持有后，它将处于锁状态。</p><p>在执行 monitorenter 时，首先尝试获取对象的锁，如果对象没有被锁定或者当前线程持有锁，锁的计数器加 1；相应的，在执行 monitorexit 指令时，将锁的计数器减 1。当计数器减到 0 时，锁释放。如果在 monitorenter 获取锁失败，当前线程会被阻塞，直到对象锁被释放。</p><p>在 JDK6 之前，Monitor 的实现是依靠操作系统内部的互斥锁实现（一般使用的是 Mutex Lock 实现），线程阻塞会进行用户态和内核态的切换，所以同步操作是一个无差别的重量级锁。</p><p>后来，JDK 对 synchronized 进行升级，为了避免线程阻塞时在用户态与内核态之间切换线程，会在操作系统阻塞线程前，加入自旋操作。然后还实现 3 种不同的 Monitor：偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）、重量级锁。在 JDK6 之后，synchronized 的性能得到很大的提升，相比于 ReentrantLock 而言，性能并不差，只不过 ReentrantLock 使用起来更加灵活。</p><h2 id="适应性自旋（Adaptive-Spinning）"><a href="#适应性自旋（Adaptive-Spinning）" class="headerlink" title="适应性自旋（Adaptive Spinning）"></a>适应性自旋（Adaptive Spinning）</h2><p>synchronized 对性能影响最大的是阻塞的实现，挂起线程和恢复线程都需要操作系统帮助完成，需要从用户态转到内核态，状态转换需要耗费很多 CPU 时间。</p><p>在我们大多数的应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间挂起和回复线程消耗的时间不值得。而且，现在大多数的处理器都是多核处理器，如果让后一个线程再等一会，不释放 CPU，等前一个释放锁，后一个线程立马获取锁执行任务就行。这就是所谓的自旋，让线程执行一个忙循环，自己在原地转一会，每转一圈看看锁释放没有，释放了直接获取锁，没有释放就再转一圈。</p><p>自旋锁是在 JDK 1.4.2 引入（使用<code>-XX:+UseSpinning</code>参数打开），JDK 1.6 默认打开。自旋锁不能代替阻塞，因为自旋等待虽然避免了线程切换的开销，但是它要占用 CPU 时间，如果锁占用时间短，自旋等待效果挺好，反之，则是性能浪费。所以在 JDK 1.6 中引入了自适应自旋锁：如果同一个锁对象，自旋等待刚成功，且持有锁的线程正在运行，那本次自旋很有可能成功，会允许自旋等待持续时间长一些。反之，如果对于某个锁，自旋很少成功，那之后很有可能直接省略自旋过程，避免浪费 CPU 资源。</p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>synchronized 用的锁存在于 Java 对象头里，对象头里的 Mark Word 里存储的数据会随标志位的变化而变化，变化如下：</p><p><img src="http://static.howardliu.cn/java/F7DE8310-E000-4B64-A3AA-9463B483BDF1.jpg" alt="Java 对象头 Mark Word"></p><h3 id="偏向锁（Biased-Locking）"><a href="#偏向锁（Biased-Locking）" class="headerlink" title="偏向锁（Biased Locking）"></a>偏向锁（Biased Locking）</h3><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引入偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。</p><h4 id="偏向锁获取"><a href="#偏向锁获取" class="headerlink" title="偏向锁获取"></a>偏向锁获取</h4><ol><li>当锁对象第一次被线程获取时，对象头的标志位设为 01，偏向模式设为 1，表示进入偏向模式。</li><li>测试线程 ID 是否指向当前线程，如果是，执行同步代码块，如果否，进入 3</li><li>使用 CAS 操作把获得到的这个锁的线程 ID 记录在对象的 Mark Word 中。如果成功，执行同步代码块，如果失败，说明存在过其他线程持有锁对象的偏向锁，开始尝试当前线程获取偏向锁</li><li>当到达全局安全点时（没有字节码正在执行），会暂停拥有偏向锁的线程，检查线程状态。如果线程已经结束，则将对象头设置成无锁状态（标志位为“01”），然后重新偏向新的线程；如果线程仍然活着，撤销偏向锁后升级到轻量级锁状态（标志位为“00”），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。</li></ol><h4 id="偏向锁释放"><a href="#偏向锁释放" class="headerlink" title="偏向锁释放"></a>偏向锁释放</h4><p>偏向锁的释放采用的是惰性释放机制：只有等到竞争出现，才释放偏向锁。释放过程就是上面说的第 4 步，这里不再赘述。</p><h4 id="关闭偏向锁"><a href="#关闭偏向锁" class="headerlink" title="关闭偏向锁"></a>关闭偏向锁</h4><p>偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，只有当存在较多不会真正竞争的同步块时，才能体现出明显改善。实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。</p><p>所以如果你确定应用程序里的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，那么程序默认会进入轻量级锁状态。</p><h3 id="轻量级锁（Lightweight-Locking）"><a href="#轻量级锁（Lightweight-Locking）" class="headerlink" title="轻量级锁（Lightweight Locking）"></a>轻量级锁（Lightweight Locking）</h3><p>轻量级锁不是用来代替重量级锁的，它的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗。</p><h4 id="轻量级锁获取"><a href="#轻量级锁获取" class="headerlink" title="轻量级锁获取"></a>轻量级锁获取</h4><ol><li>如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如下图所示：<br> <img src="http://static.howardliu.cn/java/C9DCD644-0694-4FF3-8E2E-0FCEA7C0CB5E.png" alt="Lock Record"></li><li>拷贝对象头中的 Mark Word 复制到锁记录（Lock Record）中。</li><li>拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock record 里的 owner 指针指向 object mark word。</li><li>如果成功，当前线程持有该对象锁，将对象头的 Mark Word 锁标志位设置为“00”，表示对象处于轻量级锁定状态，执行同步代码块。这时候线程堆栈与对象头的状态如下图所示：<br><img src="http://static.howardliu.cn/java/3F5C415F-2953-4987-A38E-BB4AB97600AB.png" alt="Lock Record"></li><li>如果更新失败，检查对象头的 Mark Word 是否指向当前线程的栈帧，如果是，说明当前线程拥有锁，直接执行同步代码块。</li><li>如果否，说明多个线程竞争锁，如果当前只有一个等待线程，通过自旋尝试获取锁。当自旋超过一定次数，或又来一个线程竞争锁，轻量级锁膨胀为重量级锁。重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</li></ol><h4 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h4><p>轻量级锁解锁的时机是，当前线程同步块执行完毕。</p><ol><li>通过 CAS 操作尝试把线程中复制的 Displaced Mark Word 对象替换当前的 Mark Word。</li><li>如果成功，整个同步过程完成</li><li>如果失败，说明存在竞争，且锁膨胀为重量级锁。释放锁的同时，会唤醒被挂起的线程。</li></ol><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>轻量级锁适应的场景是线程近乎交替执行同步块的情况，如果存在同一时间访问相同锁对象时（第一个线程持有锁，第二个线程自旋超过一定次数），轻量级锁会膨胀为重量级锁，Mark Word 的锁标记位更新为 10，Mark Word 指向互斥量（重量级锁）。</p><p>重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）。操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 JDK 1.6 之前，synchronized 重量级锁效率低的原因。</p><p>下图是偏向锁、轻量级锁、重量级锁之间转换对象头 Mark Word 数据转变：</p><p><img src="http://static.howardliu.cn/java/640.png" alt="偏向锁、轻量级锁、重量级锁之间转换 "></p><p>网上有一个比较全的锁升级过程：</p><p><img src="http://static.howardliu.cn/java/synchronized.png" alt="锁升级过程"></p><h2 id="锁消除（Lock-Elimination）"><a href="#锁消除（Lock-Elimination）" class="headerlink" title="锁消除（Lock Elimination）"></a>锁消除（Lock Elimination）</h2><p>锁消除说的是虚拟机即时编译器在运行过程中，对于一些同步代码，如果检测到不可能存在共享数据竞争情况，就会删除锁。也就是说，即时编译器根据情况删除不必要的加锁操作。</p><p>锁消除的依据是逃逸分析。简单地说，逃逸分析就是分析对象的动态作用域。分三种情况：</p><ul><li>不逃逸：对象的作用域只在本线程本方法</li><li>方法逃逸：对象在方法内定义后，被外部方法所引用</li><li>线程逃逸：对象在方法内定义后，被外部线程所引用</li></ul><p>即时编译器会针对对象的不同情况进行优化处理：</p><ul><li>对象栈上分配（Stack Allocations，HotSpot 不支持）：直接在栈上创建对象。</li><li>标量替换（Scalar Replacement）：将对象拆散，直接创建被方法使用的成员变量。前提是对象不会逃逸出方法范围。</li><li>同步消除（Synchronization Elimination）：就是锁消除，前提是对象不会逃逸出线程。</li></ul><p>对于锁消除来说，就是逃逸分析中，那些不会逃出线程的加锁对象，就可以直接删除同步锁。</p><p>通过代码看一个例子：</p><pre><code class="java">public void elimination1() {    final Object lock = new Object();    synchronized (lock) {        System.out.println(&quot;lock 对象没有只会作用域本线程，所以会锁消除。&quot;);    }}public String elimination2() {    final StringBuffer sb = new StringBuffer();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb.toString();}public StringBuffer notElimination() {    final StringBuffer sb = new StringBuffer();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb;}</code></pre><p><code>elimination1()</code>中的锁对象<code>lock</code>作用域只是方法内，没有逃逸出线程，<code>elimination2()</code>中的<code>sb</code>也就这样，所以这两个方法的同步锁都会被消除。但是<code>notElimination()</code>方法中的<code>sb</code>是方法返回值，可能会被其他方法修改或者其他线程修改，所以，单看这个方法，不会消除锁，还得看调用方法。</p><h2 id="锁粗化（Lock-Coarsening）"><a href="#锁粗化（Lock-Coarsening）" class="headerlink" title="锁粗化（Lock Coarsening）"></a>锁粗化（Lock Coarsening）</h2><p>原则上，我们在编写代码的时候，要将同步块作用域的作用范围限制的尽量小。使得需要同步的操作数量尽量少，当存在锁竞争时，等待线程尽快获取锁。但是有时候，如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><p>比如上面例子中的<code>elimination2()</code>方法中，<code>StringBuffer</code>的<code>append</code>是同步方法，频繁操作时，会进行锁粗化，最后结果会类似于（只是类似，不是真实情况）：</p><pre><code class="java">public String elimination2() {    final StringBuilder sb = new StringBuilder();    synchronized (sb) {        sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);        return sb.toString();    }}</code></pre><p>或者</p><pre><code class="java">public synchronized String elimination3() {    final StringBuilder sb = new StringBuilder();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb.toString();}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li>同步操作中影响性能的有两点：<ol><li>加锁解锁过程需要额外操作</li><li>用户态与内核态之间转换代价比较大</li></ol></li><li>synchronized 在 JDK 1.6 中有大量优化：分级锁（偏向锁、轻量级锁、重量级锁）、锁消除、锁粗化等。</li><li>synchronized 复用了对象头的 Mark Word 状态位，实现不同等级的锁实现。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机》</li><li>《Java 并发编程的艺术》</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a></li><li><a href="https://www.howardliu.cn/main-thread-waiting-for-the-end-of-subthread/">Java 并发基础（二）：主线程等待子线程结束</a></li><li><a href="https://www.howardliu.cn/talk-about-CountDownLatch-again/">Java 并发基础（三）：再谈 CountDownLatch</a></li><li><a href="https://www.howardliu.cn/talk-about-CyclicBarrier-again/">Java 并发基础（四）：再谈 CyclicBarrier</a></li><li><a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115286598" target="_blank" rel="noopener">Java 并发基础（一）：synchronized 锁同步</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      synchronized 是 java 内置的同步锁实现，一个关键字实现对共享资源的锁定。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="concurrency" scheme="https://www.howardliu.cn/tags/concurrency/"/>
    
      <category term="synchronized" scheme="https://www.howardliu.cn/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（三）：Docker 命令</title>
    <link href="https://www.howardliu.cn/docker-commands/"/>
    <id>https://www.howardliu.cn/docker-commands/</id>
    <published>2021-03-19T12:36:47.000Z</published>
    <updated>2021-03-19T12:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/breakwater-6017041_1920.jpg" alt="Docker 教程（三）：Docker 命令"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第三篇。</p></blockquote><a id="more"></a><p>我们通过 Docker 命令与操作 Docker 服务，可以构建 Docker 镜像、运行 Docker 容器、将 Docker 镜像推送到远程等。本文主要介绍一些常用的 Docker 命令。</p><p>Docker 有很多命令，本文不会介绍所有的命令，如果需要完整的命令教程，可以参考 <a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">Docker command line reference</a>。</p><p>请注意，根据在 Linux 系统上安装 Docker 的方式，可能需要在所有命令前面加上<code>sudo</code>，使用 root 权限运行他们。比如：</p><pre><code class="bash">sudo docker build .</code></pre><p>… 而不仅仅是：</p><pre><code class="bash">docker build .</code></pre><h2 id="Docker-命令行工具"><a href="#Docker-命令行工具" class="headerlink" title="Docker 命令行工具"></a>Docker 命令行工具</h2><p>在 Linux 系统中安装 Docker 时，会安装一个名为<code>docker</code>的命令行工具，可以在 Linux 命令行执行。</p><p><code>docker</code>有很多的参数，不同的参数作用不同，可以指挥 Docker 做出不同的行为，可以认为是给 Docker 的命令。以下是<code>docker</code>命令示例：</p><pre><code class="bash">docker build .</code></pre><p>这个示例中包含三部分：<code>docker</code>命令、参数<code>build</code>、参数<code>.</code>。</p><p>参数<code>build</code>是一个 Docker 命令，换句话说，是一个给 docker 可执行命令行的命令。通常，docker 命令行的第一个参数都是 Docker 命令。</p><p>参数<code>.</code>是<code>build</code>命令的参数。</p><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p><code>docker build</code>命令是调用 Docker 从 Dockerfile 文件构建 docker 镜像，要使用<code>docker build</code>命令，必须告诉它从哪个 Dockerfile 文件生成镜像。关于 Dockerfile 的内容，可以查看 <a href="https://www.howardliu.cn/docker-dockerfile/">这里</a>。以下是<code>docker build</code>命令示例：</p><pre><code class="bash">docker build .</code></pre><p>参数<code>.</code>表示从当前目录找到 Dockerfile 文件。</p><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><p><code>docker images</code>命令是列出本机的 Docker 镜像，以下是<code>docker images</code>命令示例：</p><pre><code class="bash">docker images</code></pre><p>运行上述命令会输出类似下面的内容：</p><pre><code class="text">REPOSITORY       TAG        IMAGE ID        CREATED          SIZEhello-world      latest     fce289e99eb9    9 months ago     1.84kB</code></pre><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p><code>docker run</code>命令用来基于给定的 Docker 镜像运行 Docker 容器，<code>docker run</code>的参数，可以是 Docker 镜像的名称或 ID，以下是运行 Docker 容器的示例：</p><pre><code class="bash">docker run hello-world</code></pre><p>这个例子会基于<code>hello-world</code>镜像运行 Docker 容器。</p><p>我们还可以通过 Docker 镜像 ID 运行 Docker 容器，命令如下：</p><pre><code class="bash">docker run fce289e99eb9</code></pre><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><p><code>docker ps</code>命令用于显示当前系统中正在运行的 Docker 容器，示例如下：</p><pre><code class="bash">docker ps</code></pre><p>注意，一些 Docker 容器会在完成任务后立即关闭，在<code>docker ps</code>的结果列表中，这种 Docker 容器很有可能会很长时间都不可见。</p><p>【译者注：本文就 4 个命令，还有很多常用的命令没有提到，比如<code>docker exec</code>之类的。其实，对于 Docker 命令行来说，我们可以先浏览一遍，知道个大概，等有需要的时候，重点看一下。个人感觉，命令的需要关键是要经常用。如果不用，转眼就忘，可以类比 Linux 命令。】</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/docker-commands.html" target="_blank" rel="noopener">Docker Commands</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115048842" target="_blank" rel="noopener">Docker 教程（三）：Docker 命令</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      我们通过 Docker 命令与操作 Docker 服务，可以构建 Docker 镜像、运行 Docker 容器、将 Docker 镜像推送到远程等。本文主要介绍一些常用的 Docker 命令。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（二）：Dockerfile</title>
    <link href="https://www.howardliu.cn/docker-dockerfile/"/>
    <id>https://www.howardliu.cn/docker-dockerfile/</id>
    <published>2021-03-13T15:30:08.000Z</published>
    <updated>2021-03-13T15:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/shops-5992277_1920.jpg" alt="Docker 教程（二）：Dockerfile"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第二篇。</p></blockquote><a id="more"></a><p>Dockerfile 包含一组关于如何构建 Docker 镜像的说明，通过<code>docker build</code>命令执行 Dockerfile 文件，可以构建一个 Docker 镜像，本文介绍了如何编写 Dockerfile 文件以及构建一个 Docker 镜像。</p><h2 id="Dockerfile-的好处"><a href="#Dockerfile-的好处" class="headerlink" title="Dockerfile 的好处"></a>Dockerfile 的好处</h2><p>Dockerfile 文件以书面形式说明了如何构建一个 Docker 镜像，Docker 镜像通常包含如下内容：</p><ul><li>首先需要一个基本的 Docker 镜像，在这个基础 Docker 镜像上构建自己的 Docker 镜像。</li><li>一组需要安装在 Docker 镜像中的工具和应用。</li><li>一组需要复制到 Docker 镜像中的文件（比如配置文件）。</li><li>可能需要在防火墙中打开的网络（TPC/UDP）端口或其他。</li><li>等等。</li></ul><p>首先，在 Dockerfile 文件中以书面形式说明这些，就意味着，我们不用特意记住应用程序如何安装，包括操作系统什么要求、需要安装的应用程序、需要赋值的文件、需要打开的网络端口等，这些内容都被记录在 Dockerfile 中。</p><p>另外，通过 Dockerfile 文件构建 Docker 镜像，我们不需要手动执行这些繁琐重复且容易出错的工作。Docker 会自动做这些事情，简单、快速、且不容易出错。</p><p>第三，我们很容易和其他人分享 Dockerfile 文件，并且他们可以自己构建 Docker 镜像。</p><p>第四，Dockerfile 很容易存储在 Git 这样的版本控制器中，这样就可以跟踪 Dockerfile（服务器、应用配置）的变更记录。版本控制器也可以很容易的让人们协同合作，比如在 Dockerfile 上，以及分享 Dockerfile。</p><h2 id="Dockerfile-的结构"><a href="#Dockerfile-的结构" class="headerlink" title="Dockerfile 的结构"></a>Dockerfile 的结构</h2><p>Dockerfile 包含一组指令，每个指令有一个命令和参数组成，类似于命令行可执行文件。下面是一个 Dockerfile 简单示例：</p><pre><code class="dockerfile"># 基础镜像FROM ubuntu:latest# 这里可以有更多安装软件和复制文件到镜像中的说明。COPY    /myapp/target/myapp.jar    /myapp/myapp.jar# 在 Docker 容器中执行的命令。CMD echo Starting Docker Container</code></pre><h2 id="Docker-基础镜像"><a href="#Docker-基础镜像" class="headerlink" title="Docker 基础镜像"></a>Docker 基础镜像</h2><p>Docker 镜像是由层组成，每一层都会为最终的 Docker 镜像添加一些内容。每一个层实际上都是一个单独的 Docker 镜像，所以说，Docker 镜像是由一个或多个层镜像组成，我们可以在其上添加自己的层。</p><p>当通过 Dockerfile 文件指定自己的 Docker 镜像时，通常是从一个 Docker 基础镜像开始。这是另一个 Docker 镜像，可以在其上构建自己的 Docker 镜像。这个 Docker 基础镜像本身可能也包含多个层，并且是基于另一个基础镜像构建的。</p><p>我们可以使用<code>From</code>命令在 Dockerfile 文件中指定 Docker 镜像作为基础镜像，如下节所述。</p><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p><code>MAINTAINER</code>命令用于说明谁在维护这个 Dockerfile 文件。比如：</p><pre><code class="dockerfile">MAINTAINER   Joe Blocks &lt;joe@blocks.com&gt;</code></pre><p><code>MAINTAINER</code>命令并不常用，因为这类信息在 Git 存储或其他地方有了。</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p><code>FROM</code>命令用于指定 Docker 基础镜像，如果是从原始 Linux 镜像开始，可以使用如下命令：</p><pre><code class="dockerfile"># 基础镜像FROM ubuntu:latest</code></pre><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p><code>CMD</code>命令用于指定启动 Docker 容器是需要执行的命令，该容器是基于此 Dockerfile 构建的 Docker 镜像，下面是一些 Dockerfile 的<code>CMD</code>示例：</p><pre><code class="dockerfile">CMD echo Docker container started.</code></pre><p>本例是打印“Docker container started”这行文本。</p><p>下一个<code>CMD</code>示例是启动一个 java 应用：</p><pre><code class="dockerfile">CMD java -cp /myapp/myapp.jar com.jenkov.myapp.MainClass arg1 arg2 arg3</code></pre><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code>命令将一个或多个文件从主机（从 Dockerfile 文件构建 Docker 镜像的机器）复制到 Docker 镜像中，可以复制的内容包括文件或目录，下面是一个示例：</p><pre><code class="dockerfile">COPY    /myapp/target/myapp.jar    /myapp/myapp.jar</code></pre><p>这个例子是把主机的/myapp/target/myapp.jar 文件复制到 Docker 进行中的/myapp/myapp.jar 文件。第一个参数是主机路径（从哪里来），第二个参数是 Docker 镜像的路径（到哪里去）。</p><p>我们还可以复制一个目录到 Docker 镜像中，比如：</p><pre><code class="dockerfile">COPY    /myapp/config/prod    /myapp/config</code></pre><p>这个例子是把主机的/myapp/config/prod 目录复制到 Docker 镜像中的/myapp/config 目录。</p><p>我们还可以复制多个文件到 Docker 镜像中的一个目录中，比如：</p><pre><code class="dockerfile">COPY    /myapp/config/prod/conf1.cfg   /myapp/config/prod/conf2.cfg   /myapp/config/</code></pre><p>这个例子是将主机的/myapp/config/prod/conf1.cfg 文件和/myapp/conig/prod/conf2.cfg 文件复制到 Docker 镜像中的/myapp/config/目录中。注意，目标目录必须以/（斜杠）结束才能工作。</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p><code>ADD</code>命令与<code>COPY</code>命令工作方式相同，只有一些细微的差别：</p><ul><li><code>ADD</code>命令可以复制并提取 TAR 文件到 Docker 镜像中。</li><li><code>ADD</code>命令可以通过 HTTP 下载文件，并复制到 Docker 镜像中。</li></ul><p>下是一些示例：</p><pre><code class="dockerfile">ADD    myapp.tar    /myapp/</code></pre><p>这个例子是将指定的 TAR 文件解压缩并提取到 Docker 镜像的/myapp/目录中。</p><p>下面是另一个例子：</p><pre><code class="dockerfile">ADD    http://jenkov.com/myapp.jar    /myapp/</code></pre><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p><code>ENV</code>命令是在 Docker 镜像中设置环境变量，此环境变量可用于<code>CMD</code>命令在 Docker 镜像内部启动应用程序。举个例子：</p><pre><code class="dockerfile">ENV    MY_VAR   123</code></pre><p>本例将环境变量<code>MY_VAR</code>设置为值 123。</p><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>可以在 Docker 镜像中执行命令行指令，执行时机是 Docker 镜像构建过程中，所以<code>RUN</code>命令只会执行一次。<code>RUN</code>命令可用于在 Docker 镜像中安装应用程序、提取文件或其他命令行功能，这些操作只需要执行一次，以供 Docker 镜像后续使用。</p><pre><code class="dockerfile">RUN apt-get install some-needed-app</code></pre><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p><code>ARG</code>命令允许定义一个参数，这个参数可以在通过 Dockerfile 文件构建 Docker 镜像时，通过命令参数传递给 Docker。比如：</p><pre><code class="dockerfile">ARG tcpPort</code></pre><p>当执行<code>docker build</code>命令执行 Dockerfile 构建 Docker 镜像时，可以指定<code>tcpPort</code>参数，比如：</p><pre><code class="dockerfile">docker build --build-arg tcpPort=8080 .</code></pre><blockquote><p>注意，<code>--build-arg</code>后面的<code>tcpPort=8080</code>，是将<code>tcpPort</code>参数的值设置为 8080。</p></blockquote><p>我们可以通过多个<code>ARG</code>命令定义多个参数，举个例子：</p><pre><code class="dockerfile">ARG tcpPortARG useTls</code></pre><p>当构建 Docker 镜像时，必须为所有构建参数提供值。【译者注，1.13 版本之前，不提供值会直接报错，1.13 版本之后，不提供值不会报错，但是会弹出警告】。举个例子：</p><pre><code class="dockerfile">docker build --build-arg tcpPort=8080 --build-arg useTls=true .</code></pre><p>我们可以为<code>ARG</code>设置默认值，当构建 Docker 镜像时，如果没有指定参数值，将使用默认值。举个例子：</p><pre><code class="dockerfile">ARG tcpPort=8080ARG useTls=true</code></pre><p>如果<code>tcpPort</code>和<code>useTls</code>在生成 Docker 镜像时，都没有设置参数，将使用默认值 8080 和 true。</p><p><code>ARG</code>声明的参数通常在 Dockerfile 的其他地方引用，比如：</p><pre><code class="dockerfile">ARG tcpPort=8080ARG useTls=trueCMD start-my-server.sh -port ${tcpPort} -tls ${useTls}</code></pre><blockquote><p>注意：两个引用<code>${tcpPort}</code>和<code>${useTls}</code>，引用名是<code>tcpPort</code>和<code>useTls</code>这两个<code>ARG</code>声明的参数。</p></blockquote><pre><code class="dockerfile">docker build --build-arg tcpPort=8080</code></pre><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p><code>WORKDIR</code>命令指明了 Docker 镜像中的工作目录，工作目录将对<code>WORKDIR</code>指令之后的所有命令生效，举个例子：</p><pre><code class="dockerfile">WORKDIR    /java/jdk/bin</code></pre><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p><code>EXPOSE</code>命令将对外开放 Docker 容器中的网络端口，比如，如果 Docker 容器运行一个 web 服务器，那么，该 web 服务器可能需要打开端口 80，以便客户端链接到它。举个例子：</p><pre><code class="dockerfile">EXPOSE   8080</code></pre><p>我们还可以指明打开端口的通信协议，比如：UDP 和 TCP。下面是设置允许通信协议的示例：</p><pre><code class="dockerfile">EXPOSE   8080/tcp 9999/udp</code></pre><p>如果没有指定协议，将默认认定为 TCP 协议。</p><h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p><code>VOLUME</code>命令会在 Docker 镜像中创建一个目录，这个目录可以挂载到 Docker 主机上。换句话说，可以在 Docker 镜像中创建目录，比如<code>/data</code>，这个目录可以在稍后挂载到 Docker 主机的<code>/container-data/container1</code>目录上。挂载成功后，容器会启动。下面是一个使用<code>VOLUME</code>命令在 Dockerfile 中定义装载目录的示例：</p><pre><code class="dockerfile">VOLUME   /data</code></pre><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>命令为从该 Docker 镜像启动 Docker 容器提供入口点，入口点是 Docker 容器启动时执行的应用程序或命令。这样，<code>ENTRYPOINT</code>和<code>CMD</code>工作方式类似，不同之处在于，使用<code>ENTRYPOINT</code>时，当<code>ENTRYPOINT</code>执行的应用程序完成时，Docker 容器将关闭。因此，<code>ENTRYPOINT</code>使 Docker 镜像本身成为一个可执行命令，可以启动，完成后关闭。以下是<code>ENTRYPOINT</code>示例：</p><pre><code class="dockerfile">ENTRYPOINT java -cp /apps/myapp/myapp.jar com.jenkov.myapp.Main</code></pre><p>这个示例将在容器启动时执行 Java 应用程序的主类<code>com.jenkov.myapp.Main</code>，当应用程序关闭时，Docker 容器也会关闭。</p><h2 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h2><p><code>HEALTHCHECK</code>命令可以定期执行健康检查，以监视 Docker 容器中运行的应用程序的运行状况。如果命令返回 0，Docker 将认为应用程序和容器正常，如果命令返回 1，Docker 会认为应用程序和容器不正常。示例如下：</p><pre><code class="dockerfile">HEALTHCHECK java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><p>这个示例中使用了 java 应用程序的<code>com.jenkov.myapp.HealthCheck</code>作为健康检查的命令，我们可以使用任何有意义的健康检查命令。</p><h3 id="健康检查间隔时间"><a href="#健康检查间隔时间" class="headerlink" title="健康检查间隔时间"></a>健康检查间隔时间</h3><p>默认情况下，Docker 每 30 秒执行一次<code>HEALTHCHECK</code>命令。如果想修改时间间隔，我们可以自定义时间，通过<code>--interval</code>参数，可以指定健康检查的检查间隔时间。下面是一个将<code>HEALTHCHECK</code>间隔设置为 60 秒的示例：</p><pre><code class="dockerfile">HEALTHCHECK --interval=60s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h3 id="健康检查开始时间"><a href="#健康检查开始时间" class="headerlink" title="健康检查开始时间"></a>健康检查开始时间</h3><p>默认情况下，Docker 会立即检查 Docker 容器的监控状况。但是，有些应用程序可能需要一段时间启动，因此，只有经过某段时间后再进行健康检查才有意义。我们可以使用<code>--start-period</code>参数设置健康检查开始时间。下面是一个将健康检查设置为 5 分钟的示例，在 Docker 开始健康检查之前，为容器和应用程序提供 300 秒（5 分钟）的启动时间：</p><pre><code class="dockerfile">HEALTHCHECK --start-period=300s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h3 id="健康检查超时时间"><a href="#健康检查超时时间" class="headerlink" title="健康检查超时时间"></a>健康检查超时时间</h3><p>健康检查很有可能超时，如果<code>HEALTCHECK</code>命令需要超过给定时间限制才完成，Docker 将认为健康检查超时。可以使用<code>--timeout</code>参数设置超时时间，如下是设置超时时间为 5 秒的示例：</p><pre><code class="dockerfile">HEALTHCHECK --timeout=5s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><blockquote><p>注意，如果健康检查超时，Docker 也会认为容器不健康。</p></blockquote><h3 id="健康检查重复次数"><a href="#健康检查重复次数" class="headerlink" title="健康检查重复次数"></a>健康检查重复次数</h3><p>如果<code>HEALTHCHECK</code>命令执行失败，有可能是结果返回 1，或者执行超时，Docker 会在认定容器不健康前，重试 3 次<code>HEALTHCHECK</code>命令，用于检查 Docker 容器是否返回健康状态。可以通过<code>--retries</code>设置重试次数。下面是将重试次数设置为 5 的示例：</p><pre><code class="dockerfile">HEALTHCHECK --retries=5 java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/dockerfile.html" target="_blank" rel="noopener">Docker Dockerfile</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114808891" target="_blank" rel="noopener">Docker 教程（二）：Dockerfile</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Dockerfile 包含一组关于如何构建 Docker 镜像的说明，通过 docker build 命令执行 Dockerfile 文件，可以构建一个 Docker 镜像，本文介绍了如何编写 Dockerfile 文件以及构建一个 Docker 镜像。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
      <category term="Dockerfile" scheme="https://www.howardliu.cn/tags/Dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（一）：Docker 是什么</title>
    <link href="https://www.howardliu.cn/docker-tutorial/"/>
    <id>https://www.howardliu.cn/docker-tutorial/</id>
    <published>2021-03-07T09:42:18.000Z</published>
    <updated>2021-03-07T09:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/dandelion-5975473_1920.jpg" alt="Docker 教程"></p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第一篇，本文大概介绍了 Docker 是什么和有什么用。可能在工作中，会有专业运维同学管理服务器镜像或其他内容，但是如果不了解这些概念，很多时候我们不会全面了解到系统的全貌。</p></blockquote><a id="more"></a><p>Docker 是一种将应用程序和服务器配置打包成 Docker 镜像的方法，使用了一种称为 Dockerfile 的简单打包规范。Docker 镜像可以启动多个多个实例，这些运行的实例被称为 Docker 容器。这个系列的内容主要包括讲解什么是 Docker 镜像、什么是容器、什么是 Dockerfile，以及如何创建、运行和发布等。</p><h2 id="Docker-的优势"><a href="#Docker-的优势" class="headerlink" title="Docker 的优势"></a>Docker 的优势</h2><p>使用 Dockerfile 打包应用和服务器配置最大的好处是：</p><ul><li>不会忘记服务器是如何配置的，这些配置信息都记录在 Dockerfile 中。</li><li>很容易在一个全新啊的 Docker 主机上运行应用程序，只需要将应用程序的 Docker 镜像部署到这台 Docker 主机上，然后启动它即可。</li><li>可以使用 Kubernetes 和 Swarm 轻松管理集群中的 Docker 容器。</li><li>目前许多云服务器平台可以很轻松的部署 Docker 容器，Docker 已经成为让云更加独立的部署方案。</li><li>Docker 容器可以很简单的实现在客户自己的服务器上按照你的应用程序。</li></ul><h2 id="什么是-Docker-容器"><a href="#什么是-Docker-容器" class="headerlink" title="什么是 Docker 容器"></a>什么是 Docker 容器</h2><p>Linux 操作系统有几个特性：运行在操作系统上运行容器化的应用程序，这些容器化的特性，运行将文件系统和网络在各个容器化应用程序之间彼此分离。换句话说，一个容器化应用程序，不能访问另一个容器化应用程序的文件系统或网络，除非增加特殊配置，允许这种操作。Docker 使用 Linux 的容器化特性，并通过一组易于使用的工具公开这些特性。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-1.png" alt="什么是 Docker 容器"></p><h2 id="Docker-容器-vs-虚拟机"><a href="#Docker-容器-vs-虚拟机" class="headerlink" title="Docker 容器 vs. 虚拟机"></a>Docker 容器 vs. 虚拟机</h2><p>Docker 容器在本质上类似于虚拟机，两者的不同之处在于，虚拟机在总栈上有一个额外的操作系统。也就是说，虚拟机有完整的操作系统，然后这个虚拟机运行在一个有操作系统的主机上。</p><p>Docker 容器与虚拟机的实现不同，它没有自己单独的操作系统，直接运行在所在主机的操作系统中。所以，Docker 容器足够小，因为它不包含虚拟机操作系统。Docker 容器运行的也很好，因为它不需要虚拟机的虚拟化。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-2.png" alt="Docker 容器 vs. 虚拟机"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>如前所述，我们可以通过一个按规则定义的 Dockerfile 文件，指定要包含在 Docker 容器中的内容。Dockerfile 文件包含了一组有 Docker 命令行工具执行的 Docker 指令，按照 Dockerfile 执行的结果是 Docker 镜像。我们可以从 <a href="http://tutorials.jenkov.com/docker/dockerfile.html" target="_blank" rel="noopener">Dockerfile 教程</a> 中得到更详细的解释。【译者注：后续翻译完成后，将替换此处链接。】</p><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>Docker 命令行工具按照 Dockerfile 中定义的结构执行指令时，会生产一个可移植、可运行的 Docker 镜像。这个 Docker 镜像中包含了所有 Docker 容器需要的文件和指令，同一个 Docker 镜像可以启动多个 Docker 容器。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-3.png" alt="Docker 镜像"></p><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>Docker 镜像可以存储在 Docker 仓库中，一个可以将 Docker 镜像上传、下载的存储仓库。Docker 仓库可以是私有的，只能你或者你的组织或者你指定的人管理其中的镜像，也可以是公有的，任何人都可以管理其中的镜像，或者是从中下载 Docker 镜像。</p><p>一个公有的 Docker 仓库，是运行潜在用户下载、安装和运行软件的很好的方式，只需要将应用程序打包为 Docker 镜像，上传到公有的 Docker 仓库中，你的用户就可以访问并使用它。</p><p>Docker 公司已将 Docker 仓库作为一项托管服务，提供了私有和公有两种服务。一些云服务商，比如 AWS、AZure 和 Google，也提供了 Docker 仓库服务器，可以上传自己的 Docker 镜像。很容易的就能在云基础设施上的虚拟机或 Kubernetes 中使用这些镜像。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-4.png" alt="Docker 仓库"></p><h2 id="Docker-命令行工具"><a href="#Docker-命令行工具" class="headerlink" title="Docker 命令行工具"></a>Docker 命令行工具</h2><p>当在操作系统中安装 Docker 的时候，会同时安装 Docker 命令行工具。Docker 命令行工具可以通过 Dockerfile 构建 Docker 镜像，可以将 Docker 镜像上传到 Docker 仓库中，可以从 Docker 仓库中下载 Docker 镜像，可以操作 Docker 镜像启动或停止 Docker 容器。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose 提供一种功能，可以将多个 Docker 容器链接成一个组合中，这个组合中的所有容器，可以一次性全部部署或停止。比如，一个 Docker 容器中运行应用，一个 Docker 容器中运行数据库，应用依赖于数据库，同时启动或停止，可以实现应用依赖的数据库没有正常运行。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">Docker Tutorial</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114497477" target="_blank" rel="noopener">Docker 教程（一）：Docker 是什么</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Docker 是一种将应用程序和服务器配置打包成 Docker 镜像的方法，使用了一种称为 Dockerfile 的简单打包规范。Docker 镜像可以启动多个多个实例，这些运行的实例被称为 Docker 容器。这个系列的内容主要包括讲解什么是 Docker 镜像、什么是容器、什么是 Dockerfile，以及如何创建、运行和发布等。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Java 中 Vector 和 SynchronizedList 的区别</title>
    <link href="https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/"/>
    <id>https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/</id>
    <published>2021-02-27T13:50:05.000Z</published>
    <updated>2021-02-27T13:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/bird-6024257_1920.jpg" alt="Java 中 Vector 和 SynchronizedList 的区别"></p><p>你好，我是看山。</p><p>本文还是折腾 Java 中的队列，上次比较了 <a href="https://www.howardliu.cn/understanding-java-list/">Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a>，当时感觉挺明白，后来想想又有些不理解的地方，所以今天在重新翻出来研究一下，我承认我钻了牛角尖了。</p><a id="more"></a><p><code>Vector</code>虽然种种问题，但是都属于设计上的问题，为什么不在后续版本中进行优化呢？<code>HashMap</code>就优化了好几次。而<code>SynchronizedList</code>这个内部类（也就是通过<code>Collections.synchronizedList(new ArrayList())</code>创建的），也是采用了和<code>Vector</code>类似的同步方式（区别是一个在方法体、一个在方法块上，差别不大），为什么大家还是舍弃<code>Vector</code>呢？</p><p>其实，在 JDK 中，<code>Vector</code>一直没有被标记为<code>Deprecated</code>，也就是说，虽然外界传说<code>Vector</code>有各种问题，但是从 JDK 官方，从没有认为这个亲儿子没用。</p><p>所以，大家不用<code>Vector</code>的原因就剩下两种：</p><ol><li>其他队列比<code>Vector</code>更加适合，优中选优</li><li>大家都说<code>Vector</code>不好用，那我也不用了【个人感觉这种概率更大】</li></ol><blockquote><p>因为<code>Vector</code>主要是数组结构，所以下面大部分的对比都是比较的是针对<code>ArrayList</code>的同步封装。</p></blockquote><h2 id="有了Vector为什么还要有SynchronizedList"><a href="#有了Vector为什么还要有SynchronizedList" class="headerlink" title="有了Vector为什么还要有SynchronizedList"></a>有了<code>Vector</code>为什么还要有<code>SynchronizedList</code></h2><p>这个问题的答案是从 StackOverflow 中找到的。</p><p>在 JDK 1.2 之前，<code>Collections</code>是独立类库，不是 JDK/JRE 中的一部分。当时<code>synchronized</code>性能特别差，很多场景不需要使用同步方式，所以，独立类库的开发者删除了同步操作，这个应该就是<code>ArrayList</code>的前身。但是，少部分场景还是需要使用同步，于是就有了<code>SynchronizedList</code>，一个可以包装所有<code>List</code>子类的包装类，这个类在几乎所有方法上都加上了<code>synchronized</code>同步，这个设计与<code>Vector</code>相似。</p><p>古人说“文人相轻”，其实在编码界也是有鄙视链的。在这里就是：虽然我的设计和你的设计类似，但是我的设计就是比你的好。不过，<code>Collections</code>确实设计更优。</p><h2 id="一个SynchronizedList实现所有List的同步"><a href="#一个SynchronizedList实现所有List的同步" class="headerlink" title="一个SynchronizedList实现所有List的同步"></a>一个<code>SynchronizedList</code>实现所有<code>List</code>的同步</h2><p><code>SynchronizedList</code>定位是包装类，可以包装所有<code>List</code>的子类。也就是说，无论是<code>ArrayList</code>还是<code>LinkedList</code>都能过实现同步，完全不会修改底层数据结构，既实现的同步，又保留了底层接口的优点。比如<code>LinkedList</code>的插入、删除效率，<code>ArrayList</code>的顺序读取。而且，一个包装类就解决所有<code>List</code>子类的同步需求，完全不需要重复实现一遍。</p><p>相对而言，<code>Vector</code>就比较霸道了，任何想要同步的队列，都需要转换为<code>Vector</code>的数组结构。大家都知道，数组存储需要连续空间，顺序读取效率表现优秀，但是插入和删除效率就比较差了。</p><h2 id="将迭代器的同步权利交给用户"><a href="#将迭代器的同步权利交给用户" class="headerlink" title="将迭代器的同步权利交给用户"></a>将迭代器的同步权利交给用户</h2><p>同步方法中<code>SynchronizedList</code>和<code>Vector</code>很类似，不过迭代器方法有了不同想法。</p><p>看源码就知道，<code>SynchronizedList</code>中的<code>iterator</code>和<code>listIterator</code>方法都没有实现同步，所以在获取迭代器的时候不会阻塞。</p><pre><code class="java">public Iterator&lt;E&gt; iterator() {    return list.iterator(); // Must be manually synched by user!}public ListIterator&lt;E&gt; listIterator() {    return list.listIterator(); // Must be manually synched by user}public ListIterator&lt;E&gt; listIterator(int index) {    return list.listIterator(index); // Must be manually synched by user}</code></pre><p>如果需要迭代的话，直接用<code>synchronized</code>包一下队列对象就可以了，代码如下：</p><pre><code class="java">final List&lt;String&gt; list = Collections.synchronizedList(new ArrayList());list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);final Iterator&lt;String&gt; iterator = list.iterator();synchronized (list) {    while (iterator.hasNext()) {        final String next = iterator.next();        System.out.println(next);    }}</code></pre><p>我们再看下<code>Vector</code>迭代器实现：</p><pre><code class="java">/**    * An optimized version of AbstractList.Itr    */private class Itr implements Iterator&lt;E&gt; {    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    public boolean hasNext() {        // Racy but within spec, since modifications are checked        // within or after synchronization in next/previous        return cursor != elementCount;    }    public E next() {        synchronized (Vector.this) {            checkForComodification();            int i = cursor;            if (i &gt;= elementCount)                throw new NoSuchElementException();            cursor = i + 1;            return elementData(lastRet = i);        }    }    public void remove() {        if (lastRet == -1)            throw new IllegalStateException();        synchronized (Vector.this) {            checkForComodification();            Vector.this.remove(lastRet);            expectedModCount = modCount;        }        cursor = lastRet;        lastRet = -1;    }    // 此处省略一些方法}</code></pre><p><code>Vector</code>的迭代器用<code>synchronized (Vector.this)</code>加锁，其实也是对当前类实例加锁，和我们自己实现的加锁方式一致。当然，从这点上来说，<code>Vector</code>能够保证在开发人员无意识的情况下，避免为同步造成的错误，这也是<code>Vector</code>的一个优点。</p><h2 id="Vector不完全一无是处"><a href="#Vector不完全一无是处" class="headerlink" title="Vector不完全一无是处"></a><code>Vector</code>不完全一无是处</h2><p>虽然<code>Vector</code>在其他地方败给了<code>Collections</code>，但是在扩容这方面，还有一个可取之处。先看看<code>Vector</code>的扩容方法：</p><pre><code class="java">private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                        capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p>在计算新数组长度的时候，会检查<code>capacityIncrement</code>是否大于 0，如果是，就扩容<code>capacityIncrement</code>的大小。就是说，在<code>Vector</code>中可以指定扩容大小，如果没有指定，默认扩容到原来的 2 倍；而<code>ArrayList</code>只能扩容到 1.5 倍，没有办法自定义扩容大小。</p><blockquote><p>仔细想想，这点并没有什么用处。</p></blockquote><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li><code>Vector</code>内部结构是数组，与<code>Collections.synchronizedList(new ArrayList())</code>类似。</li><li><code>Vector</code>可以指定扩容大小，默认是扩容到原数组长度的 2 倍；<code>ArrayList</code>不能指定扩容大小，直接扩容到原数组大小的 1.5 倍。</li><li><code>SynchronizedList</code>是一个包装类，可以将<code>List</code>子类都包装为同步队列，从非线程安全队列转为线程安全队列，没有性能延迟，直接包装即可；<code>Vector</code>是一个基于数组的同步队列，其他队列想要转换为<code>Vector</code>，需要有数据拷贝。</li><li><code>SynchronizedList</code>的迭代器没有做同步，需要用户自己实现；<code>Vector</code>的迭代器做好了同步，开发人员不需要关心同步。</li><li><code>Vector</code>至今未标记<code>Deprecated</code>，而且随着 JDK 发布，也在更新实现。虽然 JDK 承诺兼容，但是一直没有标记过期，其用意不得而知。</li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/understanding-java-list/">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a></li><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li><li><a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated" target="_blank" rel="noopener">Why is Java Vector (and Stack) class considered obsolete or deprecated?</a></li><li><a href="https://stackoverflow.com/questions/14932034/in-java-vector-and-collections-synchronizedlist-are-all-synchronized-whats-th" target="_blank" rel="noopener">In java, Vector and Collections.synchronizedList are all synchronized, what’s the difference?</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/">Java 中 Vector 和 Collections.synchronizedList(new ArrayList()) 的区别</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114238758" target="_blank" rel="noopener">Java 中 Vector 和 Collections.synchronizedList(new ArrayList()) 的区别</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java 中 Vector 和 SynchronizedList 的区别
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件架构-事件驱动架构</title>
    <link href="https://www.howardliu.cn/event-driven-architecture/"/>
    <id>https://www.howardliu.cn/event-driven-architecture/</id>
    <published>2021-02-20T13:21:45.000Z</published>
    <updated>2021-02-20T13:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/software-architecture/jellyfish-2427426_1920.jpg" alt="软件架构-事件驱动架构"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/software-architecture/index.html" target="_blank" rel="noopener">《软件架构》</a> 中关于事件驱动的内容，虽然是 2014 年的文章，但是从软件架构层面上，并不过时。</p></blockquote><p>以下是正文。</p><p>事件驱动架构是一种系统或组件之间通过发送事件和响应事件彼此交互的架构风格。当某个事件发生时，组件A不直接调用组件B，而只是发出一个事件。组件A不知道哪些组件监听并处理这些事件。事件驱动架构可以在进程内和进程间使用。比如，GUI框架中会大量使用事件驱动。【译者注：目前很多系统采用微服务架构，事件驱动使用的更加广泛了。】此外，正如我在<a href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html" target="_blank" rel="noopener">并发模型教程</a> 中所提到的，装配线并发模型（AKA reactive，非阻塞并发模型）也使用了事件驱动架构。</p><p>本文主要介绍进程之间的事件驱动架构，后文提到这个词的时候也是指进程交互方式。</p><a id="more"></a><h2 id="进程间的事件驱动架构"><a href="#进程间的事件驱动架构" class="headerlink" title="进程间的事件驱动架构"></a>进程间的事件驱动架构</h2><p>事件驱动架构是一种架构风格，先将请求事件集中存放在一个或多个事件队列中，然后事件从这些事件队列转发到后端服务，处理这些事件。</p><p>因为事件可以被看做是消息流，所以事件驱动架构也被称为消息驱动架构或者流处理架构。流处理架构又可以被称为lambda架构。为了保证统一，后文会继续使用事件驱动这个名词。</p><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>在事件驱动架构中，你会有一个或多个集中的事件队列，所有的事件被处理前，会先保存在集中的事件队列中。下面给出一个简单示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-1.png" alt="event-driven-architecture"></p><p>事件插入队列时是有序的，这样就可以顺序处理这些事件。</p><h2 id="事件日志"><a href="#事件日志" class="headerlink" title="事件日志"></a>事件日志</h2><p>写入事件队列时，消息可能写入到事件日志（通常是磁盘存储）中。如果发生系统崩溃，系统只需要重放事件日志即可恢复到崩溃前的状态。下面是一个事件驱动架构的示例，其中包括一个用于持久化事件的事件日志：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-2.png" alt="event-driven-architecture"></p><p>我们还可以通过备份事件日志，来备份系统状态。在将新版本的系统部署在生产环境之前，可以使用这个备份数据对其性能进行测试。或者，通过重放事件日志的备份，来重现某些错误。</p><h2 id="事件收集器"><a href="#事件收集器" class="headerlink" title="事件收集器"></a>事件收集器</h2><p>请求都是通过网络传输，比如HTTP或者其他协议。为了保持一致，可以通过事件采集器接收来自不同来源的事件。下面是一个添加了事件收集器的事件驱动架构示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-3.png" alt="event-driven-architecture"></p><h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>有时，我们还需要向请求（即事件）返回响应，所以，很多事件驱动架构除了包含事件队列，还会有一个响应队列。下面是包含事件队列（入队队列）和响应队列（出队队列）的事件驱动架构示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-4.png" alt="event-driven-architecture"></p><p>如你所见，响应队列必须路由到正确的事件收集器。比如，如果HTTP收集器（本质上是web服务器）通过HTTP接收的请求发送到事件队列中，则该事件生成的响应可能也需要通过HTTP收集器发回客户端。</p><p>通常，响应队列不会持久化，也就意味着它不会写入事件日志，只有输入的事件才会持久化到事件日志中。</p><h2 id="读事件-vs-写事件"><a href="#读事件-vs-写事件" class="headerlink" title="读事件 vs. 写事件"></a>读事件 vs. 写事件</h2><p>如果将所有传入的请求都认为是事件，就需要将这些事件都推送到事件队列中。如果事件队列是实现了持久化（持久化到事件日志中），就意味着所有事件都需要持久化。通常持久化都比较慢，如果我们能够过滤掉一些不需要持久化的事件，我们就能够提升队列的性能。</p><p>我们将事件持久化到事件日志的原因是，我们可以重放事件日志，并重建因为事件引起的系统状态变化。为了支持这个特性，实际上只需要持久化更改系统状态的事件。换句话说，我们只需要将事件分为读事件和写事件。读事件只读取系统数据，不会更改，写事件会更改系统数据。</p><p>通过根据读和写划分事件，我们只需要持久化写事件的消息即可。这将提升事件队列的性能，提升比例大小，取决于读写事件之间的比例。</p><p>为了将事件划分为读写事件，需要在事件到达事件队列之前，也就是事件收集器中进行区分。否则，事件队列无法知道到达的事件是否需要持久化。</p><p>还可以将事件队列拆分为两个，一个用于存储读事件的事件队列，一个用于存储写事件的事件队列。这样读事件就不会慢于写事件，事件队列也不需要检查每条事件是否需要持久化。读事件队列不需要进行持久化，写事件队列始终持久化事件。</p><p>下面是一个事件驱动架构的示例，其中事件队列分为读和写事件队列：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-5.png" alt="event-driven-architecture"></p><p>上图示例中箭头比较乱，但实际上创建3个丢列并在它们之间分发消息简单很多。</p><h2 id="事件日志重放的挑战"><a href="#事件日志重放的挑战" class="headerlink" title="事件日志重放的挑战"></a>事件日志重放的挑战</h2><p>事件驱动架构的一大优点是，在系统崩溃或系统重启情况下，只需要重放事件日志，就能够重建系统状态。在日志可以独立于时间和周边系统的情况下重放日志，这是一个很大的优势。</p><p>但是，完全独立于时间重放事件日志有时候很难实现。接下来介绍下事件日志重放的一些挑战。</p><h3 id="处理动态数据"><a href="#处理动态数据" class="headerlink" title="处理动态数据"></a>处理动态数据</h3><p>如前所述，写事件处理时可能会修改系统数据。有些情况，这种数据的修改受事件处理时动态数据的影响。比如，处理事件的日期和时间或者特定日期和时间的货币汇率。</p><p>这些动态数据会对事件重放造成困难。如果在不同的时间重放事件日志，处理该事件的服务可能会解析不同的动态值，比如其他的日期和时间或其他汇率。因此，在不同的日期重放事件日志，可能会出现重建系统数据与最初处理事件产生的数据不一致。</p><p>要解决动态数据的问题，可以让写事件队列将所需的动态数据标记在事件中。但是，要实现这种方案，需要事件队列知道每条事件消息需要哪些动态数据。这样会使事件队列的设计复杂化，每次需要新的动态数据时，事件队列都需要知道如何查找这些动态数据。</p><p>另外一种解决方案是，写事件队列只在写事件上标记事件的日期和时间。使用事件的原始日期和时间，处理事件的服务可以查找给定日期和时间对应的动态数据。比如，可以通过原始的日期和时间，查询当时有效的汇率。这就要求处理事件的服务需要基于日期和时间查询动态数据，但是这只是理想状态。</p><h3 id="与外部系统的交互"><a href="#与外部系统的交互" class="headerlink" title="与外部系统的交互"></a>与外部系统的交互</h3><p>事件日志重放的另一个挑战是与外部系统的协调。比如，事件日志中包含电商平台的订单，在第一次处理这个事件时，需要将订单发送到外部支付网关，以从客户信用卡中收费。</p><p>如果重放事件日志，就不希望再次为同一个订单向客户收费。因此，就不希望在事件重放时，将订单发送到外部支付网关。</p><h2 id="事件日志重放解决方案"><a href="#事件日志重放解决方案" class="headerlink" title="事件日志重放解决方案"></a>事件日志重放解决方案</h2><p>解决重放事件日志问题挺不容易的。有些系统没有问题，可以直接重放事件日志；有些系统可能需要知道原始事件的日期和时间；有些系统可能需要知道更多类似于事件原始处理过程中从外部系统获取的原始数据。</p><h3 id="重放模式"><a href="#重放模式" class="headerlink" title="重放模式"></a>重放模式</h3><p>在任何情况下，倾听写事件队列中事件的任何服务都必须知道传入事件是原始事件还是重放事件。这样，处理服务就能够确定如何处理动态数据或者如何与外部系统交互了。</p><h3 id="多步骤事件队列"><a href="#多步骤事件队列" class="headerlink" title="多步骤事件队列"></a>多步骤事件队列</h3><p>另外一个解决方案是采用多步骤事件队列。第一步，收集所有写事件；第二步，解析动态数据；第三步，与外部系统交互。如果需要重放事件日志，只需要跳过第一步和第二步，重放第三步即可。具体如何实现，需要取决于具体的系统设计。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html" target="_blank" rel="noopener">Event-driven Architecture</a><br>翻译: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接: <a href="https://www.howardliu.cn/event-driven-architecture/">软件架构-事件驱动架构</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113923639" target="_blank" rel="noopener">软件架构-事件驱动架构</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      事件驱动架构是一种系统或组件之间通过发送事件和响应事件彼此交互的架构风格。
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="事件驱动" scheme="https://www.howardliu.cn/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</title>
    <link href="https://www.howardliu.cn/understanding-java-list/"/>
    <id>https://www.howardliu.cn/understanding-java-list/</id>
    <published>2021-02-09T06:18:59.000Z</published>
    <updated>2021-02-09T06:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/sunset-5299957_1920.jpg" alt="认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList"></p><p>你好，我是看山。</p><p>书接上文，上次聊了聊 <a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">在多线程中使用 ArrayList 会发生什么</a>，这次我们说说平时常用的列表：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList。</p><a id="more"></a><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><code>Vector</code>是在 JDK 1.0 提供的，虽然没有被标记<code>Deprecated</code>，但是事实上已经没人使用了。主要原因是性能差，且不符合需求。</p><p>从源码可以看出（这里不贴源码了），<code>Vector</code>是基于数组实现，几乎在所有操作方法上，都用<code>synchronized</code>关键字实现方法同步，这种同步方式可以对单一操作进行加锁，比如多个线程同时执行<code>add</code>会同步阻塞执行，但是多线程执行<code>add</code>和<code>remove</code>时，就不会阻塞了。</p><p>但是，大部分需要对队列加锁的场景，是想对整个队列加锁，而不仅仅是对单一操作加锁。也就是说，<code>Vector</code>和我们的期望不同，但是又额外增加了同步操作带来的性能开销。所以，不是必须使用的场景，都可以使用<code>ArrayList</code>代替，即使是多线程情况下需要同步队列，也可以使用<code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>代替。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><code>ArrayList</code>是在 JDK 1.1 提供的，作为<code>Vector</code>的继任者（<code>ArrayList</code>实现方式与<code>Vector</code>几乎完全相同），<code>ArrayList</code>把方法上的<code>synchronized</code>全部去掉了，完全没有实现同步，是非线程安全的。</p><p>它的非线程安全，还体现在迭代器的快速失败上。在使用方法<code>iterator</code>和<code>listIterator</code>创建迭代器之后，如果还对原来的<code>ArrayList</code>队列进行修改（add 或 remove），迭代器迭代的时候就会报<code>ConcurrentModificationException</code>异常。从源码可以看出，迭代器在迭代过程中，会检查队列中修改次数<code>modCount</code>与创建迭代器时落下的修改次数快照<code>expectedModCount</code>是否相等，相等表示没有修改过，代码如下：</p><pre><code class="java">private class Itr implements Iterator&lt;E&gt; {    // 这段代码是从 ArrayList 中摘取的    // 只留下检查方法，略过其他代码，有兴趣的可以从源码中查看    final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    }}</code></pre><p>第三点是在多线程场景中，添加元素可能会丢失数据，或者发生数组越界异常，<a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">在多线程中使用 ArrayList 会发生什么</a> 有详细描述，这里就不赘述了。</p><h2 id="SynchronizedList"><a href="#SynchronizedList" class="headerlink" title="SynchronizedList"></a>SynchronizedList</h2><p><code>SynchronizedList</code>是<code>Collections</code>的静态内部类，使用<code>Collections.synchronizedList()</code>静态方法创建，是一个通过组合<code>List</code>类实现的封装实现。它的大多数方法通过<code>synchronized (mutex){...}</code>代码块同步方式，因为加锁对象<code>mutex</code>是队列对象中定义的相同对象，所以对<code>mutex</code>加锁时，可以在多线程之间实现阻塞。但是这种实现方式和<code>Vector</code>在方法上加锁没有本质的区别，所以<code>Vector</code>存在的困境，<code>SynchronizedList</code>依然存在。</p><p><code>ArrayList</code>中存在的迭代器快速失败情况，依然存在，正如下面源码中的注释：想要使用迭代器，需要用户手动实现同步。</p><pre><code class="java">static class SynchronizedList&lt;E&gt;    extends SynchronizedCollection&lt;E&gt;    implements List&lt;E&gt; {    // 代码摘自 Collections，省略很多代码    public void add(int index, E element) {        synchronized (mutex) {list.add(index, element);}    }    public ListIterator&lt;E&gt; listIterator() {        return list.listIterator(); // Must be manually synched by user    }    public ListIterator&lt;E&gt; listIterator(int index) {        return list.listIterator(index); // Must be manually synched by user    }}</code></pre><p>手动同步的时候需要注意，既然我们关注的全局同步，在迭代器设置同步的时候，要保证锁定对象与<code>add</code>等方法中对象相同。这个在后续补充说明，这里就不展开了。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>CopyOnWriteArrayList</code>是从 JDK 1.5 开始提供的，先看看<code>add</code>方法的源码：</p><pre><code class="java">public class CopyOnWriteArrayList&lt;E&gt;    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    /** The lock protecting all mutators */    final transient ReentrantLock lock = new ReentrantLock();    /** The array, accessed only via getArray/setArray. */    private transient volatile Object[] array;    // 代码摘自 CopyOnWriteArrayList，省略很多代码    public boolean add(E e) {        final ReentrantLock lock = this.lock;        lock.lock();        try {            Object[] elements = getArray();            int len = elements.length;            Object[] newElements = Arrays.copyOf(elements, len + 1);            newElements[len] = e;            setArray(newElements);            return true;        } finally {            lock.unlock();        }    }    public boolean addAll(Collection&lt;? extends E&gt; c) {        Object[] cs = (c.getClass() == CopyOnWriteArrayList.class) ?            ((CopyOnWriteArrayList&lt;?&gt;)c).getArray() : c.toArray();        if (cs.length == 0)            return false;        final ReentrantLock lock = this.lock;        lock.lock();        try {            Object[] elements = getArray();            int len = elements.length;            if (len == 0 &amp;&amp; cs.getClass() == Object[].class)                setArray(cs);            else {                Object[] newElements = Arrays.copyOf(elements, len + cs.length);                System.arraycopy(cs, 0, newElements, len, cs.length);                setArray(newElements);            }            return true;        } finally {            lock.unlock();        }    }    private E get(Object[] a, int index) {        return (E) a[index];    }    /**     * {@inheritDoc}     *     * @throws IndexOutOfBoundsException {@inheritDoc}     */    public E get(int index) {        return get(getArray(), index);    }}</code></pre><p>可以看到，<code>CopyOnWriteArrayList</code>借助<code>ReentrantLock</code>实现同步，在<code>synchronized</code>优化之前，<code>ReentrantLock</code>性能高于<code>synchronized</code>。<code>CopyOnWriteArrayList</code>也是通过数组实现的，但是在数组前面增加了<code>volatile</code>关键字，实现了多线程情况下数组的可见性，更加安全。更重要的一点是，<code>CopyOnWriteArrayList</code>在<code>add</code>添加元素的时候，实现方式是重建数组对象，替换原来的数组引用。与<code>ArrayList</code>的扩容方式相比，减少了空间，但是也增加了赋值数组的性能开销。在<code>get</code>获取元素的时候，没有任何锁，直接数据返回。</p><p><code>CopyOnWriteArrayList</code>的迭代器时通过<code>COWIterator</code>实现的，调用<code>iterator</code>方法时，将当前队列中数组的快照赋值到迭代器中的数组引用上。如果原来的队列发生修改，队列中数组会指向别的引用，而迭代器中的数组不会发生变化，所以在多线程执行过程中，通过迭代器遍历数组，也可以修改队列中的数据。这种方式保障线程安全的同时，也可能会出现数据不一致的情况，只能是使用的使用多注意了。</p><pre><code class="java">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {    /** Snapshot of the array */    private final Object[] snapshot;    /** Index of element to be returned by subsequent call to next.  */    private int cursor;    private COWIterator(Object[] elements, int initialCursor) {        cursor = initialCursor;        snapshot = elements;    }}</code></pre><h2 id="对比-CopyOnWriteArrayList-和-SynchronizedList"><a href="#对比-CopyOnWriteArrayList-和-SynchronizedList" class="headerlink" title="对比 CopyOnWriteArrayList 和 SynchronizedList"></a>对比 CopyOnWriteArrayList 和 SynchronizedList</h2><p><code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>都实现了同步，实现方式上采用的是不同策略，各自的侧重点不同。</p><p><code>CopyOnWriteArrayList</code>侧重于读写分离，发生数据写操作（<code>add</code>或<code>remove</code>）时，会加锁，各个线程阻塞执行，执行过程会创建数据副本，替换对象引用；如果同时有读操作（<code>get</code>或<code>iterator</code>），读操作读取的是老数据，或者成为历史数据快照，或者成为缓存数据。这会造成读写同时发生时，数据不一致的情况，但是数据最终会一致。这种方式与数据库读写分离模式几乎相同，很多特性可以类比。</p><p><code>SynchronizedList</code>侧重数据强一致，也就是说当发生数据写操作（<code>add</code>或<code>remove</code>）时，会加锁，各个线程阻塞执行，而且也会通过相同的锁阻塞<code>get</code>操作。</p><p>从<code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>两种不同事项方式，可以推断<code>CopyOnWriteArrayList</code>在写少读多的场景中执行效率高，<code>SynchronizedList</code>的读写操作效率很均衡，所以在写多读多、写多读少的场景执行效率都会高于<code>CopyOnWriteArrayList</code>。借用网上的测试结果：</p><p><img src="http://static.howardliu.cn/java/CopyOnWriteArrayList-SynchronizedList-Vector.jpg" alt="对比 CopyOnWriteArrayList 和 SynchronizedList"></p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li><code>synchronized</code>关键字在 JDK 8 之前性能比较差，可以看到 JDK1.5 之后实现的同步代码，很多是通过<code>ReentrantLock</code>实现的。</li><li>多线程场景中除了需要考虑同步外，还需要考虑数据可见性，可以通过<code>volatile</code>关键字实现。</li><li><code>ArrayList</code>完全没有同步操作，是非线程安全的</li><li><code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>属于线程安全队列</li><li><code>CopyOnWriteArrayList</code>实现读写分离，适合场景是写少读多的场景</li><li><code>SynchronizedList</code>要求数据强一致，是队列全局加锁方式，读操作也会加锁</li><li><code>Vector</code>只是在迭代器遍历性能很差，如果不考虑全局锁定队列，单纯读操作和单独写操作性能与<code>SynchronizedList</code>相差不大。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated" target="_blank" rel="noopener">Why is Java Vector (and Stack) class considered obsolete or deprecated?</a></li><li><a href="https://blog.csdn.net/yangzl2008/article/details/39456817" target="_blank" rel="noopener">CopyOnWriteArrayList 与 Collections.synchronizedList 的性能对比</a></li><li><a href="https://juejin.cn/post/6844904054745743367" target="_blank" rel="noopener">Collections.synchronizedList 、CopyOnWriteArrayList、Vector 介绍、源码浅析与性能对比</a></li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/understanding-java-list/">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/113780875" target="_blank" rel="noopener">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      书接上文，上次聊了聊在多线程中使用 ArrayList 会发生什么，这次我们说说平时常用的列表：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="队列" scheme="https://www.howardliu.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如果非要在多线程中使用ArrayList会发生什么？</title>
    <link href="https://www.howardliu.cn/arraylist-is-not-thread-safe/"/>
    <id>https://www.howardliu.cn/arraylist-is-not-thread-safe/</id>
    <published>2021-02-04T13:08:09.000Z</published>
    <updated>2021-02-04T13:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/road-5837403_1920.jpg" alt="如果非要在多线程中使用ArrayList会发生什么？"></p><p>你好，我是看山。</p><p>我们都知道，Java中的ArrayList是非线程安全的，这个知识点太熟了，甚至面试的时候都很少问了。</p><p>但是我们真的清楚原理吗？或者知道多线程情况下使用ArrayList会发生什么？</p><p>前段时间，我们就踩坑了，而且直接踩了两个坑，今天就来扒一扒。</p><a id="more"></a><h2 id="翠花，上源码"><a href="#翠花，上源码" class="headerlink" title="翠花，上源码"></a>翠花，上源码</h2><p>上代码之前先说下<code>ArrayList</code>的<code>add</code>逻辑：</p><ol><li>检查队列中数组是否还没有添加过元素</li><li>如果是，设置当前需要长度为10，如果否，设置当前需要长度为当前队列长度+1</li><li>判断需要长度是否大于数组大小</li><li>如果是，需要扩容，将数组长度扩容1.5倍（第一次扩容会从0直接到10，后续会按照1.5倍的步幅增长）</li><li>数组中添加元素，队列长度+1</li></ol><p>附上代码，有兴趣的可以在看看源码。</p><pre><code class="java">/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add}) */public boolean add(E e) {    // 判断数组容量是否足够，如果不足，增加1.5倍，size是当前队列长度    ensureCapacityInternal(size + 1);  // Increments modCount!!    // 给下标为size的赋值，同时队列长度+1，下标从0开始    elementData[size++] = e;    return true;}private void ensureCapacityInternal(int minCapacity) {    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}private static int calculateCapacity(Object[] elementData, int minCapacity) {    // 判断是否首次添加元素，如果是，返回默认队列长度，现在是10    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        return Math.max(DEFAULT_CAPACITY, minCapacity);    }    // 如果不是首次添加元素，就返回当前队列长度+1    return minCapacity;}private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    // 如果需要的长度大于队列中数组长度，扩容，如果可以满足需求，就不用扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    // 这里就是扩容1.5倍的代码    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><h2 id="就是这么不安全"><a href="#就是这么不安全" class="headerlink" title="就是这么不安全"></a>就是这么不安全</h2><p>从上面代码可以看出，<code>ArrayList</code>中一丁点考虑多线程的元素都没有，完全的效率优先。</p><h3 id="奇怪的ArrayIndexOutOfBoundsException"><a href="#奇怪的ArrayIndexOutOfBoundsException" class="headerlink" title="奇怪的ArrayIndexOutOfBoundsException"></a>奇怪的ArrayIndexOutOfBoundsException</h3><p>先做一个假设，此时数组长度达到临界边缘，比如目前容量是10，现在已经有9个元素，也就是size=9，然后有两个线程同时向队列中增加元素：</p><ol><li>线程1开始进入<code>add</code>方法，获取size=9，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量是10，不需要扩容</li><li>线程2也进入<code>add</code>方法，获取size=9，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量还是10，也不需要扩容</li><li>线程1开始赋值值了，也就是<code>elementData[size++] = e</code>，此时size变成10，达到数组容量极限</li><li>线程2此次开始执行赋值操作，使用的size=10，也就是<code>elementData[10] = e</code>，因为下标从0开始，目前数组容量是10，直接报数组越界<code>ArrayIndexOutOfBoundsException</code>。</li></ol><p>仅仅差了一步，线程2就成为了抛异常的凶手。但是抛出异常还是好的，因为我们知道出错了，可以沿着异常</p><h3 id="诡异的null元素"><a href="#诡异的null元素" class="headerlink" title="诡异的null元素"></a>诡异的null元素</h3><p>这种情况不太容易从代码中发现，得对代码稍加改造，<code>elementData[size++] = e</code>这块代码其实执行了两步：</p><pre><code class="java">elementData[size] = e;size++;</code></pre><p>假设还是有两个线程要赋值，此时数组长度还比较富裕，比如数组长度是10，目前size=5：</p><ol><li>线程1开始进入<code>add</code>方法，获取size=5，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量是10，不需要扩容</li><li>线程2也进入<code>add</code>方法，获取size=5，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量还是10，也不需要扩容</li><li>线程1开始赋值，执行<code>elementData[size] = e</code>，此时size=5，在执行<code>size++</code>之前，线程2开始赋值了</li><li>线程2开始赋值，执行<code>elementData[size] = e</code>，此时size还是5，所以线程2把线程1赋的值覆盖了</li><li>线程1开始执行<code>size++</code>，此时size=6</li><li>线程2开始执行<code>size++</code>，此时size=7</li></ol><p>也就是说，添加了2个元素，队列长度+2，但是真正加入队列的元素只有1个，有一个被覆盖了。</p><p>这种情况不会立马报错，排查起来就很麻烦了。而且随着JDK 8的普及，可能随手使用filter过滤空元素，这样就不会立马出错，直到出现业务异常之后才能发现，到那时，错误现场已经不见了，排查起来一头雾水。</p><p>有同学会问，源码中是<code>elementData[size++] = e</code>，是一行操作，为什么会拆成两步执行呢？其实这得从JVM字节码说起了。</p><h3 id="通过JVM字节码说说第二种异常出现的原因"><a href="#通过JVM字节码说说第二种异常出现的原因" class="headerlink" title="通过JVM字节码说说第二种异常出现的原因"></a>通过JVM字节码说说第二种异常出现的原因</h3><p>先来一段简单的代码：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        int[] nums = new int[3];        int index = 0;        nums[index++] = 5;    }}</code></pre><p>通过<code>javac Main.java</code>和<code>javap -v -l Main.class</code>组合操作得到字节码：</p><blockquote><p>下面那些中文是我后加的备注，备注中还列出了局部变量表和栈值的变化，需要有点耐心。</p></blockquote><pre><code class="class">public class Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #3.#12         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #13            // Main   #3 = Class              #14            // java/lang/Object   #4 = Utf8               &lt;init&gt;   #5 = Utf8               ()V   #6 = Utf8               Code   #7 = Utf8               LineNumberTable   #8 = Utf8               main   #9 = Utf8               ([Ljava/lang/String;)V  #10 = Utf8               SourceFile  #11 = Utf8               Main.java  #12 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V  #13 = Utf8               Main  #14 = Utf8               java/lang/Object{  public Main();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 1: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=3, locals=3, args_size=1                                                                               局部变量表                             栈         0: iconst_3                     // 将int型(3)推送至栈顶                                                      args                                3         1: newarray       int           // 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶          args                                数组引用         3: astore_1                     // 将栈顶引用型数值存入第二个本地变量                                            args, nums=数组引用                  null         4: iconst_0                     // 将int型(0)推送至栈顶                                                       args, nums=数组引用                  0         5: istore_2                     // 将栈顶int型数值存入第三个本地变量                                             args, nums=数组引用, index=0         null         6: aload_1                      // 将第二个引用类型本地变量推送至栈顶                                             args, nums=数组引用, index=0         数组引用         7: iload_2                      // 将第三个int型本地变量推送至栈顶                                               args, nums=数组引用, index=0         0, 数组引用         8: iinc          2, 1           // 将指定int型变量增加指定值（i++, i--, i+=2），也就是第三个本地变量增加1            args, nums=数组引用, index=1         0, 数组引用        11: iconst_5                     // 将int型(5)推送至栈顶                                                        args, nums=数组引用, index=1         5, 0, 数组引用        12: iastore                      // 将栈顶int型数值存入指定数组的指定索引位置                                       args, nums=数组引用, index=1         null        13: return                       // 从当前方法返回void      LineNumberTable:        line 3: 0                        // int[] nums = new int[3];        line 4: 4                        // int index = 0;        line 5: 6                        // nums[index++] = 5;        line 6: 13                       // 方法结尾默认的return}</code></pre><p>从上面的字节码可以看到，<code>nums[index++] = 5</code>这一句会被转为5个指令，是从6到12。大体操作如下：</p><ol><li>将数组、下标压入栈</li><li>给下标加值</li><li>将新值压入栈</li><li>取栈顶三个元素开始给元素指定下标赋值</li></ol><p>也即是说，错误出在数组赋值操作时先将数组引用和下标同时压入栈顶，与下标赋值是两步，在多线程环境中，就有可能出现上面说到的null值存在。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>其实解法也很简单，就是要意识到多线程环境，然后不使用ArrayList。可以使用<code>Collections.synchronizedList()</code>返回的同步队列，也可以使用<code>CopyOnWriteArrayList</code>这个队列，或者自己扩展<code>ArrayList</code>，将add方法做成同步方法。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p><code>ArrayList</code>整个类的操作都是非线程安全的，一旦在多线程环境中使用，就可能会出现问题。上面提到<code>add</code>操作就会有两种异常行为，一个是数组越界异常，一个是出现丢数且出现空值。这还只是最简单的<code>add</code>操作，如果<code>add</code>、<code>addAll</code>和<code>get</code>混合使用使用时，异常情况就更多了。所以，使用的时候一定要注意是不是单线程操作，如果不是，果断使用其他队列防雷。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，开源贡献者。游于码界，戏享人生。</p><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用ArrayList会发生什么？</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113666581" target="_blank" rel="noopener">如果非要在多线程中使用ArrayList会发生什么？</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      我们真的清楚多线程情况下使用ArrayList会发生什么吗？
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="ArrayList" scheme="https://www.howardliu.cn/tags/ArrayList/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>java import 导入包时，我们需要注意什么呢？</title>
    <link href="https://www.howardliu.cn/java-import-package/"/>
    <id>https://www.howardliu.cn/java-import-package/</id>
    <published>2021-01-31T10:54:40.000Z</published>
    <updated>2021-01-31T10:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/still-life-5322950_1920.jpg" alt="java import 导入包"></p><p>你好，我是看山。</p><p>这篇文章起因是 code review 时和同事关于 import 导入声明的分歧。</p><p>用过 IDEA 的都知道，默认情况下，通过 import 导入类时，当数量达到设置数量（类 5 个、静态变量 3 个），就会改为按需导入方式，也就是使用使用*号折叠导入。</p><p>同事建议不要采用按需导入，要使用单类型导入 (single-type-import)。而我是觉得既然 IDEA 作为宇宙级的 IDE，不会在这种地方出现纰漏，所以想继续按照 IDEA 默认配置来。</p><p>所以总结一下这两种方式的差异。如果对 java import 不熟悉，可以从 <a href="https://javagoal.com/java-import-package/" target="_blank" rel="noopener">这里</a> 看看。</p><a id="more"></a><h2 id="import-的两种导入声明"><a href="#import-的两种导入声明" class="headerlink" title="import 的两种导入声明"></a>import 的两种导入声明</h2><p>在 java 中，通过 import 导入类的方式有两种：</p><ul><li>单类型导入（single-type-import），例如 <code>import java.io.File</code>：这种方式比较容易理解，而且大部分时候我们用的都是这种方式。通过明确指明类和接口路径，将他们导入进来。</li><li>按需类型导入（type-import-on-demand），例如 <code>import java.io.*</code>：通过通配符<code>*</code>定义导入方式，但是并不是直接导入这个包下的所有类，而是可以导入所有类。也就是说，如果需要就导入，不需要就不导入。</li></ul><p>有如下属性：</p><ol><li>java 以这样两种方式导入包中的任何一个<code>public</code>的类和接口（只有 public 类和接口才能被导入）</li><li>上面说到导入声明仅导入声明目录下面的类而不导入子包，这也是为什么称它们为类型导入声明的原因。</li><li>导入的类或接口的简名（simple name）具有编译单元作用域。这表示该类型简名可以在导入语句所在的编译单元的任何地方使用。这并不意味着你可以使用该类型所有成员的简名，而只能使用类型自身的简名。例如：java.lang 包中的 public 类都是自动导入的，包括<code>Math</code>和<code>System</code>类。但是，你不能使用它们的成员的简名<code>PI()</code>和<code>gc()</code>, 而必须使用<code>Math.PI()</code>和<code>System.gc()</code>. 你不需要键入的是<code>java.lang.Math.PI()</code>和<code>java.lang.System.gc()</code>。</li><li>程序员有时会导入当前包或<code>java.lang</code>包，这是不需要的，因为当前包的成员本身就在作用域内，而<code>java.lang</code>包是自动导入的。java 编译器会忽略这些冗余导入声明 (redundant import declarations)。</li></ol><h2 id="按需导入机制"><a href="#按需导入机制" class="headerlink" title="按需导入机制"></a>按需导入机制</h2><p>按需类型导入在大部分情况用起来更加方便，一个通配符可以导入包下的所有类，就不用费劲写一堆导入了。</p><p>但是，根据能量守恒，在敲代码时节省下来的能量，必然会在其他地方消耗。</p><p>比如，<code>Date</code>类，如果完全使用按需类型导入，可以写做<code>import java.util.*</code>。当这个类恰好需要，<code>PrepareStatement</code>时，又需要加上<code>import java.sql.*</code>导入，这个时候，编译器不知道<code>Date</code>类是要用<code>java.util</code>包里的还是<code>java.sql</code>里面的了，就会报出<code>Reference to &#39;Date&#39; is ambiguous, both &#39;java.util.Date&#39; and &#39;java.sql.Date&#39; match</code>异常，也就是所说的<strong>命名冲突</strong>。</p><p>解决办法就是指明<code>Date</code>类的全路径，也就是使用单类型导入：<code>import java.util.Date</code>。</p><p>除了命名冲突，还有一些不太明显的缺点：</p><ol><li>编译速度：因为按需导入机制的特性，需要在 CLASSPATH 下找到所有符合包名的类，在编译时会消耗性能。在小项目中，这个速度可以忽略。如果在大项目中，就会有明细差异。</li><li>可读性：在使用 IDE 开发过程中，我们很少会在<code>import</code>中查看类的路径。但是如果需要我们在其他环境编辑文件，比如 vim，从<code>import</code>查看类的路径就很便捷了。</li></ol><h2 id="导入不需要的类会发生什么呢"><a href="#导入不需要的类会发生什么呢" class="headerlink" title="导入不需要的类会发生什么呢"></a>导入不需要的类会发生什么呢</h2><p>从理性讲，java 编译器一定会在这里做优化，不会把不需要的导入声明加入到 class 文件中，但是之前没有看到哪里有说明，所以动手做一下实验：</p><p>先定义 java 类：</p><pre><code class="java">package cn.howardliu;// 需要用到的单类型导入import java.util.Date;// 需要用到的按需类型导入import java.math.*;// 不需要用到的单类型导入import java.sql.PreparedStatement;// 不需要用到的按需类型导入import java.awt.*;public class Main {    private Date date1;    private BigDecimal num1;    public void test(){        Date date2 = new Date();        BigDecimal num2 = new BigDecimal(0);    }}</code></pre><p>通过命令<code>javac Main.java</code>编译，然后通过<code>javap -verbose Main.class</code>查看编译结果：</p><pre><code class="class">Classfile /path/to/Main.class  Last modified 2021-1-31; size 439 bytes  MD5 checksum 81e13559f738197b4875c2c2afd6fc41  Compiled from &quot;Main.java&quot;public class cn.howardliu.Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #7.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #20            // java/util/Date   #3 = Methodref          #2.#19         // java/util/Date.&quot;&lt;init&gt;&quot;:()V   #4 = Class              #21            // java/math/BigDecimal   #5 = Methodref          #4.#22         // java/math/BigDecimal.&quot;&lt;init&gt;&quot;:(I)V   #6 = Class              #23            // cn/howardliu/Main   #7 = Class              #24            // java/lang/Object   #8 = Utf8               date1   #9 = Utf8               Ljava/util/Date;  #10 = Utf8               num1  #11 = Utf8               Ljava/math/BigDecimal;  #12 = Utf8               &lt;init&gt;  #13 = Utf8               ()V  #14 = Utf8               Code  #15 = Utf8               LineNumberTable  #16 = Utf8               test  #17 = Utf8               SourceFile  #18 = Utf8               Main.java  #19 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V  #20 = Utf8               java/util/Date  #21 = Utf8               java/math/BigDecimal  #22 = NameAndType        #12:#25        // &quot;&lt;init&gt;&quot;:(I)V  #23 = Utf8               cn/howardliu/Main  #24 = Utf8               java/lang/Object  #25 = Utf8               (I)V{  public cn.howardliu.Main();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 12: 0  public void test();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=3, args_size=1         0: new           #2                  // class java/util/Date         3: dup         4: invokespecial #3                  // Method java/util/Date.&quot;&lt;init&gt;&quot;:()V         7: astore_1         8: new           #4                  // class java/math/BigDecimal        11: dup        12: iconst_0        13: invokespecial #5                  // Method java/math/BigDecimal.&quot;&lt;init&gt;&quot;:(I)V        16: astore_2        17: return      LineNumberTable:        line 17: 0        line 18: 8        line 19: 17}SourceFile: &quot;Main.java&quot;</code></pre><p>从 class 文件内容可以看出：</p><ol><li>按需类型导入方式在 class 文件中的表现形式，与按类型导入一样，也会找到需要的类导入，不会导入包中的所有类。</li><li>不需要的类导入声明，最终都会被优化掉，不会出现在 class 文件中。</li><li>java 中的<code>import</code>与 C 语言中的<code>include</code>不同，不会将导入声明的类写入到 class 文件中，各自还是独立的 class 文件。</li></ol><h2 id="JDK-推荐哪种方式"><a href="#JDK-推荐哪种方式" class="headerlink" title="JDK 推荐哪种方式"></a>JDK 推荐哪种方式</h2><p>JDK 绝对是 java 编程的标杆，我们很多都可以从 JDK 中学习：</p><pre><code class="java">import java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;import java.io.InputStream;import java.io.OutputStream;import java.io.Reader;import java.io.Writer;import java.io.OutputStreamWriter;import java.io.BufferedWriter;import java.security.AccessController;import java.security.PrivilegedAction;import sun.util.spi.XmlPropertiesProvider;</code></pre><p>这是<code>java.util.Properties</code>中的 import 声明，可以看出，使用了单类型导入声明，所以，在没有其他要求的情况下，我们尽量还是使用单类型导入。</p><h2 id="文末思考"><a href="#文末思考" class="headerlink" title="文末思考"></a>文末思考</h2><ol><li>java 的<code>import</code>是类导入声明，不会将文件写入到编译后的 class 文件中</li><li>java 的<code>import</code>有两种导入方式：单类型导入、按需类型导入</li><li>按需类型导入只会在编译过程中有性能损失，在运行期与单类型导入无差别</li><li>JDK 源码中，大部分使用了单类型导入。</li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老后端，Apache Storm、WxJava、Cynomys开源贡献者。主业：程序猿，兼职：架构师。游于码界，戏享人生。</p><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/java-import-package/">java import 导入包</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113487825" target="_blank" rel="noopener">java import 导入包</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      java 的`import`是类导入声明，不会将文件写入到编译后的 class 文件中；java 的`import`有两种导入方式：单类型导入、按需类型导入；按需类型导入只会在编译过程中有性能损失，在运行期与单类型导入无差别；JDK 源码中，大部分使用了单类型导入。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="import" scheme="https://www.howardliu.cn/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾收集算法</title>
    <link href="https://www.howardliu.cn/algo-for-jvm-gc/"/>
    <id>https://www.howardliu.cn/algo-for-jvm-gc/</id>
    <published>2021-01-24T13:48:58.000Z</published>
    <updated>2021-01-24T13:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是根据周志明老师的《深入理解Java虚拟机》整理的学习笔记，后续会更新在<a href="https://github.com/howardliu-cn/Rebuild2020/tree/master/Java/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">深入理解Java虚拟机</a>中，希望能够帮到一些需要速成的同学。</p></blockquote><p>从如何判断对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两大类也常被称作“直接垃圾收集”和“间接垃圾收集”。</p><a id="more"></a><blockquote><p>主流 GC 算法均未涉及引用计数式垃圾收集，所以本文所有算法均为追踪式垃圾收集的范畴。</p></blockquote><h2 id="1-分代收集理论"><a href="#1-分代收集理论" class="headerlink" title="1. 分代收集理论"></a>1. 分代收集理论</h2><p>分代收集（Generational Collection），建立在三个假设上：</p><ol><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难消亡。</li><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>根据前两个分代假说，奠定了多款常用垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据年龄分配到不同的区域中存储。</p><p>一般至少将 Java 堆划分为新生代（Young Generation）和老年代（Old Generation）。</p><p>分代收集理论除了划分内存区域，还需要解决其他问题，比如：<strong>对象不是孤立的，对象之间会存在跨代引用</strong>。为了解决这个问题，就出现了第三条假说。</p><p>第三条假说是根据前两条假说逻辑推理得出的隐含推论：存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。</p><p>依据这条假说，我们就不应再为少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每个对象是否存在及存在哪个跨代引用，只需在新生代上建立一个全局的数据结构，被称为记忆集（Remembered Set），这个结构把老年代划分成若干小块，标识老年代哪一块内存会存在跨代引用。当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。</p><p>名词解释：</p><ul><li>部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集<ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：值目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。</li></ul></li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。<ul><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</li></ul></li></ul><h2 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记-清除算法"></a>2. 标记-清除算法</h2><p>标记-清除（Mark-Sweep）算法：标记所有需要回收对象，在标记完成后，统一回收掉所有被标记的对象；或者，标记存活的对象，统一回收所有未被标记的对象。</p><p>缺点：</p><ol><li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分需要被回收，这时必须进行大量标记和清除的动作，导致标记和清除的执行效率随对象数量增长而降低；</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后程序运行过程中需要分配较大对象时无法找到足够连续的内存而不得不触发另一次垃圾收集动作。</li></ol><p><img src="http://static.howardliu.cn/java/mark-sweep.jpg" alt="标记-清除算法"></p><h2 id="3-标记-复制算法"><a href="#3-标记-复制算法" class="headerlink" title="3. 标记-复制算法"></a>3. 标记-复制算法</h2><p>半区复制（Semispace Copying）算法：将可用内存按容量划分大小相等的两块，每次只使用其中一块。当一块内存用完了，就将还存活着的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。</p><p><img src="http://static.howardliu.cn/java/mark-copying.jpg" alt="标记-复制算法"></p><p>Appel 式回收：把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。如果 Survivor 空间不足以容纳 Minor GC 后存活对象时，这些对象通常分配进入老年代。</p><p>HotSpot 虚拟机默认 Eden 和 Survivor 大小比例是 8:1，即每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间被浪费。</p><p>Appel 式回收的理论依据：IBM 公司的研究表明，新生代中的对象有 98%熬不过第一轮收集。</p><h2 id="4-标记-整理算法"><a href="#4-标记-整理算法" class="headerlink" title="4. 标记-整理算法"></a>4. 标记-整理算法</h2><p>标记-整理（Mark-Compact）算法，其中标记过程与“标记-清除”算法一样，整理过程是让所有存储对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。</p><p><img src="http://static.howardliu.cn/java/mark-compact.jpg" alt="标记-整理算法"></p><p>标记整理算法的弊端是移动存活对象并更新所有引用工作量比较大，而且需要 Stop The World，会造成延迟。</p><p>标记清除算法的弊端是由于空间碎片化，需要复杂的内存分配器和内存访问器，会影响吞吐量。</p><p>HotSpot 虚拟机里面关注吞吐量的的 Parallel Scavenge 收集器是基于标记-整理算法的，关注延迟的 CMS 收集器是基于标记-清除算法的。</p><p>还有一种“和稀泥”的方式，大部分时间使用标记-清除算法，容忍内存碎片，当内存碎片影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/algo-for-jvm-gc/">JVM 垃圾收集算法</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113098581" target="_blank" rel="noopener">JVM 垃圾收集算法</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从如何判断对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两大类也常被称作“直接垃圾收集”和“间接垃圾收集”。
    
    </summary>
    
    
      <category term="jvm" scheme="https://www.howardliu.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.howardliu.cn/tags/jvm/"/>
    
      <category term="gc" scheme="https://www.howardliu.cn/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>软件架构-缓存技术</title>
    <link href="https://www.howardliu.cn/caching-techniques/"/>
    <id>https://www.howardliu.cn/caching-techniques/</id>
    <published>2021-01-17T06:57:07.000Z</published>
    <updated>2021-01-17T06:57:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/software-architecture/pipit-5683656_1920.jpg" alt="软件架构-缓存技术"></p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/software-architecture/index.html" target="_blank" rel="noopener">《软件架构》</a> 中关于缓存技术的内容，虽然是 2014 年的文章，但是从软件架构层面上，并不过时。</p></blockquote><a id="more"></a><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是一种加速数据查找（数据读取）的技术，直接读取本地缓存的数据，而不是从数据源读取数据，数据源包括数据库、其他远程系统。</p><p><img src="http://static.howardliu.cn/software-architecture/caching-1.png" alt="caching"></p><p>缓存是比源数据更靠近使用方的一块存储空间，可以更快的读取操作。缓存的存储介质一般是内存或磁盘，很多时候会选择内存作为缓存介质，但是内存缓存会在系统重启时丢失数据。</p><p>在软件系统中，数据缓存存在多层缓存级别或多层缓存系统。在 web 应用中，缓存至少有 3 种存储位置，如下图所示：</p><p><img src="http://static.howardliu.cn/software-architecture/caching-1-2.png" alt="caching"></p><p>在 web 应用中，我们会使用各种各样的数据库存储数据，这些数据库可以将数据存放在内存中，以便我们直接读取，而不需要从磁盘中读取数据。web 服务器可以在内存中缓存图片、css 文件、js 文件等，不需要每次需要的时候从硬盘中访问文件。web 应用可以将从数据库读取的数据缓存起来，这样就不需要每次使用的时候都通过网络从数据库中读取数据了。最后，浏览器也可能存储静态文件和数据。在支持 HTML5 的浏览器中，有 localstorage 存储空间、应用数据缓存、本地 sql 存储等技术支持缓存。</p><p>当我们提到缓存的时候，有下面几项内容需要考虑：</p><ul><li>写缓存</li><li>保持缓存和远程系统数据同步</li><li>管理缓存大小</li></ul><p>我会在接下来的内容中讨论这几项内容。</p><h2 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h2><p>第一项挑战是从远程系统中读取数据写到缓存中，一般有两种方式：</p><ul><li>提前写缓存</li><li>用时写缓存</li></ul><p>提前写缓存是在系统启动的时候，就将需要的数据缓存起来。要做到这一点，需要提前知道哪些数据需要缓存。但是我们有时候并不知道哪些数据需要在系统启动时候就缓存起来。</p><p>用时写缓存是说，在第一次使用数据的时候，将数据缓存起来，之后就可以使用缓存中的数据了。这种操作的方式是，首先检查缓存中是否有数据，有就直接使用，如果没有，就从远程系统读取数据，然后写入缓存中。</p><p>下表中我列出了提前写入和用时写入的优缺点：</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>提前写缓存</td><td>比用时写入减少了第一次缓存数据的延迟</td><td>系统启动初始化缓存数据的时候，需要比较长的时间。而且，有可能缓存的数据永远不会被用到。</td></tr><tr><td>用时写缓存</td><td>缓存的数据都是需要被用到的数据，而且没有启动延迟</td><td>在第一次缓存数据的时候，用的时间比较长，可能导致用户体验不一致</td></tr></tbody></table><p>当然，在真正实践过程中，我们可能两种方式并用：我们可以对热点数据使用提前缓存的方式，对其他数据使用用时缓存的方式。</p><h2 id="保持缓存和远程系统数据同步"><a href="#保持缓存和远程系统数据同步" class="headerlink" title="保持缓存和远程系统数据同步"></a>保持缓存和远程系统数据同步</h2><p>缓存数据的一个巨大挑战是保持缓存数据与远程系统数据保持同步，也就是数据一致。根据系统结构的不同，一般有不同的方式实现这个，我们来聊聊这几种方式。</p><h3 id="直接式缓存"><a href="#直接式缓存" class="headerlink" title="直接式缓存"></a>直接式缓存</h3><p>直写式缓存是允许读写缓存的一种方式，这种方式是，保存缓存数据的计算机，在将数据写入缓存的同时，将数据写到远程系统中。简单说就是，写入操作被写到远程系统中。</p><p>只有远程系统的数据只能被直写式缓存修改时，这种方式才起作用。如果所有的数据读写都要经过直写式缓存系统，那就很容易将写入的数据更新到远程系统中，保持缓存与远程系统数据的一致性。</p><h3 id="基于过期时间"><a href="#基于过期时间" class="headerlink" title="基于过期时间"></a>基于过期时间</h3><p>如果远程系统可以不依赖远程系统进行数据更新，那缓存和远程系统之间数据同步就很难通过直写式缓存方式保证了。</p><p>保持缓存数据同步的一种方法是，为数据设置一个缓存时间。当数据过期时，就把这些数据从缓存中清除。如果再次需要读取这些数据，可以从远程系统中读取最新的数据缓存起来。</p><p>数据过期时间取决于系统需要，有些类型的数据（比如文章），可能不需要随时的完全更新，可以设置 1 小时的过期时间。对于某些文章，你甚至可以忍受 24 小时的过期时间。</p><p>需要注意的是，如果过期时间比较短，可能会频繁读取远程系统，降低缓存的作用。</p><h3 id="主动过期"><a href="#主动过期" class="headerlink" title="主动过期"></a>主动过期</h3><p>还有一种方式是主动过期，是指主动更新缓存数据。比如，远程系统数据更新时，发送一条消息到缓存系统中，指示系统数据已被更新，可以将数据设置为过期。</p><p>主动过期的优点是，可能保证远程系统数据更新后，缓存数据被尽快的更新。还有一个附加好处是“基于过期时间”方式没有办法是实现的，就是不会频繁更新没有修改的数据。</p><p>主动过期的缺点是，需要能够检测远程系统数据的变化。如果远程系统是一个关系型数据库，可以被不同的机制更新数据，那每种更新机制都需要报告他们更新了哪些数据，否则，就没有办法向缓存数据的系统通知过期消息了。</p><h2 id="管理缓存大小"><a href="#管理缓存大小" class="headerlink" title="管理缓存大小"></a>管理缓存大小</h2><p>管理缓存大小，是一个重要的方面。许多系统存储了大量数据，以至于不可能将所有数据都存储在缓存中。因此，需要一种机制来管理缓存的数据量。管理缓存大小通常是将不需要的缓存数据清除，来腾出足够的空间。一般有下面几种方式：</p><ul><li>基于时间清理</li><li>先进先出（FIFO）</li><li>先进后出（FILO）</li><li>最少被使用</li><li>最小访问间隔</li></ul><p>基于时间清理方式是类似于前面提到的基于时间过期。除了可以保持数据与远程系统同步，还能够减少缓存数据的大小。可以开启一个单独的监听线程，也可以在读写新值的时候清理数据。</p><p>先进先出清理方式意味着，当写入一个新的缓存的时候，就需要删除最早插入的缓存值。如果空间足够，也是可以不删除任何数据的。</p><p>先进后出的方式正好和先进先出相反，这种方式对于先存储的数据时热点数据的情况比较有用。</p><p>最少被使用清理方式是首先清理访问次数最少的缓存数据。这种方式的目的是避免清理热点数据，为了实现这种方式，需要记录缓存数据被访问的次数。需要注意一个问题，缓存中的旧值可能有较高的访问次数，这样就意味着这些旧值不会被清理。比如一篇旧文章的缓存，以前被访问过很多次，但是最近很少访问了，但是因为原来的访问量很高，尽管目前访问量较低，也不会被清理。为了避免这种情况，访问次数可以是针对 N 个小时统计。</p><p>最小访问间隔清理方式是将访问时间间隔考虑在内。访问某个缓存数据时，就需要标记访问该数据的时间并增加访问次数。第二次访问这个缓存数据时，就增加访问次数，并计算平均访问时间。那些曾经是热点数据，被频繁访问，但是最近访问时间间隔变长，访问频率下降的数据，其平均访问时间会降低，当降到足够低的时候，就会被清理。</p><p>有一种变化方式是，只计算最后 N 次访问的时间。N 可以是 100、1 或者其他任何有意义的数。每当访问计数到 N 时，访问计数被重置为 0，记录下来访问时间。这种方式可以更快的清理热度下降的数据。</p><p>还有一种变化方式是，定期重置访问计数，并且只使用最小访问的清理方式。比如，每缓存一个小时的数据，前一个小时的访问计数会存储在另一个变量中，以便决策清理时使用。下一个小时访问计数重置为 0。这种机制具有上次变化相同的效果。</p><p>最后两个变体之间的差异总结起来就是在每次缓存检查时，访问计数是否已达到 N，或者时间间隔是否已超过 Y。第一种方式是每隔 N 次访问一次系统时钟，而第二种方式在每次访问时都读取一次系统时钟（查看时间间隔是否已过期）。因为检查一个整数通常比读取系统时钟快，所以我会选择第一种方式。</p><p>请记住，即使使用缓存大小管理系统，也需要清理、读取和存储数据，以保证他们能够与远程系统保持一致。尽管缓存的数据被大量访问而驻留在系统中，有时候也需要与远程系统同步。</p><h2 id="服务器集群中的缓存"><a href="#服务器集群中的缓存" class="headerlink" title="服务器集群中的缓存"></a>服务器集群中的缓存</h2><p>单一服务中的缓存设计更加简单，因为你能够保证，所有写入操作都通过一个服务器，可以使用直写式缓存方式。但是在分布式集群中，情况会比较复杂，下图说明了这种情况：</p><p><img src="http://static.howardliu.cn/software-architecture/caching-2.png" alt="caching"></p><p>简单的使用直写式缓存只会更新写操作的服务器上的缓存，集群中其他服务器对此完全不知情，也就不会更新数据。</p><p>在服务器集群中，可以使用基于时间的过期策略或者主动过期策略，来保证缓存数据与远程系统的同步。</p><h2 id="缓存产品"><a href="#缓存产品" class="headerlink" title="缓存产品"></a>缓存产品</h2><p>实现自己的缓存系统并不难弄，取决于是否需要深度定制。如果没有必要自己实现缓存系统，可以用已经现成的缓存产品。比如：</p><ul><li><a href="http://memcached.org/" target="_blank" rel="noopener">Memcached</a></li><li><a href="http://ehcache.org/" target="_blank" rel="noopener">Ehcache</a></li><li><a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>【译者加】</li></ul><p>我不知道这些产品是否能够满足需要，但是我知道他们用的比较广泛。</p><hr><p>原文链接：<a href="http://tutorials.jenkov.com/software-architecture/caching-techniques.html" target="_blank" rel="noopener">Caching Techniques</a><br>翻译: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接: <a href="https://www.howardliu.cn/caching-techniques/">软件架构-缓存技术</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/112759115" target="_blank" rel="noopener">软件架构-缓存技术</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      缓存是一种加速数据查找（数据读取）的技术，直接读取本地缓存的数据，而不是从数据源读取数据，数据源包括数据库、其他远程系统。
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="缓存" scheme="https://www.howardliu.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>学非探其花 要自拔其根</title>
    <link href="https://www.howardliu.cn/keep-moving-forward/"/>
    <id>https://www.howardliu.cn/keep-moving-forward/</id>
    <published>2021-01-10T12:20:18.000Z</published>
    <updated>2021-01-10T12:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/raving/coast-5870088_1920.jpg" alt="学非探其花 要自拔其根"></p><p>昨天训练营最后一次直播答疑，问了老师一个问题：“课程中很多内容，感觉自己会，但是让自己讲却讲不出来，或者就算讲出来也不够专业，请老师指点一下？”</p><p>老师耐心做了解答，主要说了两点：</p><ol><li>不够透彻，没有抓住核心，更深层次的东西，浮于表面，没有把握和底气。</li><li>缺乏实践，想办法用，想办法深入进去。</li></ol><p>思考一下转化成自己的理解：</p><ol><li>学非探其花，要深拔其根。想要能够讲出来，必须得抓住核心，而不是流于表面。</li><li>世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。想要成长，就得比别人付出更多的努力。</li></ol><p>然后就想到自己14年的一篇旧文，这里再翻出来。</p><a id="more"></a><p>这段时间因为种种事情，感觉自己很浮躁。作为一名IT民工，把自己当做是一个做技术的人，所以一直希望自己是能够踏踏实实做事的人。不管周围如何变化，希望自己能够沉下心来好好的工作、好好学习。</p><p>毕业到现在两年多了，工作上有一些富裕时间可以自己自由安排。刚开始充分利用这些时间，深入学习一些工作中使用的技术，也算是小有成效。也是因为那段时间自己的努力，先是修改项目中使用的一个下拉菜单的插件，深得开发经理的赞赏，在之后移植手机APP的开发过程中，担任骨干开发人员。</p><p>但随着时间的推进，在项目组中担任角色的变化，看到了当前很多流行的技术后，开始这一头、那一脚的学习，Shell、Python、Pro C、NodeJS、Lucene、Solr、Hadoop等等等等，很多都是蜻蜓点水般的了解一下，有的甚至连水都没有沾到。有时候还自以为是的觉得自己很牛X，幸好有一天，突然感觉自己什么都不懂，什么都不会了，才算是幡然悔悟，开始反省自己。</p><p>佛家有三种境界：</p><ul><li>第一境界：看山是山，看水是水；</li><li>第二境界：看山不是山，看水不是水；</li><li>第三境界：看山是山，看水是水。</li></ul><p>跟朋友描述了一下当前的状态，朋友笑称境界提升了。但自己知自家事，我现在还在第一境界中，甚至连第二境界还没有达到，不禁心中很是失落，自己这段时间算是浪费了。</p><p>软件行业本就是新技术层出不穷，更新迭代频繁，想要学会所有的技术是不可能的。我就是陷入的追逐新技术的怪圈中，就像是捉蝴蝶，一会捉这只，一会捉那只，到最后，一只也没有捉到。</p><p>庄子有言：吾生也有涯，而知也无涯，以有涯随无涯，殆已。</p><p>古人诚不我欺。</p><p>知道了自己错在哪，似乎“怎么做”也就呼之欲出。有句话叫做“大道同途”，用在软件方面，应该可以理解为，很多类似的技术其本质都是一样的，没有必要学习所有的技术，只要掌握其中的一部分，其他的可以根据这一部分进行推导，由点及面，就仿佛一张蜘蛛网，掌握了中间的一个点，慢慢的向外扩展，逐步掌握周边的技术。</p><p>杜牧曾经劝诫其子：学非探其花，要自拔其根。</p><p>学习并不能像观赏花卉，应该探其根本，掌握其精髓。当真正掌握精髓之后，便能够举一反三，掌握很多东西了。之前自己学习新技术的时候，只是流于表面，写个Hello World就以为看到了全世界，没有深入学习其中的原理、精髓。</p><p>“练武不练功，到老一场空。”,这些技术就相当于武，是招式架子，而其中的原理，就相当于功，内家功法。</p><p>“阿弥陀佛，善哉善哉，施主悟了。”</p><p>“呵呵。”</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/keep-moving-forward/">学非探其花 要自拔其根</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      学非探其花，要深拔其根。想要能够讲出来，必须得抓住核心，而不是流于表面。世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。想要成长，就得比别人付出更多的努力。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="学非探其花" scheme="https://www.howardliu.cn/tags/%E5%AD%A6%E9%9D%9E%E6%8E%A2%E5%85%B6%E8%8A%B1/"/>
    
      <category term="要自拔其根" scheme="https://www.howardliu.cn/tags/%E8%A6%81%E8%87%AA%E6%8B%94%E5%85%B6%E6%A0%B9/"/>
    
  </entry>
  
</feed>
