<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2021-04-11T08:52:20.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 并发基础（五）：面试实战之多线程顺序打印</title>
    <link href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/"/>
    <id>https://www.howardliu.cn/java-concurrency-ordered-thread-print/</id>
    <published>2021-04-11T08:52:20.000Z</published>
    <updated>2021-04-11T08:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/plant-3263600_1920.jpg" alt="Java 并发基础（五）：面试实战之多线程顺序打印"></p><p>你好，我是看山。</p><p>来个面试题，让大家练练手。这个题在阿里和小米都被问过，所以放在这个抛砖引玉，期望能够得到一个更佳的答案。</p><a id="more"></a><p>实现 3 个线程 A、B、C，A 线程持续打印“A”，B 线程持续打印“B”，C 线程持续打印“C”，启动顺序是线程 C、线程 B、线程 A，打印的结果是：ABC。</p><h2 id="解法一：状态位变量控制"><a href="#解法一：状态位变量控制" class="headerlink" title="解法一：状态位变量控制"></a>解法一：状态位变量控制</h2><p>这个问题考察的是多线程协同顺序执行。也就是第一个线程最先达到执行条件，开始执行，执行完之后，第二个线程达到执行条件，开始执行，以此类推。可以想到的是，通过状态位来表示线程执行的条件，多个线程自旋等待状态位变化。</p><p>线上代码：</p><pre><code class="java">import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ABCThread {    private static final Lock lock = new ReentrantLock();    private static volatile int state = 0;    private static final Thread threadA = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 0) {                    System.out.println(&quot;A&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;A thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    private static final Thread threadB = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 1) {                    System.out.println(&quot;B&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;B thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    private static final Thread threadC = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                if (state % 3 == 2) {                    System.out.println(&quot;C&quot;);                    state++;                    break;                } else {                    System.out.println(&quot;C thread &amp; state = &quot; + state);                }            } finally {                lock.unlock();            }        }    });    public static void main(String[] args) {        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>可以看到，状态位<code>state</code>使用<code>volatile</code>修饰，是希望一个线程修改状态位值之后，其他线程可以读取到刚修改的数据，这个属于 Java 内存模型的范围，后续会有单独的章节描述。</p><p>这个可以解题，但是却有很多性能上的损耗。因为每个进程都在自旋检查状态值<code>state</code>是否符合条件，而且自旋过程中会有获取锁的过程，代码中在不符合条件时打印了一些内容，比如：<code>System.out.println(&quot;A thread &amp; state = &quot; + state);</code>，我们可以运行一下看看结果：</p><pre><code class="log">C thread &amp; state = 0...67行C thread &amp; state = 0B thread &amp; state = 0...43行B thread &amp; state = 0AC thread &amp; state = 1...53行C thread &amp; state = 1BC</code></pre><p>可以看到，在A线程获取到锁之前，C线程和B线程自旋了100多次，然后A线程才获取机会获取锁和打印。然后在B线程获取锁之前，C线程又自旋了53次。性能损耗可见一斑。</p><h2 id="解法二：Condition实现条件判断"><a href="#解法二：Condition实现条件判断" class="headerlink" title="解法二：Condition实现条件判断"></a>解法二：Condition实现条件判断</h2><p>既然无条件自旋浪费性能，那就加上条件自旋。</p><p>代码如下：</p><pre><code class="java">import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class ABCThread2 {    private static final Lock lock = new ReentrantLock();    private static volatile int state = 0;    private static final Condition conditionA = lock.newCondition();    private static final Condition conditionB = lock.newCondition();    private static final Condition conditionC = lock.newCondition();    private static final Thread threadA = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 0) {                    System.out.println(&quot;A await start&quot;);                    conditionA.await();                    System.out.println(&quot;A await end&quot;);                }                System.out.println(&quot;A&quot;);                state++;                conditionB.signal();                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    private static final Thread threadB = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 1) {                    System.out.println(&quot;B await start&quot;);                    conditionB.await();                    System.out.println(&quot;B await end&quot;);                }                System.out.println(&quot;B&quot;);                state++;                conditionC.signal();                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    private static final Thread threadC = new Thread(() -&gt; {        while (true) {            lock.lock();            try {                while(state % 3 != 2) {                    System.out.println(&quot;C await start&quot;);                    conditionC.await();                    System.out.println(&quot;C await end&quot;);                }                System.out.println(&quot;C&quot;);                state++;                break;            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    });    public static void main(String[] args) {        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>通过<code>Lock</code>锁的<code>Condition</code>实现有条件自旋，运行结果如下：</p><pre><code class="log">C await startB await startAB await endBC await endC</code></pre><p>可以从运行结果看到，C线程发现自己不符合要求，就通过<code>conditionC.await();</code>释放锁，然后等待条件被唤醒后重新获得锁。然后是B线程，最后是A线程开始执行，发现符合条件，直接运行，然后唤醒B线程的锁条件，依次类推。这种方式其实和信号量很类似。</p><h2 id="解法三：信号量"><a href="#解法三：信号量" class="headerlink" title="解法三：信号量"></a>解法三：信号量</h2><p>先上代码：</p><pre><code class="java">import java.util.concurrent.Semaphore;class ABCThread3 {    private static Semaphore semaphoreA = new Semaphore(1);    private static Semaphore semaphoreB = new Semaphore(1);    private static Semaphore semaphoreC = new Semaphore(1);    private static final Thread threadA = new Thread(() -&gt; {        try {            semaphoreA.acquire();            System.out.println(&quot;A&quot;);            semaphoreB.release();        } catch (InterruptedException e) {            e.printStackTrace();        }    });    private static final Thread threadB = new Thread(() -&gt; {        try {            semaphoreB.acquire();            System.out.println(&quot;B&quot;);            semaphoreC.release();        } catch (InterruptedException e) {            e.printStackTrace();        }    });    private static final Thread threadC = new Thread(() -&gt; {        try {            semaphoreC.acquire();            System.out.println(&quot;C&quot;);        } catch (InterruptedException e) {            e.printStackTrace();        }    });    public static void main(String[] args) throws InterruptedException {        semaphoreB.acquire();        semaphoreC.acquire();        threadC.start();        threadB.start();        threadA.start();    }}</code></pre><p>代码中执行前先执行了<code>semaphoreB.acquire();</code>和<code>semaphoreC.acquire();</code>，是为了将B和C的信号释放，这个时候，就能够阻塞B线程、C线程中信号量的获取，直到顺序获取了信号值。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p>这个题是考察大家对线程执行顺序和线程之间协同的理解，文中所实现的三种方式，都能解题，只不过代码复杂度和性能有差异。因为其中涉及很多多线程的内容，后续会单独开文说明每个知识点。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a></li><li><a href="https://www.howardliu.cn/main-thread-waiting-for-the-end-of-subthread/">Java 并发基础（二）：主线程等待子线程结束</a></li><li><a href="https://www.howardliu.cn/talk-about-CountDownLatch-again/">Java 并发基础（三）：再谈 CountDownLatch</a></li><li><a href="https://www.howardliu.cn/talk-about-CyclicBarrier-again/">Java 并发基础（四）：再谈 CyclicBarrier</a></li><li><a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115609160" target="_blank" rel="noopener">Java 并发基础（五）：面试实战之多线程顺序打印</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      实现 3 个线程 A、B、C，A 线程持续打印“A”，B 线程持续打印“B”，C 线程持续打印“C”，启动顺序是线程 C、线程 B、线程 A，打印的结果是：ABC。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="concurrency" scheme="https://www.howardliu.cn/tags/concurrency/"/>
    
      <category term="thread" scheme="https://www.howardliu.cn/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发基础（一）：synchronized 锁同步</title>
    <link href="https://www.howardliu.cn/java-concurrency-synchronized/"/>
    <id>https://www.howardliu.cn/java-concurrency-synchronized/</id>
    <published>2021-03-28T07:55:40.000Z</published>
    <updated>2021-03-28T07:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/seagull-5884998_1920.jpg" alt="Java 并发基础（一）：synchronized 锁同步"></p><p>你好，我是看山。</p><p>synchronized 是 java 内置的同步锁实现，一个关键字实现对共享资源的锁定。synchronized 有 3 种使用场景，场景不同，加锁对象也不同：</p><ol><li>普通方法：锁对象是当前实例对象</li><li>静态方法：锁对象是类的 Class 对象</li><li>方法块：锁对象是 synchronized 括号中的对象</li></ol><a id="more"></a><h2 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h2><p>synchronized 是通过进入和退出 Monitor 对象实现锁机制，代码块通过一对 monitorenter/monitorexit 指令实现。在编译后，monitorenter 指令插入到同步代码块的开始位置，monitorexit 指令插入到方法结束和异常处，JVM 要保证 monitorenter 和 monitorexit 成对出现。任何对象都有一个 Monitor 与之关联，当且仅当一个 Monitor 被持有后，它将处于锁状态。</p><p>在执行 monitorenter 时，首先尝试获取对象的锁，如果对象没有被锁定或者当前线程持有锁，锁的计数器加 1；相应的，在执行 monitorexit 指令时，将锁的计数器减 1。当计数器减到 0 时，锁释放。如果在 monitorenter 获取锁失败，当前线程会被阻塞，直到对象锁被释放。</p><p>在 JDK6 之前，Monitor 的实现是依靠操作系统内部的互斥锁实现（一般使用的是 Mutex Lock 实现），线程阻塞会进行用户态和内核态的切换，所以同步操作是一个无差别的重量级锁。</p><p>后来，JDK 对 synchronized 进行升级，为了避免线程阻塞时在用户态与内核态之间切换线程，会在操作系统阻塞线程前，加入自旋操作。然后还实现 3 种不同的 Monitor：偏向锁（Biased Locking）、轻量级锁（Lightweight Locking）、重量级锁。在 JDK6 之后，synchronized 的性能得到很大的提升，相比于 ReentrantLock 而言，性能并不差，只不过 ReentrantLock 使用起来更加灵活。</p><h2 id="适应性自旋（Adaptive-Spinning）"><a href="#适应性自旋（Adaptive-Spinning）" class="headerlink" title="适应性自旋（Adaptive Spinning）"></a>适应性自旋（Adaptive Spinning）</h2><p>synchronized 对性能影响最大的是阻塞的实现，挂起线程和恢复线程都需要操作系统帮助完成，需要从用户态转到内核态，状态转换需要耗费很多 CPU 时间。</p><p>在我们大多数的应用中，共享数据的锁定状态只会持续很短的一段时间，为了这段时间挂起和回复线程消耗的时间不值得。而且，现在大多数的处理器都是多核处理器，如果让后一个线程再等一会，不释放 CPU，等前一个释放锁，后一个线程立马获取锁执行任务就行。这就是所谓的自旋，让线程执行一个忙循环，自己在原地转一会，每转一圈看看锁释放没有，释放了直接获取锁，没有释放就再转一圈。</p><p>自旋锁是在 JDK 1.4.2 引入（使用<code>-XX:+UseSpinning</code>参数打开），JDK 1.6 默认打开。自旋锁不能代替阻塞，因为自旋等待虽然避免了线程切换的开销，但是它要占用 CPU 时间，如果锁占用时间短，自旋等待效果挺好，反之，则是性能浪费。所以在 JDK 1.6 中引入了自适应自旋锁：如果同一个锁对象，自旋等待刚成功，且持有锁的线程正在运行，那本次自旋很有可能成功，会允许自旋等待持续时间长一些。反之，如果对于某个锁，自旋很少成功，那之后很有可能直接省略自旋过程，避免浪费 CPU 资源。</p><h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><h3 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h3><p>synchronized 用的锁存在于 Java 对象头里，对象头里的 Mark Word 里存储的数据会随标志位的变化而变化，变化如下：</p><p><img src="http://static.howardliu.cn/java/F7DE8310-E000-4B64-A3AA-9463B483BDF1.jpg" alt="Java 对象头 Mark Word"></p><h3 id="偏向锁（Biased-Locking）"><a href="#偏向锁（Biased-Locking）" class="headerlink" title="偏向锁（Biased Locking）"></a>偏向锁（Biased Locking）</h3><p>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低，引入偏向锁。</p><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。</p><h4 id="偏向锁获取"><a href="#偏向锁获取" class="headerlink" title="偏向锁获取"></a>偏向锁获取</h4><ol><li>当锁对象第一次被线程获取时，对象头的标志位设为 01，偏向模式设为 1，表示进入偏向模式。</li><li>测试线程 ID 是否指向当前线程，如果是，执行同步代码块，如果否，进入 3</li><li>使用 CAS 操作把获得到的这个锁的线程 ID 记录在对象的 Mark Word 中。如果成功，执行同步代码块，如果失败，说明存在过其他线程持有锁对象的偏向锁，开始尝试当前线程获取偏向锁</li><li>当到达全局安全点时（没有字节码正在执行），会暂停拥有偏向锁的线程，检查线程状态。如果线程已经结束，则将对象头设置成无锁状态（标志位为“01”），然后重新偏向新的线程；如果线程仍然活着，撤销偏向锁后升级到轻量级锁状态（标志位为“00”），此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量级锁。</li></ol><h4 id="偏向锁释放"><a href="#偏向锁释放" class="headerlink" title="偏向锁释放"></a>偏向锁释放</h4><p>偏向锁的释放采用的是惰性释放机制：只有等到竞争出现，才释放偏向锁。释放过程就是上面说的第 4 步，这里不再赘述。</p><h4 id="关闭偏向锁"><a href="#关闭偏向锁" class="headerlink" title="关闭偏向锁"></a>关闭偏向锁</h4><p>偏斜锁并不适合所有应用场景，撤销操作（revoke）是比较重的行为，只有当存在较多不会真正竞争的同步块时，才能体现出明显改善。实践中对于偏斜锁的一直是有争议的，有人甚至认为，当你需要大量使用并发类库时，往往意味着你不需要偏斜锁。</p><p>所以如果你确定应用程序里的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，那么程序默认会进入轻量级锁状态。</p><h3 id="轻量级锁（Lightweight-Locking）"><a href="#轻量级锁（Lightweight-Locking）" class="headerlink" title="轻量级锁（Lightweight Locking）"></a>轻量级锁（Lightweight Locking）</h3><p>轻量级锁不是用来代替重量级锁的，它的初衷是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗。</p><h4 id="轻量级锁获取"><a href="#轻量级锁获取" class="headerlink" title="轻量级锁获取"></a>轻量级锁获取</h4><ol><li>如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的 Mark Word 的拷贝，官方称之为 Displaced Mark Word。这时候线程堆栈与对象头的状态如下图所示：<br> <img src="http://static.howardliu.cn/java/C9DCD644-0694-4FF3-8E2E-0FCEA7C0CB5E.png" alt="Lock Record"></li><li>拷贝对象头中的 Mark Word 复制到锁记录（Lock Record）中。</li><li>拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock record 里的 owner 指针指向 object mark word。</li><li>如果成功，当前线程持有该对象锁，将对象头的 Mark Word 锁标志位设置为“00”，表示对象处于轻量级锁定状态，执行同步代码块。这时候线程堆栈与对象头的状态如下图所示：<br><img src="http://static.howardliu.cn/java/3F5C415F-2953-4987-A38E-BB4AB97600AB.png" alt="Lock Record"></li><li>如果更新失败，检查对象头的 Mark Word 是否指向当前线程的栈帧，如果是，说明当前线程拥有锁，直接执行同步代码块。</li><li>如果否，说明多个线程竞争锁，如果当前只有一个等待线程，通过自旋尝试获取锁。当自旋超过一定次数，或又来一个线程竞争锁，轻量级锁膨胀为重量级锁。重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转，锁标志的状态值变为“10”，Mark Word 中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。</li></ol><h4 id="轻量级锁解锁"><a href="#轻量级锁解锁" class="headerlink" title="轻量级锁解锁"></a>轻量级锁解锁</h4><p>轻量级锁解锁的时机是，当前线程同步块执行完毕。</p><ol><li>通过 CAS 操作尝试把线程中复制的 Displaced Mark Word 对象替换当前的 Mark Word。</li><li>如果成功，整个同步过程完成</li><li>如果失败，说明存在竞争，且锁膨胀为重量级锁。释放锁的同时，会唤醒被挂起的线程。</li></ol><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>轻量级锁适应的场景是线程近乎交替执行同步块的情况，如果存在同一时间访问相同锁对象时（第一个线程持有锁，第二个线程自旋超过一定次数），轻量级锁会膨胀为重量级锁，Mark Word 的锁标记位更新为 10，Mark Word 指向互斥量（重量级锁）。</p><p>重量级锁是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的 Mutex Lock（互斥锁）。操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 JDK 1.6 之前，synchronized 重量级锁效率低的原因。</p><p>下图是偏向锁、轻量级锁、重量级锁之间转换对象头 Mark Word 数据转变：</p><p><img src="http://static.howardliu.cn/java/640.png" alt="偏向锁、轻量级锁、重量级锁之间转换 "></p><p>网上有一个比较全的锁升级过程：</p><p><img src="http://static.howardliu.cn/java/synchronized.png" alt="锁升级过程"></p><h2 id="锁消除（Lock-Elimination）"><a href="#锁消除（Lock-Elimination）" class="headerlink" title="锁消除（Lock Elimination）"></a>锁消除（Lock Elimination）</h2><p>锁消除说的是虚拟机即时编译器在运行过程中，对于一些同步代码，如果检测到不可能存在共享数据竞争情况，就会删除锁。也就是说，即时编译器根据情况删除不必要的加锁操作。</p><p>锁消除的依据是逃逸分析。简单地说，逃逸分析就是分析对象的动态作用域。分三种情况：</p><ul><li>不逃逸：对象的作用域只在本线程本方法</li><li>方法逃逸：对象在方法内定义后，被外部方法所引用</li><li>线程逃逸：对象在方法内定义后，被外部线程所引用</li></ul><p>即时编译器会针对对象的不同情况进行优化处理：</p><ul><li>对象栈上分配（Stack Allocations，HotSpot 不支持）：直接在栈上创建对象。</li><li>标量替换（Scalar Replacement）：将对象拆散，直接创建被方法使用的成员变量。前提是对象不会逃逸出方法范围。</li><li>同步消除（Synchronization Elimination）：就是锁消除，前提是对象不会逃逸出线程。</li></ul><p>对于锁消除来说，就是逃逸分析中，那些不会逃出线程的加锁对象，就可以直接删除同步锁。</p><p>通过代码看一个例子：</p><pre><code class="java">public void elimination1() {    final Object lock = new Object();    synchronized (lock) {        System.out.println(&quot;lock 对象没有只会作用域本线程，所以会锁消除。&quot;);    }}public String elimination2() {    final StringBuffer sb = new StringBuffer();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb.toString();}public StringBuffer notElimination() {    final StringBuffer sb = new StringBuffer();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb;}</code></pre><p><code>elimination1()</code>中的锁对象<code>lock</code>作用域只是方法内，没有逃逸出线程，<code>elimination2()</code>中的<code>sb</code>也就这样，所以这两个方法的同步锁都会被消除。但是<code>notElimination()</code>方法中的<code>sb</code>是方法返回值，可能会被其他方法修改或者其他线程修改，所以，单看这个方法，不会消除锁，还得看调用方法。</p><h2 id="锁粗化（Lock-Coarsening）"><a href="#锁粗化（Lock-Coarsening）" class="headerlink" title="锁粗化（Lock Coarsening）"></a>锁粗化（Lock Coarsening）</h2><p>原则上，我们在编写代码的时候，要将同步块作用域的作用范围限制的尽量小。使得需要同步的操作数量尽量少，当存在锁竞争时，等待线程尽快获取锁。但是有时候，如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有出现线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机检测到有一串零碎的操作都是对同一对象的加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><p>比如上面例子中的<code>elimination2()</code>方法中，<code>StringBuffer</code>的<code>append</code>是同步方法，频繁操作时，会进行锁粗化，最后结果会类似于（只是类似，不是真实情况）：</p><pre><code class="java">public String elimination2() {    final StringBuilder sb = new StringBuilder();    synchronized (sb) {        sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);        return sb.toString();    }}</code></pre><p>或者</p><pre><code class="java">public synchronized String elimination3() {    final StringBuilder sb = new StringBuilder();    sb.append(&quot;Hello, &quot;).append(&quot;World!&quot;);    return sb.toString();}</code></pre><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li>同步操作中影响性能的有两点：<ol><li>加锁解锁过程需要额外操作</li><li>用户态与内核态之间转换代价比较大</li></ol></li><li>synchronized 在 JDK 1.6 中有大量优化：分级锁（偏向锁、轻量级锁、重量级锁）、锁消除、锁粗化等。</li><li>synchronized 复用了对象头的 Mark Word 状态位，实现不同等级的锁实现。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>《深入理解 Java 虚拟机》</li><li>《Java 并发编程的艺术》</li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a></li><li><a href="https://www.howardliu.cn/main-thread-waiting-for-the-end-of-subthread/">Java 并发基础（二）：主线程等待子线程结束</a></li><li><a href="https://www.howardliu.cn/talk-about-CountDownLatch-again/">Java 并发基础（三）：再谈 CountDownLatch</a></li><li><a href="https://www.howardliu.cn/talk-about-CyclicBarrier-again/">Java 并发基础（四）：再谈 CyclicBarrier</a></li><li><a href="https://www.howardliu.cn/java-concurrency-ordered-thread-print/">Java 并发基础（五）：面试实战之多线程顺序打印</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-concurrency-synchronized/">Java 并发基础（一）：synchronized 锁同步</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115286598" target="_blank" rel="noopener">Java 并发基础（一）：synchronized 锁同步</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      synchronized 是 java 内置的同步锁实现，一个关键字实现对共享资源的锁定。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="concurrency" scheme="https://www.howardliu.cn/tags/concurrency/"/>
    
      <category term="synchronized" scheme="https://www.howardliu.cn/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（三）：Docker 命令</title>
    <link href="https://www.howardliu.cn/docker-commands/"/>
    <id>https://www.howardliu.cn/docker-commands/</id>
    <published>2021-03-19T12:36:47.000Z</published>
    <updated>2021-03-19T12:36:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/breakwater-6017041_1920.jpg" alt="Docker 教程（三）：Docker 命令"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第三篇。</p></blockquote><a id="more"></a><p>我们通过 Docker 命令与操作 Docker 服务，可以构建 Docker 镜像、运行 Docker 容器、将 Docker 镜像推送到远程等。本文主要介绍一些常用的 Docker 命令。</p><p>Docker 有很多命令，本文不会介绍所有的命令，如果需要完整的命令教程，可以参考 <a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">Docker command line reference</a>。</p><p>请注意，根据在 Linux 系统上安装 Docker 的方式，可能需要在所有命令前面加上<code>sudo</code>，使用 root 权限运行他们。比如：</p><pre><code class="bash">sudo docker build .</code></pre><p>… 而不仅仅是：</p><pre><code class="bash">docker build .</code></pre><h2 id="Docker-命令行工具"><a href="#Docker-命令行工具" class="headerlink" title="Docker 命令行工具"></a>Docker 命令行工具</h2><p>在 Linux 系统中安装 Docker 时，会安装一个名为<code>docker</code>的命令行工具，可以在 Linux 命令行执行。</p><p><code>docker</code>有很多的参数，不同的参数作用不同，可以指挥 Docker 做出不同的行为，可以认为是给 Docker 的命令。以下是<code>docker</code>命令示例：</p><pre><code class="bash">docker build .</code></pre><p>这个示例中包含三部分：<code>docker</code>命令、参数<code>build</code>、参数<code>.</code>。</p><p>参数<code>build</code>是一个 Docker 命令，换句话说，是一个给 docker 可执行命令行的命令。通常，docker 命令行的第一个参数都是 Docker 命令。</p><p>参数<code>.</code>是<code>build</code>命令的参数。</p><h2 id="docker-build"><a href="#docker-build" class="headerlink" title="docker build"></a>docker build</h2><p><code>docker build</code>命令是调用 Docker 从 Dockerfile 文件构建 docker 镜像，要使用<code>docker build</code>命令，必须告诉它从哪个 Dockerfile 文件生成镜像。关于 Dockerfile 的内容，可以查看 <a href="https://www.howardliu.cn/docker-dockerfile/">这里</a>。以下是<code>docker build</code>命令示例：</p><pre><code class="bash">docker build .</code></pre><p>参数<code>.</code>表示从当前目录找到 Dockerfile 文件。</p><h2 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h2><p><code>docker images</code>命令是列出本机的 Docker 镜像，以下是<code>docker images</code>命令示例：</p><pre><code class="bash">docker images</code></pre><p>运行上述命令会输出类似下面的内容：</p><pre><code class="text">REPOSITORY       TAG        IMAGE ID        CREATED          SIZEhello-world      latest     fce289e99eb9    9 months ago     1.84kB</code></pre><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><p><code>docker run</code>命令用来基于给定的 Docker 镜像运行 Docker 容器，<code>docker run</code>的参数，可以是 Docker 镜像的名称或 ID，以下是运行 Docker 容器的示例：</p><pre><code class="bash">docker run hello-world</code></pre><p>这个例子会基于<code>hello-world</code>镜像运行 Docker 容器。</p><p>我们还可以通过 Docker 镜像 ID 运行 Docker 容器，命令如下：</p><pre><code class="bash">docker run fce289e99eb9</code></pre><h2 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h2><p><code>docker ps</code>命令用于显示当前系统中正在运行的 Docker 容器，示例如下：</p><pre><code class="bash">docker ps</code></pre><p>注意，一些 Docker 容器会在完成任务后立即关闭，在<code>docker ps</code>的结果列表中，这种 Docker 容器很有可能会很长时间都不可见。</p><p>【译者注：本文就 4 个命令，还有很多常用的命令没有提到，比如<code>docker exec</code>之类的。其实，对于 Docker 命令行来说，我们可以先浏览一遍，知道个大概，等有需要的时候，重点看一下。个人感觉，命令的需要关键是要经常用。如果不用，转眼就忘，可以类比 Linux 命令。】</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/docker-commands.html" target="_blank" rel="noopener">Docker Commands</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/115048842" target="_blank" rel="noopener">Docker 教程（三）：Docker 命令</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      我们通过 Docker 命令与操作 Docker 服务，可以构建 Docker 镜像、运行 Docker 容器、将 Docker 镜像推送到远程等。本文主要介绍一些常用的 Docker 命令。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（二）：Dockerfile</title>
    <link href="https://www.howardliu.cn/docker-dockerfile/"/>
    <id>https://www.howardliu.cn/docker-dockerfile/</id>
    <published>2021-03-13T15:30:08.000Z</published>
    <updated>2021-03-13T15:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/shops-5992277_1920.jpg" alt="Docker 教程（二）：Dockerfile"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第二篇。</p></blockquote><a id="more"></a><p>Dockerfile 包含一组关于如何构建 Docker 镜像的说明，通过<code>docker build</code>命令执行 Dockerfile 文件，可以构建一个 Docker 镜像，本文介绍了如何编写 Dockerfile 文件以及构建一个 Docker 镜像。</p><h2 id="Dockerfile-的好处"><a href="#Dockerfile-的好处" class="headerlink" title="Dockerfile 的好处"></a>Dockerfile 的好处</h2><p>Dockerfile 文件以书面形式说明了如何构建一个 Docker 镜像，Docker 镜像通常包含如下内容：</p><ul><li>首先需要一个基本的 Docker 镜像，在这个基础 Docker 镜像上构建自己的 Docker 镜像。</li><li>一组需要安装在 Docker 镜像中的工具和应用。</li><li>一组需要复制到 Docker 镜像中的文件（比如配置文件）。</li><li>可能需要在防火墙中打开的网络（TPC/UDP）端口或其他。</li><li>等等。</li></ul><p>首先，在 Dockerfile 文件中以书面形式说明这些，就意味着，我们不用特意记住应用程序如何安装，包括操作系统什么要求、需要安装的应用程序、需要赋值的文件、需要打开的网络端口等，这些内容都被记录在 Dockerfile 中。</p><p>另外，通过 Dockerfile 文件构建 Docker 镜像，我们不需要手动执行这些繁琐重复且容易出错的工作。Docker 会自动做这些事情，简单、快速、且不容易出错。</p><p>第三，我们很容易和其他人分享 Dockerfile 文件，并且他们可以自己构建 Docker 镜像。</p><p>第四，Dockerfile 很容易存储在 Git 这样的版本控制器中，这样就可以跟踪 Dockerfile（服务器、应用配置）的变更记录。版本控制器也可以很容易的让人们协同合作，比如在 Dockerfile 上，以及分享 Dockerfile。</p><h2 id="Dockerfile-的结构"><a href="#Dockerfile-的结构" class="headerlink" title="Dockerfile 的结构"></a>Dockerfile 的结构</h2><p>Dockerfile 包含一组指令，每个指令有一个命令和参数组成，类似于命令行可执行文件。下面是一个 Dockerfile 简单示例：</p><pre><code class="dockerfile"># 基础镜像FROM ubuntu:latest# 这里可以有更多安装软件和复制文件到镜像中的说明。COPY    /myapp/target/myapp.jar    /myapp/myapp.jar# 在 Docker 容器中执行的命令。CMD echo Starting Docker Container</code></pre><h2 id="Docker-基础镜像"><a href="#Docker-基础镜像" class="headerlink" title="Docker 基础镜像"></a>Docker 基础镜像</h2><p>Docker 镜像是由层组成，每一层都会为最终的 Docker 镜像添加一些内容。每一个层实际上都是一个单独的 Docker 镜像，所以说，Docker 镜像是由一个或多个层镜像组成，我们可以在其上添加自己的层。</p><p>当通过 Dockerfile 文件指定自己的 Docker 镜像时，通常是从一个 Docker 基础镜像开始。这是另一个 Docker 镜像，可以在其上构建自己的 Docker 镜像。这个 Docker 基础镜像本身可能也包含多个层，并且是基于另一个基础镜像构建的。</p><p>我们可以使用<code>From</code>命令在 Dockerfile 文件中指定 Docker 镜像作为基础镜像，如下节所述。</p><h2 id="MAINTAINER"><a href="#MAINTAINER" class="headerlink" title="MAINTAINER"></a>MAINTAINER</h2><p><code>MAINTAINER</code>命令用于说明谁在维护这个 Dockerfile 文件。比如：</p><pre><code class="dockerfile">MAINTAINER   Joe Blocks &lt;joe@blocks.com&gt;</code></pre><p><code>MAINTAINER</code>命令并不常用，因为这类信息在 Git 存储或其他地方有了。</p><h2 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h2><p><code>FROM</code>命令用于指定 Docker 基础镜像，如果是从原始 Linux 镜像开始，可以使用如下命令：</p><pre><code class="dockerfile"># 基础镜像FROM ubuntu:latest</code></pre><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p><code>CMD</code>命令用于指定启动 Docker 容器是需要执行的命令，该容器是基于此 Dockerfile 构建的 Docker 镜像，下面是一些 Dockerfile 的<code>CMD</code>示例：</p><pre><code class="dockerfile">CMD echo Docker container started.</code></pre><p>本例是打印“Docker container started”这行文本。</p><p>下一个<code>CMD</code>示例是启动一个 java 应用：</p><pre><code class="dockerfile">CMD java -cp /myapp/myapp.jar com.jenkov.myapp.MainClass arg1 arg2 arg3</code></pre><h2 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h2><p><code>COPY</code>命令将一个或多个文件从主机（从 Dockerfile 文件构建 Docker 镜像的机器）复制到 Docker 镜像中，可以复制的内容包括文件或目录，下面是一个示例：</p><pre><code class="dockerfile">COPY    /myapp/target/myapp.jar    /myapp/myapp.jar</code></pre><p>这个例子是把主机的/myapp/target/myapp.jar 文件复制到 Docker 进行中的/myapp/myapp.jar 文件。第一个参数是主机路径（从哪里来），第二个参数是 Docker 镜像的路径（到哪里去）。</p><p>我们还可以复制一个目录到 Docker 镜像中，比如：</p><pre><code class="dockerfile">COPY    /myapp/config/prod    /myapp/config</code></pre><p>这个例子是把主机的/myapp/config/prod 目录复制到 Docker 镜像中的/myapp/config 目录。</p><p>我们还可以复制多个文件到 Docker 镜像中的一个目录中，比如：</p><pre><code class="dockerfile">COPY    /myapp/config/prod/conf1.cfg   /myapp/config/prod/conf2.cfg   /myapp/config/</code></pre><p>这个例子是将主机的/myapp/config/prod/conf1.cfg 文件和/myapp/conig/prod/conf2.cfg 文件复制到 Docker 镜像中的/myapp/config/目录中。注意，目标目录必须以/（斜杠）结束才能工作。</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p><code>ADD</code>命令与<code>COPY</code>命令工作方式相同，只有一些细微的差别：</p><ul><li><code>ADD</code>命令可以复制并提取 TAR 文件到 Docker 镜像中。</li><li><code>ADD</code>命令可以通过 HTTP 下载文件，并复制到 Docker 镜像中。</li></ul><p>下是一些示例：</p><pre><code class="dockerfile">ADD    myapp.tar    /myapp/</code></pre><p>这个例子是将指定的 TAR 文件解压缩并提取到 Docker 镜像的/myapp/目录中。</p><p>下面是另一个例子：</p><pre><code class="dockerfile">ADD    http://jenkov.com/myapp.jar    /myapp/</code></pre><h2 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h2><p><code>ENV</code>命令是在 Docker 镜像中设置环境变量，此环境变量可用于<code>CMD</code>命令在 Docker 镜像内部启动应用程序。举个例子：</p><pre><code class="dockerfile">ENV    MY_VAR   123</code></pre><p>本例将环境变量<code>MY_VAR</code>设置为值 123。</p><h2 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h2><p><code>RUN</code>可以在 Docker 镜像中执行命令行指令，执行时机是 Docker 镜像构建过程中，所以<code>RUN</code>命令只会执行一次。<code>RUN</code>命令可用于在 Docker 镜像中安装应用程序、提取文件或其他命令行功能，这些操作只需要执行一次，以供 Docker 镜像后续使用。</p><pre><code class="dockerfile">RUN apt-get install some-needed-app</code></pre><h2 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h2><p><code>ARG</code>命令允许定义一个参数，这个参数可以在通过 Dockerfile 文件构建 Docker 镜像时，通过命令参数传递给 Docker。比如：</p><pre><code class="dockerfile">ARG tcpPort</code></pre><p>当执行<code>docker build</code>命令执行 Dockerfile 构建 Docker 镜像时，可以指定<code>tcpPort</code>参数，比如：</p><pre><code class="dockerfile">docker build --build-arg tcpPort=8080 .</code></pre><blockquote><p>注意，<code>--build-arg</code>后面的<code>tcpPort=8080</code>，是将<code>tcpPort</code>参数的值设置为 8080。</p></blockquote><p>我们可以通过多个<code>ARG</code>命令定义多个参数，举个例子：</p><pre><code class="dockerfile">ARG tcpPortARG useTls</code></pre><p>当构建 Docker 镜像时，必须为所有构建参数提供值。【译者注，1.13 版本之前，不提供值会直接报错，1.13 版本之后，不提供值不会报错，但是会弹出警告】。举个例子：</p><pre><code class="dockerfile">docker build --build-arg tcpPort=8080 --build-arg useTls=true .</code></pre><p>我们可以为<code>ARG</code>设置默认值，当构建 Docker 镜像时，如果没有指定参数值，将使用默认值。举个例子：</p><pre><code class="dockerfile">ARG tcpPort=8080ARG useTls=true</code></pre><p>如果<code>tcpPort</code>和<code>useTls</code>在生成 Docker 镜像时，都没有设置参数，将使用默认值 8080 和 true。</p><p><code>ARG</code>声明的参数通常在 Dockerfile 的其他地方引用，比如：</p><pre><code class="dockerfile">ARG tcpPort=8080ARG useTls=trueCMD start-my-server.sh -port ${tcpPort} -tls ${useTls}</code></pre><blockquote><p>注意：两个引用<code>${tcpPort}</code>和<code>${useTls}</code>，引用名是<code>tcpPort</code>和<code>useTls</code>这两个<code>ARG</code>声明的参数。</p></blockquote><pre><code class="dockerfile">docker build --build-arg tcpPort=8080</code></pre><h2 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h2><p><code>WORKDIR</code>命令指明了 Docker 镜像中的工作目录，工作目录将对<code>WORKDIR</code>指令之后的所有命令生效，举个例子：</p><pre><code class="dockerfile">WORKDIR    /java/jdk/bin</code></pre><h2 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h2><p><code>EXPOSE</code>命令将对外开放 Docker 容器中的网络端口，比如，如果 Docker 容器运行一个 web 服务器，那么，该 web 服务器可能需要打开端口 80，以便客户端链接到它。举个例子：</p><pre><code class="dockerfile">EXPOSE   8080</code></pre><p>我们还可以指明打开端口的通信协议，比如：UDP 和 TCP。下面是设置允许通信协议的示例：</p><pre><code class="dockerfile">EXPOSE   8080/tcp 9999/udp</code></pre><p>如果没有指定协议，将默认认定为 TCP 协议。</p><h2 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h2><p><code>VOLUME</code>命令会在 Docker 镜像中创建一个目录，这个目录可以挂载到 Docker 主机上。换句话说，可以在 Docker 镜像中创建目录，比如<code>/data</code>，这个目录可以在稍后挂载到 Docker 主机的<code>/container-data/container1</code>目录上。挂载成功后，容器会启动。下面是一个使用<code>VOLUME</code>命令在 Dockerfile 中定义装载目录的示例：</p><pre><code class="dockerfile">VOLUME   /data</code></pre><h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p><code>ENTRYPOINT</code>命令为从该 Docker 镜像启动 Docker 容器提供入口点，入口点是 Docker 容器启动时执行的应用程序或命令。这样，<code>ENTRYPOINT</code>和<code>CMD</code>工作方式类似，不同之处在于，使用<code>ENTRYPOINT</code>时，当<code>ENTRYPOINT</code>执行的应用程序完成时，Docker 容器将关闭。因此，<code>ENTRYPOINT</code>使 Docker 镜像本身成为一个可执行命令，可以启动，完成后关闭。以下是<code>ENTRYPOINT</code>示例：</p><pre><code class="dockerfile">ENTRYPOINT java -cp /apps/myapp/myapp.jar com.jenkov.myapp.Main</code></pre><p>这个示例将在容器启动时执行 Java 应用程序的主类<code>com.jenkov.myapp.Main</code>，当应用程序关闭时，Docker 容器也会关闭。</p><h2 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h2><p><code>HEALTHCHECK</code>命令可以定期执行健康检查，以监视 Docker 容器中运行的应用程序的运行状况。如果命令返回 0，Docker 将认为应用程序和容器正常，如果命令返回 1，Docker 会认为应用程序和容器不正常。示例如下：</p><pre><code class="dockerfile">HEALTHCHECK java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><p>这个示例中使用了 java 应用程序的<code>com.jenkov.myapp.HealthCheck</code>作为健康检查的命令，我们可以使用任何有意义的健康检查命令。</p><h3 id="健康检查间隔时间"><a href="#健康检查间隔时间" class="headerlink" title="健康检查间隔时间"></a>健康检查间隔时间</h3><p>默认情况下，Docker 每 30 秒执行一次<code>HEALTHCHECK</code>命令。如果想修改时间间隔，我们可以自定义时间，通过<code>--interval</code>参数，可以指定健康检查的检查间隔时间。下面是一个将<code>HEALTHCHECK</code>间隔设置为 60 秒的示例：</p><pre><code class="dockerfile">HEALTHCHECK --interval=60s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h3 id="健康检查开始时间"><a href="#健康检查开始时间" class="headerlink" title="健康检查开始时间"></a>健康检查开始时间</h3><p>默认情况下，Docker 会立即检查 Docker 容器的监控状况。但是，有些应用程序可能需要一段时间启动，因此，只有经过某段时间后再进行健康检查才有意义。我们可以使用<code>--start-period</code>参数设置健康检查开始时间。下面是一个将健康检查设置为 5 分钟的示例，在 Docker 开始健康检查之前，为容器和应用程序提供 300 秒（5 分钟）的启动时间：</p><pre><code class="dockerfile">HEALTHCHECK --start-period=300s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h3 id="健康检查超时时间"><a href="#健康检查超时时间" class="headerlink" title="健康检查超时时间"></a>健康检查超时时间</h3><p>健康检查很有可能超时，如果<code>HEALTCHECK</code>命令需要超过给定时间限制才完成，Docker 将认为健康检查超时。可以使用<code>--timeout</code>参数设置超时时间，如下是设置超时时间为 5 秒的示例：</p><pre><code class="dockerfile">HEALTHCHECK --timeout=5s java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><blockquote><p>注意，如果健康检查超时，Docker 也会认为容器不健康。</p></blockquote><h3 id="健康检查重复次数"><a href="#健康检查重复次数" class="headerlink" title="健康检查重复次数"></a>健康检查重复次数</h3><p>如果<code>HEALTHCHECK</code>命令执行失败，有可能是结果返回 1，或者执行超时，Docker 会在认定容器不健康前，重试 3 次<code>HEALTHCHECK</code>命令，用于检查 Docker 容器是否返回健康状态。可以通过<code>--retries</code>设置重试次数。下面是将重试次数设置为 5 的示例：</p><pre><code class="dockerfile">HEALTHCHECK --retries=5 java -cp /apps/myapp/healthcheck.jar com.jenkov.myapp.HealthCheck https://localhost/healthcheck</code></pre><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/dockerfile.html" target="_blank" rel="noopener">Docker Dockerfile</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114808891" target="_blank" rel="noopener">Docker 教程（二）：Dockerfile</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Dockerfile 包含一组关于如何构建 Docker 镜像的说明，通过 docker build 命令执行 Dockerfile 文件，可以构建一个 Docker 镜像，本文介绍了如何编写 Dockerfile 文件以及构建一个 Docker 镜像。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
      <category term="Dockerfile" scheme="https://www.howardliu.cn/tags/Dockerfile/"/>
    
  </entry>
  
  <entry>
    <title>Docker 教程（一）：Docker 是什么</title>
    <link href="https://www.howardliu.cn/docker-tutorial/"/>
    <id>https://www.howardliu.cn/docker-tutorial/</id>
    <published>2021-03-07T09:42:18.000Z</published>
    <updated>2021-03-07T09:42:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/docker/dandelion-5975473_1920.jpg" alt="Docker 教程"></p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">《Docker 教程》</a> 中的第一篇，本文大概介绍了 Docker 是什么和有什么用。可能在工作中，会有专业运维同学管理服务器镜像或其他内容，但是如果不了解这些概念，很多时候我们不会全面了解到系统的全貌。</p></blockquote><a id="more"></a><p>Docker 是一种将应用程序和服务器配置打包成 Docker 镜像的方法，使用了一种称为 Dockerfile 的简单打包规范。Docker 镜像可以启动多个多个实例，这些运行的实例被称为 Docker 容器。这个系列的内容主要包括讲解什么是 Docker 镜像、什么是容器、什么是 Dockerfile，以及如何创建、运行和发布等。</p><h2 id="Docker-的优势"><a href="#Docker-的优势" class="headerlink" title="Docker 的优势"></a>Docker 的优势</h2><p>使用 Dockerfile 打包应用和服务器配置最大的好处是：</p><ul><li>不会忘记服务器是如何配置的，这些配置信息都记录在 Dockerfile 中。</li><li>很容易在一个全新啊的 Docker 主机上运行应用程序，只需要将应用程序的 Docker 镜像部署到这台 Docker 主机上，然后启动它即可。</li><li>可以使用 Kubernetes 和 Swarm 轻松管理集群中的 Docker 容器。</li><li>目前许多云服务器平台可以很轻松的部署 Docker 容器，Docker 已经成为让云更加独立的部署方案。</li><li>Docker 容器可以很简单的实现在客户自己的服务器上按照你的应用程序。</li></ul><h2 id="什么是-Docker-容器"><a href="#什么是-Docker-容器" class="headerlink" title="什么是 Docker 容器"></a>什么是 Docker 容器</h2><p>Linux 操作系统有几个特性：运行在操作系统上运行容器化的应用程序，这些容器化的特性，运行将文件系统和网络在各个容器化应用程序之间彼此分离。换句话说，一个容器化应用程序，不能访问另一个容器化应用程序的文件系统或网络，除非增加特殊配置，允许这种操作。Docker 使用 Linux 的容器化特性，并通过一组易于使用的工具公开这些特性。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-1.png" alt="什么是 Docker 容器"></p><h2 id="Docker-容器-vs-虚拟机"><a href="#Docker-容器-vs-虚拟机" class="headerlink" title="Docker 容器 vs. 虚拟机"></a>Docker 容器 vs. 虚拟机</h2><p>Docker 容器在本质上类似于虚拟机，两者的不同之处在于，虚拟机在总栈上有一个额外的操作系统。也就是说，虚拟机有完整的操作系统，然后这个虚拟机运行在一个有操作系统的主机上。</p><p>Docker 容器与虚拟机的实现不同，它没有自己单独的操作系统，直接运行在所在主机的操作系统中。所以，Docker 容器足够小，因为它不包含虚拟机操作系统。Docker 容器运行的也很好，因为它不需要虚拟机的虚拟化。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-2.png" alt="Docker 容器 vs. 虚拟机"></p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>如前所述，我们可以通过一个按规则定义的 Dockerfile 文件，指定要包含在 Docker 容器中的内容。Dockerfile 文件包含了一组有 Docker 命令行工具执行的 Docker 指令，按照 Dockerfile 执行的结果是 Docker 镜像。我们可以从 <a href="http://tutorials.jenkov.com/docker/dockerfile.html" target="_blank" rel="noopener">Dockerfile 教程</a> 中得到更详细的解释。【译者注：后续翻译完成后，将替换此处链接。】</p><h2 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h2><p>Docker 命令行工具按照 Dockerfile 中定义的结构执行指令时，会生产一个可移植、可运行的 Docker 镜像。这个 Docker 镜像中包含了所有 Docker 容器需要的文件和指令，同一个 Docker 镜像可以启动多个 Docker 容器。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-3.png" alt="Docker 镜像"></p><h2 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h2><p>Docker 镜像可以存储在 Docker 仓库中，一个可以将 Docker 镜像上传、下载的存储仓库。Docker 仓库可以是私有的，只能你或者你的组织或者你指定的人管理其中的镜像，也可以是公有的，任何人都可以管理其中的镜像，或者是从中下载 Docker 镜像。</p><p>一个公有的 Docker 仓库，是运行潜在用户下载、安装和运行软件的很好的方式，只需要将应用程序打包为 Docker 镜像，上传到公有的 Docker 仓库中，你的用户就可以访问并使用它。</p><p>Docker 公司已将 Docker 仓库作为一项托管服务，提供了私有和公有两种服务。一些云服务商，比如 AWS、AZure 和 Google，也提供了 Docker 仓库服务器，可以上传自己的 Docker 镜像。很容易的就能在云基础设施上的虚拟机或 Kubernetes 中使用这些镜像。</p><p><img src="http://static.howardliu.cn/docker/docker-introduction-4.png" alt="Docker 仓库"></p><h2 id="Docker-命令行工具"><a href="#Docker-命令行工具" class="headerlink" title="Docker 命令行工具"></a>Docker 命令行工具</h2><p>当在操作系统中安装 Docker 的时候，会同时安装 Docker 命令行工具。Docker 命令行工具可以通过 Dockerfile 构建 Docker 镜像，可以将 Docker 镜像上传到 Docker 仓库中，可以从 Docker 仓库中下载 Docker 镜像，可以操作 Docker 镜像启动或停止 Docker 容器。</p><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose 提供一种功能，可以将多个 Docker 容器链接成一个组合中，这个组合中的所有容器，可以一次性全部部署或停止。比如，一个 Docker 容器中运行应用，一个 Docker 容器中运行数据库，应用依赖于数据库，同时启动或停止，可以实现应用依赖的数据库没有正常运行。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a></li><li><a href="https://www.howardliu.cn/docker-dockerfile/">Docker 教程（二）：Dockerfile</a></li><li><a href="https://www.howardliu.cn/docker-commands/">Docker 教程（三）：Docker 命令</a></li></ul><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/docker/index.html" target="_blank" rel="noopener">Docker Tutorial</a><br>翻译：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接：<a href="https://www.howardliu.cn/docker-tutorial/">Docker 教程（一）：Docker 是什么</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114497477" target="_blank" rel="noopener">Docker 教程（一）：Docker 是什么</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Docker 是一种将应用程序和服务器配置打包成 Docker 镜像的方法，使用了一种称为 Dockerfile 的简单打包规范。Docker 镜像可以启动多个多个实例，这些运行的实例被称为 Docker 容器。这个系列的内容主要包括讲解什么是 Docker 镜像、什么是容器、什么是 Dockerfile，以及如何创建、运行和发布等。
    
    </summary>
    
    
      <category term="docker" scheme="https://www.howardliu.cn/categories/docker/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Docker" scheme="https://www.howardliu.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Java 中 Vector 和 SynchronizedList 的区别</title>
    <link href="https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/"/>
    <id>https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/</id>
    <published>2021-02-27T13:50:05.000Z</published>
    <updated>2021-02-27T13:50:05.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/bird-6024257_1920.jpg" alt="Java 中 Vector 和 SynchronizedList 的区别"></p><p>你好，我是看山。</p><p>本文还是折腾 Java 中的队列，上次比较了 <a href="https://www.howardliu.cn/understanding-java-list/">Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a>，当时感觉挺明白，后来想想又有些不理解的地方，所以今天在重新翻出来研究一下，我承认我钻了牛角尖了。</p><a id="more"></a><p><code>Vector</code>虽然种种问题，但是都属于设计上的问题，为什么不在后续版本中进行优化呢？<code>HashMap</code>就优化了好几次。而<code>SynchronizedList</code>这个内部类（也就是通过<code>Collections.synchronizedList(new ArrayList())</code>创建的），也是采用了和<code>Vector</code>类似的同步方式（区别是一个在方法体、一个在方法块上，差别不大），为什么大家还是舍弃<code>Vector</code>呢？</p><p>其实，在 JDK 中，<code>Vector</code>一直没有被标记为<code>Deprecated</code>，也就是说，虽然外界传说<code>Vector</code>有各种问题，但是从 JDK 官方，从没有认为这个亲儿子没用。</p><p>所以，大家不用<code>Vector</code>的原因就剩下两种：</p><ol><li>其他队列比<code>Vector</code>更加适合，优中选优</li><li>大家都说<code>Vector</code>不好用，那我也不用了【个人感觉这种概率更大】</li></ol><blockquote><p>因为<code>Vector</code>主要是数组结构，所以下面大部分的对比都是比较的是针对<code>ArrayList</code>的同步封装。</p></blockquote><h2 id="有了Vector为什么还要有SynchronizedList"><a href="#有了Vector为什么还要有SynchronizedList" class="headerlink" title="有了Vector为什么还要有SynchronizedList"></a>有了<code>Vector</code>为什么还要有<code>SynchronizedList</code></h2><p>这个问题的答案是从 StackOverflow 中找到的。</p><p>在 JDK 1.2 之前，<code>Collections</code>是独立类库，不是 JDK/JRE 中的一部分。当时<code>synchronized</code>性能特别差，很多场景不需要使用同步方式，所以，独立类库的开发者删除了同步操作，这个应该就是<code>ArrayList</code>的前身。但是，少部分场景还是需要使用同步，于是就有了<code>SynchronizedList</code>，一个可以包装所有<code>List</code>子类的包装类，这个类在几乎所有方法上都加上了<code>synchronized</code>同步，这个设计与<code>Vector</code>相似。</p><p>古人说“文人相轻”，其实在编码界也是有鄙视链的。在这里就是：虽然我的设计和你的设计类似，但是我的设计就是比你的好。不过，<code>Collections</code>确实设计更优。</p><h2 id="一个SynchronizedList实现所有List的同步"><a href="#一个SynchronizedList实现所有List的同步" class="headerlink" title="一个SynchronizedList实现所有List的同步"></a>一个<code>SynchronizedList</code>实现所有<code>List</code>的同步</h2><p><code>SynchronizedList</code>定位是包装类，可以包装所有<code>List</code>的子类。也就是说，无论是<code>ArrayList</code>还是<code>LinkedList</code>都能过实现同步，完全不会修改底层数据结构，既实现的同步，又保留了底层接口的优点。比如<code>LinkedList</code>的插入、删除效率，<code>ArrayList</code>的顺序读取。而且，一个包装类就解决所有<code>List</code>子类的同步需求，完全不需要重复实现一遍。</p><p>相对而言，<code>Vector</code>就比较霸道了，任何想要同步的队列，都需要转换为<code>Vector</code>的数组结构。大家都知道，数组存储需要连续空间，顺序读取效率表现优秀，但是插入和删除效率就比较差了。</p><h2 id="将迭代器的同步权利交给用户"><a href="#将迭代器的同步权利交给用户" class="headerlink" title="将迭代器的同步权利交给用户"></a>将迭代器的同步权利交给用户</h2><p>同步方法中<code>SynchronizedList</code>和<code>Vector</code>很类似，不过迭代器方法有了不同想法。</p><p>看源码就知道，<code>SynchronizedList</code>中的<code>iterator</code>和<code>listIterator</code>方法都没有实现同步，所以在获取迭代器的时候不会阻塞。</p><pre><code class="java">public Iterator&lt;E&gt; iterator() {    return list.iterator(); // Must be manually synched by user!}public ListIterator&lt;E&gt; listIterator() {    return list.listIterator(); // Must be manually synched by user}public ListIterator&lt;E&gt; listIterator(int index) {    return list.listIterator(index); // Must be manually synched by user}</code></pre><p>如果需要迭代的话，直接用<code>synchronized</code>包一下队列对象就可以了，代码如下：</p><pre><code class="java">final List&lt;String&gt; list = Collections.synchronizedList(new ArrayList());list.add(&quot;A&quot;);list.add(&quot;B&quot;);list.add(&quot;C&quot;);final Iterator&lt;String&gt; iterator = list.iterator();synchronized (list) {    while (iterator.hasNext()) {        final String next = iterator.next();        System.out.println(next);    }}</code></pre><p>我们再看下<code>Vector</code>迭代器实现：</p><pre><code class="java">/**    * An optimized version of AbstractList.Itr    */private class Itr implements Iterator&lt;E&gt; {    int cursor;       // index of next element to return    int lastRet = -1; // index of last element returned; -1 if no such    int expectedModCount = modCount;    public boolean hasNext() {        // Racy but within spec, since modifications are checked        // within or after synchronization in next/previous        return cursor != elementCount;    }    public E next() {        synchronized (Vector.this) {            checkForComodification();            int i = cursor;            if (i &gt;= elementCount)                throw new NoSuchElementException();            cursor = i + 1;            return elementData(lastRet = i);        }    }    public void remove() {        if (lastRet == -1)            throw new IllegalStateException();        synchronized (Vector.this) {            checkForComodification();            Vector.this.remove(lastRet);            expectedModCount = modCount;        }        cursor = lastRet;        lastRet = -1;    }    // 此处省略一些方法}</code></pre><p><code>Vector</code>的迭代器用<code>synchronized (Vector.this)</code>加锁，其实也是对当前类实例加锁，和我们自己实现的加锁方式一致。当然，从这点上来说，<code>Vector</code>能够保证在开发人员无意识的情况下，避免为同步造成的错误，这也是<code>Vector</code>的一个优点。</p><h2 id="Vector不完全一无是处"><a href="#Vector不完全一无是处" class="headerlink" title="Vector不完全一无是处"></a><code>Vector</code>不完全一无是处</h2><p>虽然<code>Vector</code>在其他地方败给了<code>Collections</code>，但是在扩容这方面，还有一个可取之处。先看看<code>Vector</code>的扩容方法：</p><pre><code class="java">private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ?                                        capacityIncrement : oldCapacity);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><p>在计算新数组长度的时候，会检查<code>capacityIncrement</code>是否大于 0，如果是，就扩容<code>capacityIncrement</code>的大小。就是说，在<code>Vector</code>中可以指定扩容大小，如果没有指定，默认扩容到原来的 2 倍；而<code>ArrayList</code>只能扩容到 1.5 倍，没有办法自定义扩容大小。</p><blockquote><p>仔细想想，这点并没有什么用处。</p></blockquote><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li><code>Vector</code>内部结构是数组，与<code>Collections.synchronizedList(new ArrayList())</code>类似。</li><li><code>Vector</code>可以指定扩容大小，默认是扩容到原数组长度的 2 倍；<code>ArrayList</code>不能指定扩容大小，直接扩容到原数组大小的 1.5 倍。</li><li><code>SynchronizedList</code>是一个包装类，可以将<code>List</code>子类都包装为同步队列，从非线程安全队列转为线程安全队列，没有性能延迟，直接包装即可；<code>Vector</code>是一个基于数组的同步队列，其他队列想要转换为<code>Vector</code>，需要有数据拷贝。</li><li><code>SynchronizedList</code>的迭代器没有做同步，需要用户自己实现；<code>Vector</code>的迭代器做好了同步，开发人员不需要关心同步。</li><li><code>Vector</code>至今未标记<code>Deprecated</code>，而且随着 JDK 发布，也在更新实现。虽然 JDK 承诺兼容，但是一直没有标记过期，其用意不得而知。</li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/understanding-java-list/">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a></li><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li><li><a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated" target="_blank" rel="noopener">Why is Java Vector (and Stack) class considered obsolete or deprecated?</a></li><li><a href="https://stackoverflow.com/questions/14932034/in-java-vector-and-collections-synchronizedlist-are-all-synchronized-whats-th" target="_blank" rel="noopener">In java, Vector and Collections.synchronizedList are all synchronized, what’s the difference?</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/java-vector-vs-collections-synchronizedlist-arraylist/">Java 中 Vector 和 Collections.synchronizedList(new ArrayList()) 的区别</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/114238758" target="_blank" rel="noopener">Java 中 Vector 和 Collections.synchronizedList(new ArrayList()) 的区别</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      Java 中 Vector 和 SynchronizedList 的区别
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件架构-事件驱动架构</title>
    <link href="https://www.howardliu.cn/event-driven-architecture/"/>
    <id>https://www.howardliu.cn/event-driven-architecture/</id>
    <published>2021-02-20T13:21:45.000Z</published>
    <updated>2021-02-20T13:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/software-architecture/jellyfish-2427426_1920.jpg" alt="软件架构-事件驱动架构"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/software-architecture/index.html" target="_blank" rel="noopener">《软件架构》</a> 中关于事件驱动的内容，虽然是 2014 年的文章，但是从软件架构层面上，并不过时。</p></blockquote><p>以下是正文。</p><p>事件驱动架构是一种系统或组件之间通过发送事件和响应事件彼此交互的架构风格。当某个事件发生时，组件A不直接调用组件B，而只是发出一个事件。组件A不知道哪些组件监听并处理这些事件。事件驱动架构可以在进程内和进程间使用。比如，GUI框架中会大量使用事件驱动。【译者注：目前很多系统采用微服务架构，事件驱动使用的更加广泛了。】此外，正如我在<a href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html" target="_blank" rel="noopener">并发模型教程</a> 中所提到的，装配线并发模型（AKA reactive，非阻塞并发模型）也使用了事件驱动架构。</p><p>本文主要介绍进程之间的事件驱动架构，后文提到这个词的时候也是指进程交互方式。</p><a id="more"></a><h2 id="进程间的事件驱动架构"><a href="#进程间的事件驱动架构" class="headerlink" title="进程间的事件驱动架构"></a>进程间的事件驱动架构</h2><p>事件驱动架构是一种架构风格，先将请求事件集中存放在一个或多个事件队列中，然后事件从这些事件队列转发到后端服务，处理这些事件。</p><p>因为事件可以被看做是消息流，所以事件驱动架构也被称为消息驱动架构或者流处理架构。流处理架构又可以被称为lambda架构。为了保证统一，后文会继续使用事件驱动这个名词。</p><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>在事件驱动架构中，你会有一个或多个集中的事件队列，所有的事件被处理前，会先保存在集中的事件队列中。下面给出一个简单示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-1.png" alt="event-driven-architecture"></p><p>事件插入队列时是有序的，这样就可以顺序处理这些事件。</p><h2 id="事件日志"><a href="#事件日志" class="headerlink" title="事件日志"></a>事件日志</h2><p>写入事件队列时，消息可能写入到事件日志（通常是磁盘存储）中。如果发生系统崩溃，系统只需要重放事件日志即可恢复到崩溃前的状态。下面是一个事件驱动架构的示例，其中包括一个用于持久化事件的事件日志：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-2.png" alt="event-driven-architecture"></p><p>我们还可以通过备份事件日志，来备份系统状态。在将新版本的系统部署在生产环境之前，可以使用这个备份数据对其性能进行测试。或者，通过重放事件日志的备份，来重现某些错误。</p><h2 id="事件收集器"><a href="#事件收集器" class="headerlink" title="事件收集器"></a>事件收集器</h2><p>请求都是通过网络传输，比如HTTP或者其他协议。为了保持一致，可以通过事件采集器接收来自不同来源的事件。下面是一个添加了事件收集器的事件驱动架构示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-3.png" alt="event-driven-architecture"></p><h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>有时，我们还需要向请求（即事件）返回响应，所以，很多事件驱动架构除了包含事件队列，还会有一个响应队列。下面是包含事件队列（入队队列）和响应队列（出队队列）的事件驱动架构示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-4.png" alt="event-driven-architecture"></p><p>如你所见，响应队列必须路由到正确的事件收集器。比如，如果HTTP收集器（本质上是web服务器）通过HTTP接收的请求发送到事件队列中，则该事件生成的响应可能也需要通过HTTP收集器发回客户端。</p><p>通常，响应队列不会持久化，也就意味着它不会写入事件日志，只有输入的事件才会持久化到事件日志中。</p><h2 id="读事件-vs-写事件"><a href="#读事件-vs-写事件" class="headerlink" title="读事件 vs. 写事件"></a>读事件 vs. 写事件</h2><p>如果将所有传入的请求都认为是事件，就需要将这些事件都推送到事件队列中。如果事件队列是实现了持久化（持久化到事件日志中），就意味着所有事件都需要持久化。通常持久化都比较慢，如果我们能够过滤掉一些不需要持久化的事件，我们就能够提升队列的性能。</p><p>我们将事件持久化到事件日志的原因是，我们可以重放事件日志，并重建因为事件引起的系统状态变化。为了支持这个特性，实际上只需要持久化更改系统状态的事件。换句话说，我们只需要将事件分为读事件和写事件。读事件只读取系统数据，不会更改，写事件会更改系统数据。</p><p>通过根据读和写划分事件，我们只需要持久化写事件的消息即可。这将提升事件队列的性能，提升比例大小，取决于读写事件之间的比例。</p><p>为了将事件划分为读写事件，需要在事件到达事件队列之前，也就是事件收集器中进行区分。否则，事件队列无法知道到达的事件是否需要持久化。</p><p>还可以将事件队列拆分为两个，一个用于存储读事件的事件队列，一个用于存储写事件的事件队列。这样读事件就不会慢于写事件，事件队列也不需要检查每条事件是否需要持久化。读事件队列不需要进行持久化，写事件队列始终持久化事件。</p><p>下面是一个事件驱动架构的示例，其中事件队列分为读和写事件队列：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-5.png" alt="event-driven-architecture"></p><p>上图示例中箭头比较乱，但实际上创建3个丢列并在它们之间分发消息简单很多。</p><h2 id="事件日志重放的挑战"><a href="#事件日志重放的挑战" class="headerlink" title="事件日志重放的挑战"></a>事件日志重放的挑战</h2><p>事件驱动架构的一大优点是，在系统崩溃或系统重启情况下，只需要重放事件日志，就能够重建系统状态。在日志可以独立于时间和周边系统的情况下重放日志，这是一个很大的优势。</p><p>但是，完全独立于时间重放事件日志有时候很难实现。接下来介绍下事件日志重放的一些挑战。</p><h3 id="处理动态数据"><a href="#处理动态数据" class="headerlink" title="处理动态数据"></a>处理动态数据</h3><p>如前所述，写事件处理时可能会修改系统数据。有些情况，这种数据的修改受事件处理时动态数据的影响。比如，处理事件的日期和时间或者特定日期和时间的货币汇率。</p><p>这些动态数据会对事件重放造成困难。如果在不同的时间重放事件日志，处理该事件的服务可能会解析不同的动态值，比如其他的日期和时间或其他汇率。因此，在不同的日期重放事件日志，可能会出现重建系统数据与最初处理事件产生的数据不一致。</p><p>要解决动态数据的问题，可以让写事件队列将所需的动态数据标记在事件中。但是，要实现这种方案，需要事件队列知道每条事件消息需要哪些动态数据。这样会使事件队列的设计复杂化，每次需要新的动态数据时，事件队列都需要知道如何查找这些动态数据。</p><p>另外一种解决方案是，写事件队列只在写事件上标记事件的日期和时间。使用事件的原始日期和时间，处理事件的服务可以查找给定日期和时间对应的动态数据。比如，可以通过原始的日期和时间，查询当时有效的汇率。这就要求处理事件的服务需要基于日期和时间查询动态数据，但是这只是理想状态。</p><h3 id="与外部系统的交互"><a href="#与外部系统的交互" class="headerlink" title="与外部系统的交互"></a>与外部系统的交互</h3><p>事件日志重放的另一个挑战是与外部系统的协调。比如，事件日志中包含电商平台的订单，在第一次处理这个事件时，需要将订单发送到外部支付网关，以从客户信用卡中收费。</p><p>如果重放事件日志，就不希望再次为同一个订单向客户收费。因此，就不希望在事件重放时，将订单发送到外部支付网关。</p><h2 id="事件日志重放解决方案"><a href="#事件日志重放解决方案" class="headerlink" title="事件日志重放解决方案"></a>事件日志重放解决方案</h2><p>解决重放事件日志问题挺不容易的。有些系统没有问题，可以直接重放事件日志；有些系统可能需要知道原始事件的日期和时间；有些系统可能需要知道更多类似于事件原始处理过程中从外部系统获取的原始数据。</p><h3 id="重放模式"><a href="#重放模式" class="headerlink" title="重放模式"></a>重放模式</h3><p>在任何情况下，倾听写事件队列中事件的任何服务都必须知道传入事件是原始事件还是重放事件。这样，处理服务就能够确定如何处理动态数据或者如何与外部系统交互了。</p><h3 id="多步骤事件队列"><a href="#多步骤事件队列" class="headerlink" title="多步骤事件队列"></a>多步骤事件队列</h3><p>另外一个解决方案是采用多步骤事件队列。第一步，收集所有写事件；第二步，解析动态数据；第三步，与外部系统交互。如果需要重放事件日志，只需要跳过第一步和第二步，重放第三步即可。具体如何实现，需要取决于具体的系统设计。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html" target="_blank" rel="noopener">Event-driven Architecture</a><br>翻译: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接: <a href="https://www.howardliu.cn/event-driven-architecture/">软件架构-事件驱动架构</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113923639" target="_blank" rel="noopener">软件架构-事件驱动架构</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      事件驱动架构是一种系统或组件之间通过发送事件和响应事件彼此交互的架构风格。
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="事件驱动" scheme="https://www.howardliu.cn/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</title>
    <link href="https://www.howardliu.cn/understanding-java-list/"/>
    <id>https://www.howardliu.cn/understanding-java-list/</id>
    <published>2021-02-09T06:18:59.000Z</published>
    <updated>2021-02-09T06:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/sunset-5299957_1920.jpg" alt="认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList"></p><p>你好，我是看山。</p><p>书接上文，上次聊了聊 <a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">在多线程中使用 ArrayList 会发生什么</a>，这次我们说说平时常用的列表：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList。</p><a id="more"></a><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><code>Vector</code>是在 JDK 1.0 提供的，虽然没有被标记<code>Deprecated</code>，但是事实上已经没人使用了。主要原因是性能差，且不符合需求。</p><p>从源码可以看出（这里不贴源码了），<code>Vector</code>是基于数组实现，几乎在所有操作方法上，都用<code>synchronized</code>关键字实现方法同步，这种同步方式可以对单一操作进行加锁，比如多个线程同时执行<code>add</code>会同步阻塞执行，但是多线程执行<code>add</code>和<code>remove</code>时，就不会阻塞了。</p><p>但是，大部分需要对队列加锁的场景，是想对整个队列加锁，而不仅仅是对单一操作加锁。也就是说，<code>Vector</code>和我们的期望不同，但是又额外增加了同步操作带来的性能开销。所以，不是必须使用的场景，都可以使用<code>ArrayList</code>代替，即使是多线程情况下需要同步队列，也可以使用<code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>代替。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><code>ArrayList</code>是在 JDK 1.1 提供的，作为<code>Vector</code>的继任者（<code>ArrayList</code>实现方式与<code>Vector</code>几乎完全相同），<code>ArrayList</code>把方法上的<code>synchronized</code>全部去掉了，完全没有实现同步，是非线程安全的。</p><p>它的非线程安全，还体现在迭代器的快速失败上。在使用方法<code>iterator</code>和<code>listIterator</code>创建迭代器之后，如果还对原来的<code>ArrayList</code>队列进行修改（add 或 remove），迭代器迭代的时候就会报<code>ConcurrentModificationException</code>异常。从源码可以看出，迭代器在迭代过程中，会检查队列中修改次数<code>modCount</code>与创建迭代器时落下的修改次数快照<code>expectedModCount</code>是否相等，相等表示没有修改过，代码如下：</p><pre><code class="java">private class Itr implements Iterator&lt;E&gt; {    // 这段代码是从 ArrayList 中摘取的    // 只留下检查方法，略过其他代码，有兴趣的可以从源码中查看    final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    }}</code></pre><p>第三点是在多线程场景中，添加元素可能会丢失数据，或者发生数组越界异常，<a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">在多线程中使用 ArrayList 会发生什么</a> 有详细描述，这里就不赘述了。</p><h2 id="SynchronizedList"><a href="#SynchronizedList" class="headerlink" title="SynchronizedList"></a>SynchronizedList</h2><p><code>SynchronizedList</code>是<code>Collections</code>的静态内部类，使用<code>Collections.synchronizedList()</code>静态方法创建，是一个通过组合<code>List</code>类实现的封装实现。它的大多数方法通过<code>synchronized (mutex){...}</code>代码块同步方式，因为加锁对象<code>mutex</code>是队列对象中定义的相同对象，所以对<code>mutex</code>加锁时，可以在多线程之间实现阻塞。但是这种实现方式和<code>Vector</code>在方法上加锁没有本质的区别，所以<code>Vector</code>存在的困境，<code>SynchronizedList</code>依然存在。</p><p><code>ArrayList</code>中存在的迭代器快速失败情况，依然存在，正如下面源码中的注释：想要使用迭代器，需要用户手动实现同步。</p><pre><code class="java">static class SynchronizedList&lt;E&gt;    extends SynchronizedCollection&lt;E&gt;    implements List&lt;E&gt; {    // 代码摘自 Collections，省略很多代码    public void add(int index, E element) {        synchronized (mutex) {list.add(index, element);}    }    public ListIterator&lt;E&gt; listIterator() {        return list.listIterator(); // Must be manually synched by user    }    public ListIterator&lt;E&gt; listIterator(int index) {        return list.listIterator(index); // Must be manually synched by user    }}</code></pre><p>手动同步的时候需要注意，既然我们关注的全局同步，在迭代器设置同步的时候，要保证锁定对象与<code>add</code>等方法中对象相同。这个在后续补充说明，这里就不展开了。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>CopyOnWriteArrayList</code>是从 JDK 1.5 开始提供的，先看看<code>add</code>方法的源码：</p><pre><code class="java">public class CopyOnWriteArrayList&lt;E&gt;    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    /** The lock protecting all mutators */    final transient ReentrantLock lock = new ReentrantLock();    /** The array, accessed only via getArray/setArray. */    private transient volatile Object[] array;    // 代码摘自 CopyOnWriteArrayList，省略很多代码    public boolean add(E e) {        final ReentrantLock lock = this.lock;        lock.lock();        try {            Object[] elements = getArray();            int len = elements.length;            Object[] newElements = Arrays.copyOf(elements, len + 1);            newElements[len] = e;            setArray(newElements);            return true;        } finally {            lock.unlock();        }    }    public boolean addAll(Collection&lt;? extends E&gt; c) {        Object[] cs = (c.getClass() == CopyOnWriteArrayList.class) ?            ((CopyOnWriteArrayList&lt;?&gt;)c).getArray() : c.toArray();        if (cs.length == 0)            return false;        final ReentrantLock lock = this.lock;        lock.lock();        try {            Object[] elements = getArray();            int len = elements.length;            if (len == 0 &amp;&amp; cs.getClass() == Object[].class)                setArray(cs);            else {                Object[] newElements = Arrays.copyOf(elements, len + cs.length);                System.arraycopy(cs, 0, newElements, len, cs.length);                setArray(newElements);            }            return true;        } finally {            lock.unlock();        }    }    private E get(Object[] a, int index) {        return (E) a[index];    }    /**     * {@inheritDoc}     *     * @throws IndexOutOfBoundsException {@inheritDoc}     */    public E get(int index) {        return get(getArray(), index);    }}</code></pre><p>可以看到，<code>CopyOnWriteArrayList</code>借助<code>ReentrantLock</code>实现同步，在<code>synchronized</code>优化之前，<code>ReentrantLock</code>性能高于<code>synchronized</code>。<code>CopyOnWriteArrayList</code>也是通过数组实现的，但是在数组前面增加了<code>volatile</code>关键字，实现了多线程情况下数组的可见性，更加安全。更重要的一点是，<code>CopyOnWriteArrayList</code>在<code>add</code>添加元素的时候，实现方式是重建数组对象，替换原来的数组引用。与<code>ArrayList</code>的扩容方式相比，减少了空间，但是也增加了赋值数组的性能开销。在<code>get</code>获取元素的时候，没有任何锁，直接数据返回。</p><p><code>CopyOnWriteArrayList</code>的迭代器时通过<code>COWIterator</code>实现的，调用<code>iterator</code>方法时，将当前队列中数组的快照赋值到迭代器中的数组引用上。如果原来的队列发生修改，队列中数组会指向别的引用，而迭代器中的数组不会发生变化，所以在多线程执行过程中，通过迭代器遍历数组，也可以修改队列中的数据。这种方式保障线程安全的同时，也可能会出现数据不一致的情况，只能是使用的使用多注意了。</p><pre><code class="java">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {    /** Snapshot of the array */    private final Object[] snapshot;    /** Index of element to be returned by subsequent call to next.  */    private int cursor;    private COWIterator(Object[] elements, int initialCursor) {        cursor = initialCursor;        snapshot = elements;    }}</code></pre><h2 id="对比-CopyOnWriteArrayList-和-SynchronizedList"><a href="#对比-CopyOnWriteArrayList-和-SynchronizedList" class="headerlink" title="对比 CopyOnWriteArrayList 和 SynchronizedList"></a>对比 CopyOnWriteArrayList 和 SynchronizedList</h2><p><code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>都实现了同步，实现方式上采用的是不同策略，各自的侧重点不同。</p><p><code>CopyOnWriteArrayList</code>侧重于读写分离，发生数据写操作（<code>add</code>或<code>remove</code>）时，会加锁，各个线程阻塞执行，执行过程会创建数据副本，替换对象引用；如果同时有读操作（<code>get</code>或<code>iterator</code>），读操作读取的是老数据，或者成为历史数据快照，或者成为缓存数据。这会造成读写同时发生时，数据不一致的情况，但是数据最终会一致。这种方式与数据库读写分离模式几乎相同，很多特性可以类比。</p><p><code>SynchronizedList</code>侧重数据强一致，也就是说当发生数据写操作（<code>add</code>或<code>remove</code>）时，会加锁，各个线程阻塞执行，而且也会通过相同的锁阻塞<code>get</code>操作。</p><p>从<code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>两种不同事项方式，可以推断<code>CopyOnWriteArrayList</code>在写少读多的场景中执行效率高，<code>SynchronizedList</code>的读写操作效率很均衡，所以在写多读多、写多读少的场景执行效率都会高于<code>CopyOnWriteArrayList</code>。借用网上的测试结果：</p><p><img src="http://static.howardliu.cn/java/CopyOnWriteArrayList-SynchronizedList-Vector.jpg" alt="对比 CopyOnWriteArrayList 和 SynchronizedList"></p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li><code>synchronized</code>关键字在 JDK 8 之前性能比较差，可以看到 JDK1.5 之后实现的同步代码，很多是通过<code>ReentrantLock</code>实现的。</li><li>多线程场景中除了需要考虑同步外，还需要考虑数据可见性，可以通过<code>volatile</code>关键字实现。</li><li><code>ArrayList</code>完全没有同步操作，是非线程安全的</li><li><code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>属于线程安全队列</li><li><code>CopyOnWriteArrayList</code>实现读写分离，适合场景是写少读多的场景</li><li><code>SynchronizedList</code>要求数据强一致，是队列全局加锁方式，读操作也会加锁</li><li><code>Vector</code>只是在迭代器遍历性能很差，如果不考虑全局锁定队列，单纯读操作和单独写操作性能与<code>SynchronizedList</code>相差不大。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated" target="_blank" rel="noopener">Why is Java Vector (and Stack) class considered obsolete or deprecated?</a></li><li><a href="https://blog.csdn.net/yangzl2008/article/details/39456817" target="_blank" rel="noopener">CopyOnWriteArrayList 与 Collections.synchronizedList 的性能对比</a></li><li><a href="https://juejin.cn/post/6844904054745743367" target="_blank" rel="noopener">Collections.synchronizedList 、CopyOnWriteArrayList、Vector 介绍、源码浅析与性能对比</a></li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/understanding-java-list/">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/113780875" target="_blank" rel="noopener">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      书接上文，上次聊了聊在多线程中使用 ArrayList 会发生什么，这次我们说说平时常用的列表：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="队列" scheme="https://www.howardliu.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如果非要在多线程中使用ArrayList会发生什么？</title>
    <link href="https://www.howardliu.cn/arraylist-is-not-thread-safe/"/>
    <id>https://www.howardliu.cn/arraylist-is-not-thread-safe/</id>
    <published>2021-02-04T13:08:09.000Z</published>
    <updated>2021-02-04T13:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/road-5837403_1920.jpg" alt="如果非要在多线程中使用ArrayList会发生什么？"></p><p>你好，我是看山。</p><p>我们都知道，Java中的ArrayList是非线程安全的，这个知识点太熟了，甚至面试的时候都很少问了。</p><p>但是我们真的清楚原理吗？或者知道多线程情况下使用ArrayList会发生什么？</p><p>前段时间，我们就踩坑了，而且直接踩了两个坑，今天就来扒一扒。</p><a id="more"></a><h2 id="翠花，上源码"><a href="#翠花，上源码" class="headerlink" title="翠花，上源码"></a>翠花，上源码</h2><p>上代码之前先说下<code>ArrayList</code>的<code>add</code>逻辑：</p><ol><li>检查队列中数组是否还没有添加过元素</li><li>如果是，设置当前需要长度为10，如果否，设置当前需要长度为当前队列长度+1</li><li>判断需要长度是否大于数组大小</li><li>如果是，需要扩容，将数组长度扩容1.5倍（第一次扩容会从0直接到10，后续会按照1.5倍的步幅增长）</li><li>数组中添加元素，队列长度+1</li></ol><p>附上代码，有兴趣的可以在看看源码。</p><pre><code class="java">/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add}) */public boolean add(E e) {    // 判断数组容量是否足够，如果不足，增加1.5倍，size是当前队列长度    ensureCapacityInternal(size + 1);  // Increments modCount!!    // 给下标为size的赋值，同时队列长度+1，下标从0开始    elementData[size++] = e;    return true;}private void ensureCapacityInternal(int minCapacity) {    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}private static int calculateCapacity(Object[] elementData, int minCapacity) {    // 判断是否首次添加元素，如果是，返回默认队列长度，现在是10    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        return Math.max(DEFAULT_CAPACITY, minCapacity);    }    // 如果不是首次添加元素，就返回当前队列长度+1    return minCapacity;}private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    // 如果需要的长度大于队列中数组长度，扩容，如果可以满足需求，就不用扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    // 这里就是扩容1.5倍的代码    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><h2 id="就是这么不安全"><a href="#就是这么不安全" class="headerlink" title="就是这么不安全"></a>就是这么不安全</h2><p>从上面代码可以看出，<code>ArrayList</code>中一丁点考虑多线程的元素都没有，完全的效率优先。</p><h3 id="奇怪的ArrayIndexOutOfBoundsException"><a href="#奇怪的ArrayIndexOutOfBoundsException" class="headerlink" title="奇怪的ArrayIndexOutOfBoundsException"></a>奇怪的ArrayIndexOutOfBoundsException</h3><p>先做一个假设，此时数组长度达到临界边缘，比如目前容量是10，现在已经有9个元素，也就是size=9，然后有两个线程同时向队列中增加元素：</p><ol><li>线程1开始进入<code>add</code>方法，获取size=9，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量是10，不需要扩容</li><li>线程2也进入<code>add</code>方法，获取size=9，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量还是10，也不需要扩容</li><li>线程1开始赋值值了，也就是<code>elementData[size++] = e</code>，此时size变成10，达到数组容量极限</li><li>线程2此次开始执行赋值操作，使用的size=10，也就是<code>elementData[10] = e</code>，因为下标从0开始，目前数组容量是10，直接报数组越界<code>ArrayIndexOutOfBoundsException</code>。</li></ol><p>仅仅差了一步，线程2就成为了抛异常的凶手。但是抛出异常还是好的，因为我们知道出错了，可以沿着异常</p><h3 id="诡异的null元素"><a href="#诡异的null元素" class="headerlink" title="诡异的null元素"></a>诡异的null元素</h3><p>这种情况不太容易从代码中发现，得对代码稍加改造，<code>elementData[size++] = e</code>这块代码其实执行了两步：</p><pre><code class="java">elementData[size] = e;size++;</code></pre><p>假设还是有两个线程要赋值，此时数组长度还比较富裕，比如数组长度是10，目前size=5：</p><ol><li>线程1开始进入<code>add</code>方法，获取size=5，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量是10，不需要扩容</li><li>线程2也进入<code>add</code>方法，获取size=5，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量还是10，也不需要扩容</li><li>线程1开始赋值，执行<code>elementData[size] = e</code>，此时size=5，在执行<code>size++</code>之前，线程2开始赋值了</li><li>线程2开始赋值，执行<code>elementData[size] = e</code>，此时size还是5，所以线程2把线程1赋的值覆盖了</li><li>线程1开始执行<code>size++</code>，此时size=6</li><li>线程2开始执行<code>size++</code>，此时size=7</li></ol><p>也就是说，添加了2个元素，队列长度+2，但是真正加入队列的元素只有1个，有一个被覆盖了。</p><p>这种情况不会立马报错，排查起来就很麻烦了。而且随着JDK 8的普及，可能随手使用filter过滤空元素，这样就不会立马出错，直到出现业务异常之后才能发现，到那时，错误现场已经不见了，排查起来一头雾水。</p><p>有同学会问，源码中是<code>elementData[size++] = e</code>，是一行操作，为什么会拆成两步执行呢？其实这得从JVM字节码说起了。</p><h3 id="通过JVM字节码说说第二种异常出现的原因"><a href="#通过JVM字节码说说第二种异常出现的原因" class="headerlink" title="通过JVM字节码说说第二种异常出现的原因"></a>通过JVM字节码说说第二种异常出现的原因</h3><p>先来一段简单的代码：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        int[] nums = new int[3];        int index = 0;        nums[index++] = 5;    }}</code></pre><p>通过<code>javac Main.java</code>和<code>javap -v -l Main.class</code>组合操作得到字节码：</p><blockquote><p>下面那些中文是我后加的备注，备注中还列出了局部变量表和栈值的变化，需要有点耐心。</p></blockquote><pre><code class="class">public class Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #3.#12         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #13            // Main   #3 = Class              #14            // java/lang/Object   #4 = Utf8               &lt;init&gt;   #5 = Utf8               ()V   #6 = Utf8               Code   #7 = Utf8               LineNumberTable   #8 = Utf8               main   #9 = Utf8               ([Ljava/lang/String;)V  #10 = Utf8               SourceFile  #11 = Utf8               Main.java  #12 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V  #13 = Utf8               Main  #14 = Utf8               java/lang/Object{  public Main();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 1: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=3, locals=3, args_size=1                                                                               局部变量表                             栈         0: iconst_3                     // 将int型(3)推送至栈顶                                                      args                                3         1: newarray       int           // 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶          args                                数组引用         3: astore_1                     // 将栈顶引用型数值存入第二个本地变量                                            args, nums=数组引用                  null         4: iconst_0                     // 将int型(0)推送至栈顶                                                       args, nums=数组引用                  0         5: istore_2                     // 将栈顶int型数值存入第三个本地变量                                             args, nums=数组引用, index=0         null         6: aload_1                      // 将第二个引用类型本地变量推送至栈顶                                             args, nums=数组引用, index=0         数组引用         7: iload_2                      // 将第三个int型本地变量推送至栈顶                                               args, nums=数组引用, index=0         0, 数组引用         8: iinc          2, 1           // 将指定int型变量增加指定值（i++, i--, i+=2），也就是第三个本地变量增加1            args, nums=数组引用, index=1         0, 数组引用        11: iconst_5                     // 将int型(5)推送至栈顶                                                        args, nums=数组引用, index=1         5, 0, 数组引用        12: iastore                      // 将栈顶int型数值存入指定数组的指定索引位置                                       args, nums=数组引用, index=1         null        13: return                       // 从当前方法返回void      LineNumberTable:        line 3: 0                        // int[] nums = new int[3];        line 4: 4                        // int index = 0;        line 5: 6                        // nums[index++] = 5;        line 6: 13                       // 方法结尾默认的return}</code></pre><p>从上面的字节码可以看到，<code>nums[index++] = 5</code>这一句会被转为5个指令，是从6到12。大体操作如下：</p><ol><li>将数组、下标压入栈</li><li>给下标加值</li><li>将新值压入栈</li><li>取栈顶三个元素开始给元素指定下标赋值</li></ol><p>也即是说，错误出在数组赋值操作时先将数组引用和下标同时压入栈顶，与下标赋值是两步，在多线程环境中，就有可能出现上面说到的null值存在。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>其实解法也很简单，就是要意识到多线程环境，然后不使用ArrayList。可以使用<code>Collections.synchronizedList()</code>返回的同步队列，也可以使用<code>CopyOnWriteArrayList</code>这个队列，或者自己扩展<code>ArrayList</code>，将add方法做成同步方法。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p><code>ArrayList</code>整个类的操作都是非线程安全的，一旦在多线程环境中使用，就可能会出现问题。上面提到<code>add</code>操作就会有两种异常行为，一个是数组越界异常，一个是出现丢数且出现空值。这还只是最简单的<code>add</code>操作，如果<code>add</code>、<code>addAll</code>和<code>get</code>混合使用使用时，异常情况就更多了。所以，使用的时候一定要注意是不是单线程操作，如果不是，果断使用其他队列防雷。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老猿，Apache Storm、WxJava、Cynomys 开源贡献者。游于码界，戏享人生。</p><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用ArrayList会发生什么？</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113666581" target="_blank" rel="noopener">如果非要在多线程中使用ArrayList会发生什么？</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      我们真的清楚多线程情况下使用ArrayList会发生什么吗？
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="ArrayList" scheme="https://www.howardliu.cn/tags/ArrayList/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>java import 导入包时，我们需要注意什么呢？</title>
    <link href="https://www.howardliu.cn/java-import-package/"/>
    <id>https://www.howardliu.cn/java-import-package/</id>
    <published>2021-01-31T10:54:40.000Z</published>
    <updated>2021-01-31T10:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/still-life-5322950_1920.jpg" alt="java import 导入包"></p><p>你好，我是看山。</p><p>这篇文章起因是 code review 时和同事关于 import 导入声明的分歧。</p><p>用过 IDEA 的都知道，默认情况下，通过 import 导入类时，当数量达到设置数量（类 5 个、静态变量 3 个），就会改为按需导入方式，也就是使用使用*号折叠导入。</p><p>同事建议不要采用按需导入，要使用单类型导入 (single-type-import)。而我是觉得既然 IDEA 作为宇宙级的 IDE，不会在这种地方出现纰漏，所以想继续按照 IDEA 默认配置来。</p><p>所以总结一下这两种方式的差异。如果对 java import 不熟悉，可以从 <a href="https://javagoal.com/java-import-package/" target="_blank" rel="noopener">这里</a> 看看。</p><a id="more"></a><h2 id="import-的两种导入声明"><a href="#import-的两种导入声明" class="headerlink" title="import 的两种导入声明"></a>import 的两种导入声明</h2><p>在 java 中，通过 import 导入类的方式有两种：</p><ul><li>单类型导入（single-type-import），例如 <code>import java.io.File</code>：这种方式比较容易理解，而且大部分时候我们用的都是这种方式。通过明确指明类和接口路径，将他们导入进来。</li><li>按需类型导入（type-import-on-demand），例如 <code>import java.io.*</code>：通过通配符<code>*</code>定义导入方式，但是并不是直接导入这个包下的所有类，而是可以导入所有类。也就是说，如果需要就导入，不需要就不导入。</li></ul><p>有如下属性：</p><ol><li>java 以这样两种方式导入包中的任何一个<code>public</code>的类和接口（只有 public 类和接口才能被导入）</li><li>上面说到导入声明仅导入声明目录下面的类而不导入子包，这也是为什么称它们为类型导入声明的原因。</li><li>导入的类或接口的简名（simple name）具有编译单元作用域。这表示该类型简名可以在导入语句所在的编译单元的任何地方使用。这并不意味着你可以使用该类型所有成员的简名，而只能使用类型自身的简名。例如：java.lang 包中的 public 类都是自动导入的，包括<code>Math</code>和<code>System</code>类。但是，你不能使用它们的成员的简名<code>PI()</code>和<code>gc()</code>, 而必须使用<code>Math.PI()</code>和<code>System.gc()</code>. 你不需要键入的是<code>java.lang.Math.PI()</code>和<code>java.lang.System.gc()</code>。</li><li>程序员有时会导入当前包或<code>java.lang</code>包，这是不需要的，因为当前包的成员本身就在作用域内，而<code>java.lang</code>包是自动导入的。java 编译器会忽略这些冗余导入声明 (redundant import declarations)。</li></ol><h2 id="按需导入机制"><a href="#按需导入机制" class="headerlink" title="按需导入机制"></a>按需导入机制</h2><p>按需类型导入在大部分情况用起来更加方便，一个通配符可以导入包下的所有类，就不用费劲写一堆导入了。</p><p>但是，根据能量守恒，在敲代码时节省下来的能量，必然会在其他地方消耗。</p><p>比如，<code>Date</code>类，如果完全使用按需类型导入，可以写做<code>import java.util.*</code>。当这个类恰好需要，<code>PrepareStatement</code>时，又需要加上<code>import java.sql.*</code>导入，这个时候，编译器不知道<code>Date</code>类是要用<code>java.util</code>包里的还是<code>java.sql</code>里面的了，就会报出<code>Reference to &#39;Date&#39; is ambiguous, both &#39;java.util.Date&#39; and &#39;java.sql.Date&#39; match</code>异常，也就是所说的<strong>命名冲突</strong>。</p><p>解决办法就是指明<code>Date</code>类的全路径，也就是使用单类型导入：<code>import java.util.Date</code>。</p><p>除了命名冲突，还有一些不太明显的缺点：</p><ol><li>编译速度：因为按需导入机制的特性，需要在 CLASSPATH 下找到所有符合包名的类，在编译时会消耗性能。在小项目中，这个速度可以忽略。如果在大项目中，就会有明细差异。</li><li>可读性：在使用 IDE 开发过程中，我们很少会在<code>import</code>中查看类的路径。但是如果需要我们在其他环境编辑文件，比如 vim，从<code>import</code>查看类的路径就很便捷了。</li></ol><h2 id="导入不需要的类会发生什么呢"><a href="#导入不需要的类会发生什么呢" class="headerlink" title="导入不需要的类会发生什么呢"></a>导入不需要的类会发生什么呢</h2><p>从理性讲，java 编译器一定会在这里做优化，不会把不需要的导入声明加入到 class 文件中，但是之前没有看到哪里有说明，所以动手做一下实验：</p><p>先定义 java 类：</p><pre><code class="java">package cn.howardliu;// 需要用到的单类型导入import java.util.Date;// 需要用到的按需类型导入import java.math.*;// 不需要用到的单类型导入import java.sql.PreparedStatement;// 不需要用到的按需类型导入import java.awt.*;public class Main {    private Date date1;    private BigDecimal num1;    public void test(){        Date date2 = new Date();        BigDecimal num2 = new BigDecimal(0);    }}</code></pre><p>通过命令<code>javac Main.java</code>编译，然后通过<code>javap -verbose Main.class</code>查看编译结果：</p><pre><code class="class">Classfile /path/to/Main.class  Last modified 2021-1-31; size 439 bytes  MD5 checksum 81e13559f738197b4875c2c2afd6fc41  Compiled from &quot;Main.java&quot;public class cn.howardliu.Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #7.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #20            // java/util/Date   #3 = Methodref          #2.#19         // java/util/Date.&quot;&lt;init&gt;&quot;:()V   #4 = Class              #21            // java/math/BigDecimal   #5 = Methodref          #4.#22         // java/math/BigDecimal.&quot;&lt;init&gt;&quot;:(I)V   #6 = Class              #23            // cn/howardliu/Main   #7 = Class              #24            // java/lang/Object   #8 = Utf8               date1   #9 = Utf8               Ljava/util/Date;  #10 = Utf8               num1  #11 = Utf8               Ljava/math/BigDecimal;  #12 = Utf8               &lt;init&gt;  #13 = Utf8               ()V  #14 = Utf8               Code  #15 = Utf8               LineNumberTable  #16 = Utf8               test  #17 = Utf8               SourceFile  #18 = Utf8               Main.java  #19 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V  #20 = Utf8               java/util/Date  #21 = Utf8               java/math/BigDecimal  #22 = NameAndType        #12:#25        // &quot;&lt;init&gt;&quot;:(I)V  #23 = Utf8               cn/howardliu/Main  #24 = Utf8               java/lang/Object  #25 = Utf8               (I)V{  public cn.howardliu.Main();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 12: 0  public void test();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=3, args_size=1         0: new           #2                  // class java/util/Date         3: dup         4: invokespecial #3                  // Method java/util/Date.&quot;&lt;init&gt;&quot;:()V         7: astore_1         8: new           #4                  // class java/math/BigDecimal        11: dup        12: iconst_0        13: invokespecial #5                  // Method java/math/BigDecimal.&quot;&lt;init&gt;&quot;:(I)V        16: astore_2        17: return      LineNumberTable:        line 17: 0        line 18: 8        line 19: 17}SourceFile: &quot;Main.java&quot;</code></pre><p>从 class 文件内容可以看出：</p><ol><li>按需类型导入方式在 class 文件中的表现形式，与按类型导入一样，也会找到需要的类导入，不会导入包中的所有类。</li><li>不需要的类导入声明，最终都会被优化掉，不会出现在 class 文件中。</li><li>java 中的<code>import</code>与 C 语言中的<code>include</code>不同，不会将导入声明的类写入到 class 文件中，各自还是独立的 class 文件。</li></ol><h2 id="JDK-推荐哪种方式"><a href="#JDK-推荐哪种方式" class="headerlink" title="JDK 推荐哪种方式"></a>JDK 推荐哪种方式</h2><p>JDK 绝对是 java 编程的标杆，我们很多都可以从 JDK 中学习：</p><pre><code class="java">import java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;import java.io.InputStream;import java.io.OutputStream;import java.io.Reader;import java.io.Writer;import java.io.OutputStreamWriter;import java.io.BufferedWriter;import java.security.AccessController;import java.security.PrivilegedAction;import sun.util.spi.XmlPropertiesProvider;</code></pre><p>这是<code>java.util.Properties</code>中的 import 声明，可以看出，使用了单类型导入声明，所以，在没有其他要求的情况下，我们尽量还是使用单类型导入。</p><h2 id="文末思考"><a href="#文末思考" class="headerlink" title="文末思考"></a>文末思考</h2><ol><li>java 的<code>import</code>是类导入声明，不会将文件写入到编译后的 class 文件中</li><li>java 的<code>import</code>有两种导入方式：单类型导入、按需类型导入</li><li>按需类型导入只会在编译过程中有性能损失，在运行期与单类型导入无差别</li><li>JDK 源码中，大部分使用了单类型导入。</li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老后端，Apache Storm、WxJava、Cynomys开源贡献者。主业：程序猿，兼职：架构师。游于码界，戏享人生。</p><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/java-import-package/">java import 导入包</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113487825" target="_blank" rel="noopener">java import 导入包</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      java 的`import`是类导入声明，不会将文件写入到编译后的 class 文件中；java 的`import`有两种导入方式：单类型导入、按需类型导入；按需类型导入只会在编译过程中有性能损失，在运行期与单类型导入无差别；JDK 源码中，大部分使用了单类型导入。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="import" scheme="https://www.howardliu.cn/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾收集算法</title>
    <link href="https://www.howardliu.cn/algo-for-jvm-gc/"/>
    <id>https://www.howardliu.cn/algo-for-jvm-gc/</id>
    <published>2021-01-24T13:48:58.000Z</published>
    <updated>2021-01-24T13:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是根据周志明老师的《深入理解Java虚拟机》整理的学习笔记，后续会更新在<a href="https://github.com/howardliu-cn/Rebuild2020/tree/master/Java/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">深入理解Java虚拟机</a>中，希望能够帮到一些需要速成的同学。</p></blockquote><p>从如何判断对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两大类也常被称作“直接垃圾收集”和“间接垃圾收集”。</p><a id="more"></a><blockquote><p>主流 GC 算法均未涉及引用计数式垃圾收集，所以本文所有算法均为追踪式垃圾收集的范畴。</p></blockquote><h2 id="1-分代收集理论"><a href="#1-分代收集理论" class="headerlink" title="1. 分代收集理论"></a>1. 分代收集理论</h2><p>分代收集（Generational Collection），建立在三个假设上：</p><ol><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难消亡。</li><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>根据前两个分代假说，奠定了多款常用垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据年龄分配到不同的区域中存储。</p><p>一般至少将 Java 堆划分为新生代（Young Generation）和老年代（Old Generation）。</p><p>分代收集理论除了划分内存区域，还需要解决其他问题，比如：<strong>对象不是孤立的，对象之间会存在跨代引用</strong>。为了解决这个问题，就出现了第三条假说。</p><p>第三条假说是根据前两条假说逻辑推理得出的隐含推论：存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。</p><p>依据这条假说，我们就不应再为少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每个对象是否存在及存在哪个跨代引用，只需在新生代上建立一个全局的数据结构，被称为记忆集（Remembered Set），这个结构把老年代划分成若干小块，标识老年代哪一块内存会存在跨代引用。当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。</p><p>名词解释：</p><ul><li>部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集<ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：值目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。</li></ul></li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。<ul><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</li></ul></li></ul><h2 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记-清除算法"></a>2. 标记-清除算法</h2><p>标记-清除（Mark-Sweep）算法：标记所有需要回收对象，在标记完成后，统一回收掉所有被标记的对象；或者，标记存活的对象，统一回收所有未被标记的对象。</p><p>缺点：</p><ol><li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分需要被回收，这时必须进行大量标记和清除的动作，导致标记和清除的执行效率随对象数量增长而降低；</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后程序运行过程中需要分配较大对象时无法找到足够连续的内存而不得不触发另一次垃圾收集动作。</li></ol><p><img src="http://static.howardliu.cn/java/mark-sweep.jpg" alt="标记-清除算法"></p><h2 id="3-标记-复制算法"><a href="#3-标记-复制算法" class="headerlink" title="3. 标记-复制算法"></a>3. 标记-复制算法</h2><p>半区复制（Semispace Copying）算法：将可用内存按容量划分大小相等的两块，每次只使用其中一块。当一块内存用完了，就将还存活着的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。</p><p><img src="http://static.howardliu.cn/java/mark-copying.jpg" alt="标记-复制算法"></p><p>Appel 式回收：把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。如果 Survivor 空间不足以容纳 Minor GC 后存活对象时，这些对象通常分配进入老年代。</p><p>HotSpot 虚拟机默认 Eden 和 Survivor 大小比例是 8:1，即每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间被浪费。</p><p>Appel 式回收的理论依据：IBM 公司的研究表明，新生代中的对象有 98%熬不过第一轮收集。</p><h2 id="4-标记-整理算法"><a href="#4-标记-整理算法" class="headerlink" title="4. 标记-整理算法"></a>4. 标记-整理算法</h2><p>标记-整理（Mark-Compact）算法，其中标记过程与“标记-清除”算法一样，整理过程是让所有存储对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。</p><p><img src="http://static.howardliu.cn/java/mark-compact.jpg" alt="标记-整理算法"></p><p>标记整理算法的弊端是移动存活对象并更新所有引用工作量比较大，而且需要 Stop The World，会造成延迟。</p><p>标记清除算法的弊端是由于空间碎片化，需要复杂的内存分配器和内存访问器，会影响吞吐量。</p><p>HotSpot 虚拟机里面关注吞吐量的的 Parallel Scavenge 收集器是基于标记-整理算法的，关注延迟的 CMS 收集器是基于标记-清除算法的。</p><p>还有一种“和稀泥”的方式，大部分时间使用标记-清除算法，容忍内存碎片，当内存碎片影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/algo-for-jvm-gc/">JVM 垃圾收集算法</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113098581" target="_blank" rel="noopener">JVM 垃圾收集算法</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从如何判断对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两大类也常被称作“直接垃圾收集”和“间接垃圾收集”。
    
    </summary>
    
    
      <category term="jvm" scheme="https://www.howardliu.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.howardliu.cn/tags/jvm/"/>
    
      <category term="gc" scheme="https://www.howardliu.cn/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>软件架构-缓存技术</title>
    <link href="https://www.howardliu.cn/caching-techniques/"/>
    <id>https://www.howardliu.cn/caching-techniques/</id>
    <published>2021-01-17T06:57:07.000Z</published>
    <updated>2021-01-17T06:57:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/software-architecture/pipit-5683656_1920.jpg" alt="软件架构-缓存技术"></p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/software-architecture/index.html" target="_blank" rel="noopener">《软件架构》</a> 中关于缓存技术的内容，虽然是 2014 年的文章，但是从软件架构层面上，并不过时。</p></blockquote><a id="more"></a><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是一种加速数据查找（数据读取）的技术，直接读取本地缓存的数据，而不是从数据源读取数据，数据源包括数据库、其他远程系统。</p><p><img src="http://static.howardliu.cn/software-architecture/caching-1.png" alt="caching"></p><p>缓存是比源数据更靠近使用方的一块存储空间，可以更快的读取操作。缓存的存储介质一般是内存或磁盘，很多时候会选择内存作为缓存介质，但是内存缓存会在系统重启时丢失数据。</p><p>在软件系统中，数据缓存存在多层缓存级别或多层缓存系统。在 web 应用中，缓存至少有 3 种存储位置，如下图所示：</p><p><img src="http://static.howardliu.cn/software-architecture/caching-1-2.png" alt="caching"></p><p>在 web 应用中，我们会使用各种各样的数据库存储数据，这些数据库可以将数据存放在内存中，以便我们直接读取，而不需要从磁盘中读取数据。web 服务器可以在内存中缓存图片、css 文件、js 文件等，不需要每次需要的时候从硬盘中访问文件。web 应用可以将从数据库读取的数据缓存起来，这样就不需要每次使用的时候都通过网络从数据库中读取数据了。最后，浏览器也可能存储静态文件和数据。在支持 HTML5 的浏览器中，有 localstorage 存储空间、应用数据缓存、本地 sql 存储等技术支持缓存。</p><p>当我们提到缓存的时候，有下面几项内容需要考虑：</p><ul><li>写缓存</li><li>保持缓存和远程系统数据同步</li><li>管理缓存大小</li></ul><p>我会在接下来的内容中讨论这几项内容。</p><h2 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h2><p>第一项挑战是从远程系统中读取数据写到缓存中，一般有两种方式：</p><ul><li>提前写缓存</li><li>用时写缓存</li></ul><p>提前写缓存是在系统启动的时候，就将需要的数据缓存起来。要做到这一点，需要提前知道哪些数据需要缓存。但是我们有时候并不知道哪些数据需要在系统启动时候就缓存起来。</p><p>用时写缓存是说，在第一次使用数据的时候，将数据缓存起来，之后就可以使用缓存中的数据了。这种操作的方式是，首先检查缓存中是否有数据，有就直接使用，如果没有，就从远程系统读取数据，然后写入缓存中。</p><p>下表中我列出了提前写入和用时写入的优缺点：</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>提前写缓存</td><td>比用时写入减少了第一次缓存数据的延迟</td><td>系统启动初始化缓存数据的时候，需要比较长的时间。而且，有可能缓存的数据永远不会被用到。</td></tr><tr><td>用时写缓存</td><td>缓存的数据都是需要被用到的数据，而且没有启动延迟</td><td>在第一次缓存数据的时候，用的时间比较长，可能导致用户体验不一致</td></tr></tbody></table><p>当然，在真正实践过程中，我们可能两种方式并用：我们可以对热点数据使用提前缓存的方式，对其他数据使用用时缓存的方式。</p><h2 id="保持缓存和远程系统数据同步"><a href="#保持缓存和远程系统数据同步" class="headerlink" title="保持缓存和远程系统数据同步"></a>保持缓存和远程系统数据同步</h2><p>缓存数据的一个巨大挑战是保持缓存数据与远程系统数据保持同步，也就是数据一致。根据系统结构的不同，一般有不同的方式实现这个，我们来聊聊这几种方式。</p><h3 id="直接式缓存"><a href="#直接式缓存" class="headerlink" title="直接式缓存"></a>直接式缓存</h3><p>直写式缓存是允许读写缓存的一种方式，这种方式是，保存缓存数据的计算机，在将数据写入缓存的同时，将数据写到远程系统中。简单说就是，写入操作被写到远程系统中。</p><p>只有远程系统的数据只能被直写式缓存修改时，这种方式才起作用。如果所有的数据读写都要经过直写式缓存系统，那就很容易将写入的数据更新到远程系统中，保持缓存与远程系统数据的一致性。</p><h3 id="基于过期时间"><a href="#基于过期时间" class="headerlink" title="基于过期时间"></a>基于过期时间</h3><p>如果远程系统可以不依赖远程系统进行数据更新，那缓存和远程系统之间数据同步就很难通过直写式缓存方式保证了。</p><p>保持缓存数据同步的一种方法是，为数据设置一个缓存时间。当数据过期时，就把这些数据从缓存中清除。如果再次需要读取这些数据，可以从远程系统中读取最新的数据缓存起来。</p><p>数据过期时间取决于系统需要，有些类型的数据（比如文章），可能不需要随时的完全更新，可以设置 1 小时的过期时间。对于某些文章，你甚至可以忍受 24 小时的过期时间。</p><p>需要注意的是，如果过期时间比较短，可能会频繁读取远程系统，降低缓存的作用。</p><h3 id="主动过期"><a href="#主动过期" class="headerlink" title="主动过期"></a>主动过期</h3><p>还有一种方式是主动过期，是指主动更新缓存数据。比如，远程系统数据更新时，发送一条消息到缓存系统中，指示系统数据已被更新，可以将数据设置为过期。</p><p>主动过期的优点是，可能保证远程系统数据更新后，缓存数据被尽快的更新。还有一个附加好处是“基于过期时间”方式没有办法是实现的，就是不会频繁更新没有修改的数据。</p><p>主动过期的缺点是，需要能够检测远程系统数据的变化。如果远程系统是一个关系型数据库，可以被不同的机制更新数据，那每种更新机制都需要报告他们更新了哪些数据，否则，就没有办法向缓存数据的系统通知过期消息了。</p><h2 id="管理缓存大小"><a href="#管理缓存大小" class="headerlink" title="管理缓存大小"></a>管理缓存大小</h2><p>管理缓存大小，是一个重要的方面。许多系统存储了大量数据，以至于不可能将所有数据都存储在缓存中。因此，需要一种机制来管理缓存的数据量。管理缓存大小通常是将不需要的缓存数据清除，来腾出足够的空间。一般有下面几种方式：</p><ul><li>基于时间清理</li><li>先进先出（FIFO）</li><li>先进后出（FILO）</li><li>最少被使用</li><li>最小访问间隔</li></ul><p>基于时间清理方式是类似于前面提到的基于时间过期。除了可以保持数据与远程系统同步，还能够减少缓存数据的大小。可以开启一个单独的监听线程，也可以在读写新值的时候清理数据。</p><p>先进先出清理方式意味着，当写入一个新的缓存的时候，就需要删除最早插入的缓存值。如果空间足够，也是可以不删除任何数据的。</p><p>先进后出的方式正好和先进先出相反，这种方式对于先存储的数据时热点数据的情况比较有用。</p><p>最少被使用清理方式是首先清理访问次数最少的缓存数据。这种方式的目的是避免清理热点数据，为了实现这种方式，需要记录缓存数据被访问的次数。需要注意一个问题，缓存中的旧值可能有较高的访问次数，这样就意味着这些旧值不会被清理。比如一篇旧文章的缓存，以前被访问过很多次，但是最近很少访问了，但是因为原来的访问量很高，尽管目前访问量较低，也不会被清理。为了避免这种情况，访问次数可以是针对 N 个小时统计。</p><p>最小访问间隔清理方式是将访问时间间隔考虑在内。访问某个缓存数据时，就需要标记访问该数据的时间并增加访问次数。第二次访问这个缓存数据时，就增加访问次数，并计算平均访问时间。那些曾经是热点数据，被频繁访问，但是最近访问时间间隔变长，访问频率下降的数据，其平均访问时间会降低，当降到足够低的时候，就会被清理。</p><p>有一种变化方式是，只计算最后 N 次访问的时间。N 可以是 100、1 或者其他任何有意义的数。每当访问计数到 N 时，访问计数被重置为 0，记录下来访问时间。这种方式可以更快的清理热度下降的数据。</p><p>还有一种变化方式是，定期重置访问计数，并且只使用最小访问的清理方式。比如，每缓存一个小时的数据，前一个小时的访问计数会存储在另一个变量中，以便决策清理时使用。下一个小时访问计数重置为 0。这种机制具有上次变化相同的效果。</p><p>最后两个变体之间的差异总结起来就是在每次缓存检查时，访问计数是否已达到 N，或者时间间隔是否已超过 Y。第一种方式是每隔 N 次访问一次系统时钟，而第二种方式在每次访问时都读取一次系统时钟（查看时间间隔是否已过期）。因为检查一个整数通常比读取系统时钟快，所以我会选择第一种方式。</p><p>请记住，即使使用缓存大小管理系统，也需要清理、读取和存储数据，以保证他们能够与远程系统保持一致。尽管缓存的数据被大量访问而驻留在系统中，有时候也需要与远程系统同步。</p><h2 id="服务器集群中的缓存"><a href="#服务器集群中的缓存" class="headerlink" title="服务器集群中的缓存"></a>服务器集群中的缓存</h2><p>单一服务中的缓存设计更加简单，因为你能够保证，所有写入操作都通过一个服务器，可以使用直写式缓存方式。但是在分布式集群中，情况会比较复杂，下图说明了这种情况：</p><p><img src="http://static.howardliu.cn/software-architecture/caching-2.png" alt="caching"></p><p>简单的使用直写式缓存只会更新写操作的服务器上的缓存，集群中其他服务器对此完全不知情，也就不会更新数据。</p><p>在服务器集群中，可以使用基于时间的过期策略或者主动过期策略，来保证缓存数据与远程系统的同步。</p><h2 id="缓存产品"><a href="#缓存产品" class="headerlink" title="缓存产品"></a>缓存产品</h2><p>实现自己的缓存系统并不难弄，取决于是否需要深度定制。如果没有必要自己实现缓存系统，可以用已经现成的缓存产品。比如：</p><ul><li><a href="http://memcached.org/" target="_blank" rel="noopener">Memcached</a></li><li><a href="http://ehcache.org/" target="_blank" rel="noopener">Ehcache</a></li><li><a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>【译者加】</li></ul><p>我不知道这些产品是否能够满足需要，但是我知道他们用的比较广泛。</p><hr><p>原文链接：<a href="http://tutorials.jenkov.com/software-architecture/caching-techniques.html" target="_blank" rel="noopener">Caching Techniques</a><br>翻译: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接: <a href="https://www.howardliu.cn/caching-techniques/">软件架构-缓存技术</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/112759115" target="_blank" rel="noopener">软件架构-缓存技术</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      缓存是一种加速数据查找（数据读取）的技术，直接读取本地缓存的数据，而不是从数据源读取数据，数据源包括数据库、其他远程系统。
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="缓存" scheme="https://www.howardliu.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>学非探其花 要自拔其根</title>
    <link href="https://www.howardliu.cn/keep-moving-forward/"/>
    <id>https://www.howardliu.cn/keep-moving-forward/</id>
    <published>2021-01-10T12:20:18.000Z</published>
    <updated>2021-01-10T12:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/raving/coast-5870088_1920.jpg" alt="学非探其花 要自拔其根"></p><p>昨天训练营最后一次直播答疑，问了老师一个问题：“课程中很多内容，感觉自己会，但是让自己讲却讲不出来，或者就算讲出来也不够专业，请老师指点一下？”</p><p>老师耐心做了解答，主要说了两点：</p><ol><li>不够透彻，没有抓住核心，更深层次的东西，浮于表面，没有把握和底气。</li><li>缺乏实践，想办法用，想办法深入进去。</li></ol><p>思考一下转化成自己的理解：</p><ol><li>学非探其花，要深拔其根。想要能够讲出来，必须得抓住核心，而不是流于表面。</li><li>世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。想要成长，就得比别人付出更多的努力。</li></ol><p>然后就想到自己14年的一篇旧文，这里再翻出来。</p><a id="more"></a><p>这段时间因为种种事情，感觉自己很浮躁。作为一名IT民工，把自己当做是一个做技术的人，所以一直希望自己是能够踏踏实实做事的人。不管周围如何变化，希望自己能够沉下心来好好的工作、好好学习。</p><p>毕业到现在两年多了，工作上有一些富裕时间可以自己自由安排。刚开始充分利用这些时间，深入学习一些工作中使用的技术，也算是小有成效。也是因为那段时间自己的努力，先是修改项目中使用的一个下拉菜单的插件，深得开发经理的赞赏，在之后移植手机APP的开发过程中，担任骨干开发人员。</p><p>但随着时间的推进，在项目组中担任角色的变化，看到了当前很多流行的技术后，开始这一头、那一脚的学习，Shell、Python、Pro C、NodeJS、Lucene、Solr、Hadoop等等等等，很多都是蜻蜓点水般的了解一下，有的甚至连水都没有沾到。有时候还自以为是的觉得自己很牛X，幸好有一天，突然感觉自己什么都不懂，什么都不会了，才算是幡然悔悟，开始反省自己。</p><p>佛家有三种境界：</p><ul><li>第一境界：看山是山，看水是水；</li><li>第二境界：看山不是山，看水不是水；</li><li>第三境界：看山是山，看水是水。</li></ul><p>跟朋友描述了一下当前的状态，朋友笑称境界提升了。但自己知自家事，我现在还在第一境界中，甚至连第二境界还没有达到，不禁心中很是失落，自己这段时间算是浪费了。</p><p>软件行业本就是新技术层出不穷，更新迭代频繁，想要学会所有的技术是不可能的。我就是陷入的追逐新技术的怪圈中，就像是捉蝴蝶，一会捉这只，一会捉那只，到最后，一只也没有捉到。</p><p>庄子有言：吾生也有涯，而知也无涯，以有涯随无涯，殆已。</p><p>古人诚不我欺。</p><p>知道了自己错在哪，似乎“怎么做”也就呼之欲出。有句话叫做“大道同途”，用在软件方面，应该可以理解为，很多类似的技术其本质都是一样的，没有必要学习所有的技术，只要掌握其中的一部分，其他的可以根据这一部分进行推导，由点及面，就仿佛一张蜘蛛网，掌握了中间的一个点，慢慢的向外扩展，逐步掌握周边的技术。</p><p>杜牧曾经劝诫其子：学非探其花，要自拔其根。</p><p>学习并不能像观赏花卉，应该探其根本，掌握其精髓。当真正掌握精髓之后，便能够举一反三，掌握很多东西了。之前自己学习新技术的时候，只是流于表面，写个Hello World就以为看到了全世界，没有深入学习其中的原理、精髓。</p><p>“练武不练功，到老一场空。”,这些技术就相当于武，是招式架子，而其中的原理，就相当于功，内家功法。</p><p>“阿弥陀佛，善哉善哉，施主悟了。”</p><p>“呵呵。”</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/keep-moving-forward/">学非探其花 要自拔其根</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      学非探其花，要深拔其根。想要能够讲出来，必须得抓住核心，而不是流于表面。世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。想要成长，就得比别人付出更多的努力。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="学非探其花" scheme="https://www.howardliu.cn/tags/%E5%AD%A6%E9%9D%9E%E6%8E%A2%E5%85%B6%E8%8A%B1/"/>
    
      <category term="要自拔其根" scheme="https://www.howardliu.cn/tags/%E8%A6%81%E8%87%AA%E6%8B%94%E5%85%B6%E6%A0%B9/"/>
    
  </entry>
  
  <entry>
    <title>我从 HX 辞职了</title>
    <link href="https://www.howardliu.cn/i-resigned-from-hx/"/>
    <id>https://www.howardliu.cn/i-resigned-from-hx/</id>
    <published>2020-12-31T10:53:57.000Z</published>
    <updated>2020-12-31T10:53:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/thinking/fire-4892711_1920.jpg" alt="我从 HX 辞职了"></p><blockquote><p>这篇文章早就想写了，结果一直拖到 2020 最后一天，借着年终总结的感觉，记一下流水账，算是给这段经历画上一个句号。</p></blockquote><p>2020 年十一假期后和领导提了离职，思考很久的结果。在这待了整三年，一届高中生毕业了。</p><a id="more"></a><p>因为一些原因，离职过程匆匆忙忙的，没有好好告别，总感觉差点意思，这里先胡乱说几句，算是开始画句号，毕竟三年时间，没做什么事，但也做了很多事。本文通篇灌水，记一下流水账。</p><p>HX 旗下有一个钻戒品牌相信很多人听过或者见过，全国线下门店 600 多家，近两年 618、双十一钻石类目第一。这样想来，好像待过的几家公司，都在各自业务领域做的比较牛。</p><p>这 3 年里，我算是见证了它在线上营销从 0 到 1，再到第一的过程，虽然我就是个程序猿，但是那个时候，开发和线上运营都在一个中心，虽然荣誉和奖金都是别人的事，但吃个牛还是挺爽的。</p><p>到 HX 是大哥叫去了，2017 年 11 月 1 号入职。因为当时官方商城和天猫旗舰店都没什么量，而且双十一那天有考试，所以妥妥的在家睡了个好觉，三年来唯一一次。听说那天晚上大哥、周老板、小文几个人熬了个大夜，从 0 到 1 的阶段真的挺难的。在大家都关心流量的时候，想要从平台分一些流量、从别人嘴里抢一些流量太难了。</p><p>刚去 HX，就碰到了坑人的官网改版，而且当时开发负责人闹情绪离职，啥也没交接就休假了。我和来福一脸懵逼的开始弄，偌大一个工程 12 月 20 上线。当时特别希望有个人可以给说一下业务，可惜没有，只能摸着石头过河。万幸的是，组里其他人都很负责任，而且需要改造的系统比较 low，有问题就直接暴力改造。最后准时上线，挺好。</p><p>后来是甜蜜秀项目，通过活动奖品引诱用户发文拉赞，用来获客。第一次活动正好是春节期间，结果有人刷赞，我还以为是系统 bug，过年期间查了 N 遍，也没多休息，初七就赶回了公司。万没想到是，是花钱买赞的。也是这次之后，知道风控的重要性了。</p><p>后续就是会员中心升级和模块化、香水项目、门店二维码、亲子品牌官网改版……太多了，不想流水账了，说下几个大的就好。</p><p>18 年因为香水项目折腾的太惨，启动了中台项目，9 月份开始，第二年 5 月份一期上线。我也是在这个过程中，经历了架构设计、系统设计、功能开发、团队管理，每一个都有很多值得总结的点，立个 flag，要在 2021 年总结出来，要不然，那段痛苦的经历就白白浪费了。</p><p>中台其实是比较挑公司的，对于 HX 这种有 N 多个品牌独立运营、对接 N 多个渠道的公司，挺需要一个可以支撑这种变化的 IT 系统的。只不过是公司的人不清楚其中的价值，当然也不能全怪他们，这个系统当时做的比较匆忙，很多地方有问题，而且后期人手太少、资源不足，很多问题没有时间修复，即使这样，也是在疫情期间支持了 7 天完成 3 个完整电商小程序项目、从 0 开始的优惠券营销系统的上线。所以说，即使是这个到处是破洞的系统，也不是随便一个系统就可以替换的，就算百胜的系统也不行。（说到百胜，是因为听说我走了之后要换中台，要用百胜的系统，调研结果是，需要 300w，还只能满足 50%的功能。）</p><p>其实对于 HX 是有感情的，毕竟待了三年，光加班时间加起来都可以调休好几个月了（可惜都过期了），我走的时候，看到了对系统研发的不重视，就在刚才，得知对线上营销也不重视了。感觉现在她在逆风而行，毕竟现在 IT 建设是一个公司发展的基石，可能我辈凡人体会不到大领导的苦心吧。所以，思考了很久，还是离开吧。</p><p>交接的时候，交接文档写了 30 多页，有两页是我负责过的 34 个研发项目，剩下都是给运维的一些介绍。挺无奈的，被交接人完全没有参与过这些项目，还很轻视这些，那个目录，本意是根据他提出的问题，完善交接文档，结果人家一点不看，这就没有办法了。不过后来听说，他很长一段时间，都没办法在本地启动项目，挺嘲讽的一件事。</p><p>休假的时候，做了个小手术，在医院呆了 17 天，算是 3 年来完全放空自己的一段时间，也能好好思考这三年的得失，收获挺多。所以，2021 年，无论多忙，都要留出思考的时间。</p><p>在 HX 的流水账写完了，说一下接下来的计划：</p><ul><li>伤口恢复差不多之后，请老同事吃顿散伙饭</li><li>补上架构师训练营落下的作业，先达到毕业标准</li><li>在新公司多学多看，之前吃亏在没有见识，现在有见识的机会得抓住</li><li>完成代办里面那些要写的总结，经历过的不能白经历</li><li>2021 年至少每周一篇更新</li><li>继续 Rebuild2020 那个项目</li></ul><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/i-resigned-from-hx/">我从 HX 辞职了</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/112055786" target="_blank" rel="noopener">我从 HX 辞职了</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      2020 年最后一篇博文，记一些流水账。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="辞职" scheme="https://www.howardliu.cn/tags/%E8%BE%9E%E8%81%8C/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：如何优雅的处理异常</title>
    <link href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/"/>
    <id>https://www.howardliu.cn/springboot-action-gracefully-response-exception/</id>
    <published>2020-09-11T02:55:46.000Z</published>
    <updated>2020-09-11T02:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/springboot/sea-4841142_1920.jpg" alt="SpringBoot 实战：如何优雅的处理异常"></p><p>前段时间写了一篇<a href="https://www.howardliu.cn/springboot-action-gracefully-response/">关于实现统一响应信息的博文</a>，根据文中实战操作，能够解决正常响应的一致性，但想要实现优雅响应，还需要优雅的处理异常响应，所以有了这篇内容。</p><p>作为后台服务，能够正确的处理程序抛出的异常，并返回友好的异常信息是非常重要的，毕竟我们大部分代码都是为了 处理异常情况。而且，统一的异常响应，有助于客户端理解服务端响应，并作出正确处理，而且能够提升接口的服务质量。</p><a id="more"></a><p>SpringBoot提供了异常的响应，可以通过<code>/error</code>请求查看效果：</p><p><img src="http://static.howardliu.cn/springboot/springboot-error.png" alt="SpringBoot错误页面"></p><p>这是从浏览器打开的场景，也就是请求头不包括<code>content-type: applicaton/json</code>，大白板一个，和友好完全不搭边。</p><p><img src="http://static.howardliu.cn/springboot/springboot-error-json.png" alt="SpringBoot错误响应"></p><p>这是请求头包括<code>content-type: applicaton/json</code>时的响应，格式还行，但是我们还需要加工一下，实现自定义的异常码和异常信息。</p><p>本文主要是针对RESTful请求的统一响应，想要实现的功能包括：</p><ol><li>自动封装异常，返回统一响应</li><li>异常信息国际化</li></ol><h2 id="定义异常响应类"><a href="#定义异常响应类" class="headerlink" title="定义异常响应类"></a>定义异常响应类</h2><p>当程序发送错误时，不应该将晦涩的堆栈报告信息返回给API客户端，从某种意义讲，这是一种不礼貌的和不负责任的行为。</p><p>我们在<a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a>中，定义了一个响应类，为什么还要再定义一个异常响应类呢？其实是为了语义明确且职责单一。类图如下：</p><p><img src="http://static.howardliu.cn/springboot/ErrorResponse1.png" alt="定义异常响应类"></p><p>具体代码如下：</p><p>基础类<code>BaseResponse</code>：</p><pre><code class="java">@Datapublic abstract class BaseResponse {    private Integer code;    private String desc;    private Date timestamp = new Date();    private String path;    public BaseResponse() {    }    public BaseResponse(final Integer code, final String desc) {        this.code = code;        this.desc = desc;    }    public BaseResponse(final Integer code, final String desc, final String path) {        this.code = code;        this.desc = desc;        this.path = path;    }}</code></pre><p>异常类<code>ErrorResponse</code>：</p><pre><code class="java">@EqualsAndHashCode(callSuper = true)@Datapublic class ErrorResponse extends BaseResponse {    public ErrorResponse(final Integer code, final String desc) {        super(code, desc);    }    public ErrorResponse(final Integer code, final String desc, final WebRequest request) {        super(code, desc, extractRequestURI(request));    }    public ErrorResponse(final HttpStatus status, final Exception e) {        super(status.value(), status.getReasonPhrase() + &quot;: &quot; + e.getMessage());    }    public ErrorResponse(final HttpStatus status, final Exception e, final WebRequest request) {        super(status.value(), status.getReasonPhrase() + &quot;: &quot; + e.getMessage(), extractRequestURI(request));    }    private static String extractRequestURI(WebRequest request) {        final String requestURI;        if (request instanceof ServletWebRequest) {            ServletWebRequest servletWebRequest = (ServletWebRequest) request;            requestURI = servletWebRequest.getRequest().getRequestURI();        } else {            requestURI = request.getDescription(false);        }        return requestURI;    }}</code></pre><h2 id="定义异常枚举类"><a href="#定义异常枚举类" class="headerlink" title="定义异常枚举类"></a>定义异常枚举类</h2><p>为了能够规范响应码和响应信息，我们可以定义一个枚举类。</p><p><img src="http://static.howardliu.cn/springboot/ResponseEnum.png" alt="定义异常枚举类"></p><p>枚举接口<code>ResponseEnum</code>：</p><pre><code class="java">public interface ResponseEnum {    Integer getCode();    String getMessage();    default String getLocaleMessage() {        return getLocaleMessage(null);    }    String getLocaleMessage(Object[] args);}</code></pre><p>枚举类<code>CommonResponseEnum</code>：</p><pre><code class="java">public enum CommonResponseEnum implements ResponseEnum {    BAD_REQUEST(HttpStatus.BAD_REQUEST.value(), &quot;Bad Request&quot;),    NOT_FOUND(HttpStatus.NOT_FOUND.value(), &quot;Not Found&quot;),    METHOD_NOT_ALLOWED(HttpStatus.METHOD_NOT_ALLOWED.value(), &quot;Method Not Allowed&quot;),    NOT_ACCEPTABLE(HttpStatus.NOT_ACCEPTABLE.value(), &quot;Not Acceptable&quot;),    REQUEST_TIMEOUT(HttpStatus.REQUEST_TIMEOUT.value(), &quot;Request Timeout&quot;),    UNSUPPORTED_MEDIA_TYPE(HttpStatus.UNSUPPORTED_MEDIA_TYPE.value(), &quot;Unsupported Media Type&quot;),    INTERNAL_SERVER_ERROR(HttpStatus.INTERNAL_SERVER_ERROR.value(), &quot;Server Error&quot;),    SERVICE_UNAVAILABLE(HttpStatus.SERVICE_UNAVAILABLE.value(), &quot;Service Unavailable&quot;),    ILLEGAL_ARGUMENT(4000, &quot;Illegal Argument&quot;),    DATA_NOT_FOUND(4004, &quot;Data Not Found&quot;),    USER_NOT_FOUND(4104, &quot;User Not Found&quot;),    MENU_NOT_FOUND(4204, &quot;Menu Not Found&quot;),    INTERNAL_ERROR(9999, &quot;Server Error&quot;),    ;    private final Integer code;    private final String message;    private MessageSource messageSource;    CommonResponseEnum(final Integer code, final String message) {        this.code = code;        this.message = message;    }    @Override    public Integer getCode() {        return code;    }    @Override    public String getMessage() {        return message;    }    @Override    public String getLocaleMessage(Object[] args) {        return messageSource.getMessage(&quot;response.error.&quot; + code, args, message, LocaleContextHolder.getLocale());    }    public void setMessageSource(final MessageSource messageSource) {        this.messageSource = messageSource;    }    @Component    public static class ReportTypeServiceInjector {        private final MessageSource messageSource;        public ReportTypeServiceInjector(final MessageSource messageSource) {            this.messageSource = messageSource;        }        @PostConstruct        public void postConstruct() {            for (final CommonResponseEnum anEnum : CommonResponseEnum.values()) {                anEnum.setMessageSource(messageSource);            }        }    }}</code></pre><p>需要注意的是，我们在异常枚举类中定义了<code>ReportTypeServiceInjector</code>类，这个类的作用是为枚举类注入<code>MessageSource</code>对象，是为了实现异常信息的国际化。这部分功能Spring已经封装好了，我们只需要在resources目录中定义一组<code>messages.properties</code>文件就可以了，比如：</p><p>message.properties定义默认描述：</p><pre><code class="properties">response.error.4000=[DEFAULT] Illegal Argumentsresponse.error.4004=[DEFAULT] Not Found</code></pre><p>messages_zh_CN.properties定义中文描述：</p><pre><code class="properties">response.error.4004=对应数据未找到response.error.9999=系统异常，请求参数: {0}</code></pre><p>messages_en_US.properties定义英文描述：</p><pre><code class="properties">response.error.4004=Not Found</code></pre><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>Java和Spring中提供了很多可用的异常类，可以满足大部分场景，但是有时候我们希望异常类可以携带更多信息，所以还是需要自定义异常类：</p><ul><li>可以携带我们想要的信息；</li><li>有更加明确语义；</li><li>附带效果，可以知道这是手动抛出的业务异常。</li></ul><p>上代码：</p><pre><code class="java">@Data@EqualsAndHashCode(callSuper = true)public class CodeBaseException extends RuntimeException {    private final ResponseEnum anEnum;    private final Object[] args;// 打印参数    private final String message;// 异常信息    private final Throwable cause;// 异常栈    public CodeBaseException(final ResponseEnum anEnum) {        this(anEnum, null, anEnum.getMessage(), null);    }    public CodeBaseException(final ResponseEnum anEnum, final String message) {        this(anEnum, null, message, null);    }    public CodeBaseException(final ResponseEnum anEnum, final Object[] args, final String message) {        this(anEnum, args, message, null);    }    public CodeBaseException(final ResponseEnum anEnum, final Object[] args, final String message, final Throwable cause) {        this.anEnum = anEnum;        this.args = args;        this.message = message;        this.cause = cause;    }}</code></pre><h2 id="自定义异常信息处理类"><a href="#自定义异常信息处理类" class="headerlink" title="自定义异常信息处理类"></a>自定义异常信息处理类</h2><p>前期准备工作完成，接下来定义异常信息处理类。</p><p>Spring自带的异常信息处理类往往不能满足我们实际的业务需求，这就需要我们定义符合具体情况的异常信息处理类，在自定义异常信息处理类中，我们可以封装更为详细的异常报告。我们可以扩展Spring提供的ResponseEntityExceptionHandler类定义自己的异常信息处理类，站在巨人的肩膀上，快速封装自己需要的类。</p><p>通过源码可以看到，<code>ResponseEntityExceptionHandler</code>类的核心方法是<code>public final ResponseEntity&lt;Object&gt; handleException(Exception ex, WebRequest request)</code>，所有的异常都在这个方法中根据类型进行处理，我们只需要实现具体的处理方法即可：</p><pre><code class="java">@RestControllerAdvice@Slf4jpublic class UnifiedExceptionHandlerV2 extends ResponseEntityExceptionHandler {    private static final String ENV_PROD = &quot;prod&quot;;    private final MessageSource messageSource;    private final Boolean isProd;    public UnifiedExceptionHandlerV2(@Value(&quot;${spring.profiles.active:dev}&quot;) final String activeProfile, final MessageSource messageSource) {        this.messageSource = messageSource;        this.isProd = new HashSet&lt;&gt;(Arrays.asList(activeProfile.split(&quot;,&quot;))).contains(ENV_PROD);    }    @Override    protected ResponseEntity&lt;Object&gt; handleExceptionInternal(final Exception e, final Object body, final HttpHeaders headers, final HttpStatus status, final WebRequest request) {        log.info(&quot;请求异常：&quot; + e.getMessage(), e);        if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {            request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, e, WebRequest.SCOPE_REQUEST);        }        return new ResponseEntity&lt;&gt;(new ErrorResponse(status, e), headers, HttpStatus.OK);    }    @Override    protected ResponseEntity&lt;Object&gt; handleBindException(final BindException ex, final HttpHeaders headers, final HttpStatus status, final WebRequest request) {        log.info(&quot;参数绑定异常&quot;, ex);        final ErrorResponse response = wrapperBindingResult(status, ex.getBindingResult());        return new ResponseEntity&lt;&gt;(response, headers, HttpStatus.OK);    }    @Override    protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(final MethodArgumentNotValidException ex, final HttpHeaders headers, final HttpStatus status, final WebRequest request) {        log.info(&quot;参数校验异常&quot;, ex);        final ErrorResponse response = wrapperBindingResult(status, ex.getBindingResult());        return new ResponseEntity&lt;&gt;(response, headers, HttpStatus.OK);    }    @ExceptionHandler(value = CodeBaseException.class)    @ResponseBody    public ErrorResponse handleBusinessException(CodeBaseException e) {        log.error(&quot;业务异常：&quot; + e.getMessage(), e);        final ResponseEnum anEnum = e.getAnEnum();        return new ErrorResponse(anEnum.getCode(), anEnum.getLocaleMessage(e.getArgs()));    }    @ExceptionHandler(value = Exception.class)    @ResponseBody    public ErrorResponse handleExceptionInternal(Exception e) {        log.error(&quot;未捕捉异常：&quot; + e.getMessage(), e);        final Integer code = INTERNAL_SERVER_ERROR.getCode();        return new ErrorResponse(code, getLocaleMessage(code, e.getMessage()));    }    /**     * 包装绑定异常结果     *     * @param status        HTTP状态码     * @param bindingResult 参数校验结果     * @return 异常对象     */    private ErrorResponse wrapperBindingResult(HttpStatus status, BindingResult bindingResult) {        final List&lt;String&gt; errorDesc = new ArrayList&lt;&gt;();        for (ObjectError error : bindingResult.getAllErrors()) {            final StringBuilder msg = new StringBuilder();            if (error instanceof FieldError) {                msg.append(((FieldError) error).getField()).append(&quot;: &quot;);            }            msg.append(error.getDefaultMessage() == null ? &quot;&quot; : error.getDefaultMessage());            errorDesc.add(msg.toString());        }        final String desc = isProd ? getLocaleMessage(status.value(), status.getReasonPhrase()) : String.join(&quot;, &quot;, errorDesc);        return new ErrorResponse(status.value(), desc);    }    private String getLocaleMessage(Integer code, String defaultMsg) {        try {            return messageSource.getMessage(&quot;&quot; + code, null, defaultMsg, LocaleContextHolder.getLocale());        } catch (Throwable t) {            log.warn(&quot;本地化异常消息发生异常: {}&quot;, code);            return defaultMsg;        }    }}</code></pre><p>如果感觉Spring的<code>ResponseEntityExceptionHandler</code>类不够灵活，也可以完全自定义异常处理类：</p><pre><code class="java">@RestControllerAdvice@Slf4jpublic class UnifiedExceptionHandler {    private static final String ENV_PROD = &quot;prod&quot;;    private final MessageSource messageSource;    private final Boolean isProd;    public UnifiedExceptionHandler(@Value(&quot;${spring.profiles.active:dev}&quot;) final String activeProfile, final MessageSource messageSource) {        this.messageSource = messageSource;        this.isProd = new HashSet&lt;&gt;(Arrays.asList(activeProfile.split(&quot;,&quot;))).contains(ENV_PROD);    }    @ExceptionHandler({            MissingServletRequestParameterException.class,// 缺少servlet请求参数异常处理方法            ServletRequestBindingException.class,// servlet请求绑定异常            TypeMismatchException.class,// 类型不匹配            HttpMessageNotReadableException.class,// 消息无法检索            MissingServletRequestPartException.class// 缺少servlet请求部分    })    public ErrorResponse badRequestException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(BAD_REQUEST.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            NoHandlerFoundException.class// 没有发现处理程序异常    })    public ErrorResponse noHandlerFoundException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(NOT_FOUND.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            HttpRequestMethodNotSupportedException.class// 不支持的HTTP请求方法异常信息处理方法    })    public ErrorResponse httpRequestMethodNotSupportedException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(METHOD_NOT_ALLOWED.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            HttpMediaTypeNotAcceptableException.class// 不接受的HTTP媒体类型异常处方法    })    public ErrorResponse httpMediaTypeNotAcceptableException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(NOT_ACCEPTABLE.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            HttpMediaTypeNotSupportedException.class// 不支持的HTTP媒体类型异常处理方法    })    public ErrorResponse httpMediaTypeNotSupportedException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(UNSUPPORTED_MEDIA_TYPE.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            AsyncRequestTimeoutException.class// 异步请求超时异常    })    public ErrorResponse asyncRequestTimeoutException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(SERVICE_UNAVAILABLE.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            MissingPathVariableException.class,// 请求路径参数缺失异常处方法            HttpMessageNotWritableException.class,// HTTP消息不可写            ConversionNotSupportedException.class,// 不支持转换    })    public ErrorResponse handleServletException(Exception e, WebRequest request) {        log.error(e.getMessage(), e);        return new ErrorResponse(INTERNAL_SERVER_ERROR.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            BindException.class// 参数绑定异常    })    @ResponseBody    public ErrorResponse handleBindException(BindException e, WebRequest request) {        log.error(&quot;参数绑定异常&quot;, e);        return wrapperBindingResult(e.getBindingResult(), request);    }    /**     * 参数校验异常，将校验失败的所有异常组合成一条错误信息     */    @ExceptionHandler({            MethodArgumentNotValidException.class// 方法参数无效    })    @ResponseBody    public ErrorResponse handleValidException(MethodArgumentNotValidException e, WebRequest request) {        log.error(&quot;参数校验异常&quot;, e);        return wrapperBindingResult(e.getBindingResult(), request);    }    /**     * 包装绑定异常结果     */    private ErrorResponse wrapperBindingResult(BindingResult bindingResult, WebRequest request) {        final List&lt;String&gt; errorDesc = new ArrayList&lt;&gt;();        for (ObjectError error : bindingResult.getAllErrors()) {            final StringBuilder msg = new StringBuilder();            if (error instanceof FieldError) {                msg.append(((FieldError) error).getField()).append(&quot;: &quot;);            }            msg.append(error.getDefaultMessage() == null ? &quot;&quot; : error.getDefaultMessage());            errorDesc.add(msg.toString());        }        final String desc = isProd ? getLocaleMessage(BAD_REQUEST.getCode(), &quot;&quot;) : String.join(&quot;, &quot;, errorDesc);        return new ErrorResponse(BAD_REQUEST.getCode(), desc, request);    }    /**     * 业务异常     */    @ExceptionHandler(value = CodeBaseException.class)    @ResponseBody    public ErrorResponse handleBusinessException(CodeBaseException e, WebRequest request) {        log.error(&quot;业务异常：&quot; + e.getMessage(), e);        final ResponseEnum anEnum = e.getAnEnum();        return new ErrorResponse(anEnum.getCode(), anEnum.getLocaleMessage(e.getArgs()), request);    }    /**     * 未定义异常     */    @ExceptionHandler(value = Exception.class)    @ResponseBody    public ErrorResponse handleExceptionInternal(Exception e, WebRequest request) {        log.error(&quot;未捕捉异常：&quot; + e.getMessage(), e);        final Integer code = INTERNAL_SERVER_ERROR.getCode();        return new ErrorResponse(code, getLocaleMessage(code, e.getMessage()), request);    }    private String getLocaleMessage(Integer code, String defaultMsg) {        try {            return messageSource.getMessage(&quot;&quot; + code, null, defaultMsg, LocaleContextHolder.getLocale());        } catch (Throwable t) {            log.warn(&quot;本地化异常消息发生异常: {}&quot;, code);            return defaultMsg;        }    }}</code></pre><p>从上面两个类可以看出，比较核心的是这么几个注解：</p><ul><li>@ExceptionHandle：负责处理controller标注的类中抛出的异常的注解</li><li>@RestControllerAdvice：能够将@ExceptionHandler标注的方法集中到一个地方进行处理的注解，这个注解是复合注解，实现了<code>@ControllerAdvice</code>和<code>@ResponseBody</code>的功能。</li></ul><p>借用谭朝红博文中的图片（蓝色箭头表示正常的请求和响应，红色箭头表示发生异常的请求和响应）：</p><p><img src="http://static.howardliu.cn/springboot/1141452688-5ce176fbd4a9b_articlex.png" alt="异常信息处理类"></p><h2 id="写个Demo测试一下"><a href="#写个Demo测试一下" class="headerlink" title="写个Demo测试一下"></a>写个Demo测试一下</h2><p>接下来我们写个demo测试一下是否能够实现异常的优雅响应：</p><pre><code class="java">@RestController@RequestMapping(&quot;index&quot;)@Slf4jpublic class IndexController {    private final IndexService indexService;    public IndexController(final IndexService indexService) {        this.indexService = indexService;    }    @GetMapping(&quot;hello1&quot;)    public Response&lt;String&gt; hello1() {        Response&lt;String&gt; response = new Response&lt;&gt;();        try {            response.setCode(200);            response.setDesc(&quot;请求成功&quot;);            response.setData(indexService.hello());        } catch (Exception e) {            log.error(&quot;hello1方法请求异常&quot;, e);            response.setCode(500);            response.setDesc(&quot;请求异常:&quot; + e.getMessage());        } finally {            log.info(&quot;执行controller的finally结构&quot;);        }        return response;    }    @GetMapping(&quot;hello2&quot;)    public Response&lt;String&gt; hello2(@RequestParam(&quot;ex&quot;) String ex) {        switch (ex) {            case &quot;ex1&quot;:                throw new CodeBaseException(CommonResponseEnum.USER_NOT_FOUND, &quot;用户信息不存在&quot;);            case &quot;ex2&quot;:                throw new CodeBaseException(CommonResponseEnum.MENU_NOT_FOUND, &quot;菜单信息不存在&quot;);            case &quot;ex3&quot;:                throw new CodeBaseException(CommonResponseEnum.ILLEGAL_ARGUMENT, &quot;请求参数异常&quot;);            case &quot;ex4&quot;:                throw new CodeBaseException(CommonResponseEnum.DATA_NOT_FOUND, &quot;数据不存在&quot;);        }        throw new CodeBaseException(INTERNAL_ERROR, new Object[]{ex}, &quot;请求异常&quot;, new RuntimeException(&quot;运行时异常信息&quot;));    }}</code></pre><p>启动服务之后，传入不同参数获取不同的异常信息：</p><pre><code class="javascript">// 请求 /index/hello2?ex=ex1{    &quot;code&quot;: 4104,    &quot;desc&quot;: &quot;User Not Found&quot;,    &quot;timestamp&quot;: &quot;2020-10-10T05:58:39.433+00:00&quot;,    &quot;path&quot;: &quot;/index/hello2&quot;}// 请求 /index/hello2?ex=ex2{    &quot;code&quot;: 4204,    &quot;desc&quot;: &quot;Menu Not Found&quot;,    &quot;timestamp&quot;: &quot;2020-10-10T06:00:34.141+00:00&quot;,    &quot;path&quot;: &quot;/index/hello2&quot;}// 请求 /index/hello2?ex=ex3{    &quot;code&quot;: 4000,    &quot;desc&quot;: &quot;[DEFAULT] Illegal Arguments&quot;,    &quot;timestamp&quot;: &quot;2020-10-10T06:00:44.233+00:00&quot;,    &quot;path&quot;: &quot;/index/hello2&quot;}// 请求 /index/hello2?ex=ex4{    &quot;code&quot;: 4004,    &quot;desc&quot;: &quot;对应数据未找到&quot;,    &quot;timestamp&quot;: &quot;2020-10-10T06:00:54.178+00:00&quot;,    &quot;path&quot;: &quot;/index/hello2&quot;}</code></pre><p>附上文中的代码：<a href="https://github.com/howardliu-cn/effective-spring/tree/main/spring-exception-handler" target="_blank" rel="noopener">https://github.com/howardliu-cn/effective-spring/tree/main/spring-exception-handler</a>，收工。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/108996938" target="_blank" rel="noopener">SpringBoot 实战：如何优雅的处理异常</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      作为后台服务，能够正确的处理程序抛出的异常，并返回友好的异常信息是非常重要的，毕竟我们大部分代码都是为了 处理异常情况。而且，统一的异常响应，有助于客户端理解服务端响应，并作出正确处理，而且能够提升接口的服务质量。
    
    </summary>
    
    
      <category term="springboot" scheme="https://www.howardliu.cn/categories/springboot/"/>
    
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="实战" scheme="https://www.howardliu.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：一招实现结果的优雅响应</title>
    <link href="https://www.howardliu.cn/springboot-action-gracefully-response/"/>
    <id>https://www.howardliu.cn/springboot-action-gracefully-response/</id>
    <published>2020-08-12T12:26:56.000Z</published>
    <updated>2020-08-12T12:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/springboot/red-panda-5475574_1280.png" alt="SpringBoot 实战：一招实现结果的优雅响应"></p><p>因为最近事比较杂，很多文章都没有连续性，想到哪写到哪，大家海涵，后面理清思绪，会连贯输出，形成系列，供大家找茬。</p><p>今天说一下 Spring Boot 如何实现优雅的数据响应：统一的结果响应格式、简单的数据封装。</p><a id="more"></a><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>无论系统规模大小，大部分 Spring Boot 项目是提供 Restful + json 接口，供前端或其他服务调用，格式统一规范，是程序猿彼此善待彼此的象征，也是减少联调挨骂的基本保障。</p><p>通常响应结果中需要包含业务状态码、响应描述、响应时间戳、响应内容，比如：</p><pre><code class="json">{  &quot;code&quot;: 200,  &quot;desc&quot;: &quot;查询成功&quot;,  &quot;timestamp&quot;: &quot;2020-08-12 14:37:11&quot;,  &quot;data&quot;: {    &quot;uid&quot;: &quot;1597242780874&quot;,    &quot;name&quot;: &quot;测试 1&quot;  }}</code></pre><p>对于业务状态码分为两个派系：一个是推荐使用 HTTP 响应码作为接口业务返回；另一种是 HTTP 响应码全部返回 200，在响应体中通过单独的字段表示响应状态。两种方式各有优劣，个人推荐使用第二种，因为很多 Web 服务器对 HTTP 状态码有拦截处理功能，而且状态码数量有限，不够灵活。比如返回 200 表示接口处理成功且正常响应，现在需要有一个状态码表示接口处理成功且正常响应，但是请求数据状态不对，可以返回 2001 表示。</p><h2 id="自定义响应体"><a href="#自定义响应体" class="headerlink" title="自定义响应体"></a>自定义响应体</h2><p>定义一个数据响应体是返回统一响应格式的第一步，无论接口正常返回，还是发生异常，返回给调用方的结构格式都应该不变。给出一个示例：</p><pre><code class="java">@ApiModel@Datapublic class Response&lt;T&gt; {    @ApiModelProperty(value = &quot;返回码&quot;, example = &quot;200&quot;)    private Integer code;    @ApiModelProperty(value = &quot;返回码描述&quot;, example = &quot;ok&quot;)    private String desc;    @ApiModelProperty(value = &quot;响应时间戳&quot;, example = &quot;2020-08-12 14:37:11&quot;)    private Date timestamp = new Date();    @ApiModelProperty(value = &quot;返回结果&quot;)    private T data;}</code></pre><p>这样，只要在 Controller 的方法返回<code>Response</code>就可以了，接口响应就一致了，但是这样会形成很多格式固定的代码模板，比如下面这种写法：</p><pre><code class="java">@RequestMapping(&quot;hello1&quot;)public Response&lt;String&gt; hello1() {    final Response&lt;String&gt; response = new Response&lt;&gt;();    response.setCode(200);    response.setDesc(&quot;返回成功&quot;);    response.setData(&quot;Hello, World!&quot;);    return response;}</code></pre><p>调用接口响应结果为：</p><pre><code class="json">{  &quot;code&quot;: 200,  &quot;desc&quot;: &quot;返回成功&quot;,  &quot;timestamp&quot;: &quot;2020-08-12 14:37:11&quot;,  &quot;data&quot;: &quot;Hello, World!&quot;}</code></pre><p>这种重复且没有技术含量的代码，怎么能配得上程序猿这种优（lan）雅（duo）的生物呢？最好能在返回响应结果的前提下，减去那些重复的代码，比如：</p><pre><code class="java">@RequestMapping(&quot;hello2&quot;)public String hello2() {    return &quot;Hello, World!&quot;;}</code></pre><p>这就需要借助 Spring 提供的<code>ResponseBodyAdvice</code>来实现了。</p><h2 id="全局处理响应数据"><a href="#全局处理响应数据" class="headerlink" title="全局处理响应数据"></a>全局处理响应数据</h2><p>先上代码：</p><pre><code class="java">/** * &lt;br&gt;created at 2020/8/12 * * @author www.howardliu.cn * @since 1.0.0 */@RestControllerAdvicepublic class ResultResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; {    @Override    public boolean supports(final MethodParameter returnType, final Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {        return !returnType.getGenericParameterType().equals(Response.class);// 1    }    @Override    public Object beforeBodyWrite(final Object body, final MethodParameter returnType, final MediaType selectedContentType,                                  final Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,                                  final ServerHttpRequest request, final ServerHttpResponse response) {        if (body == null || body instanceof Response) {            return body;        }        final Response&lt;Object&gt; result = new Response&lt;&gt;();        result.setCode(200);        result.setDesc(&quot;查询成功&quot;);        result.setData(body);        if (returnType.getGenericParameterType().equals(String.class)) {// 2            ObjectMapper objectMapper = new ObjectMapper();            try {                return objectMapper.writeValueAsString(result);            } catch (JsonProcessingException e) {                throw new RuntimeException(&quot;将 Response 对象序列化为 json 字符串时发生异常&quot;, e);            }        }        return result;    }}/** * &lt;br&gt;created at 2020/8/12 * * @author www.howardliu.cn * @since 1.0.0 */@RestControllerpublic class HelloWorldController {    @RequestMapping(&quot;hello2&quot;)    public String hello2() {        return &quot;Hello, World!&quot;;    }    @RequestMapping(&quot;user1&quot;)    public User user1() {        User u = new User();        u.setUid(System.currentTimeMillis() + &quot;&quot;);        u.setName(&quot;测试1&quot;);        return u;    }}</code></pre><p>上面代码是实现了 Spring <code>ResponseBodyAdvice</code>类的模板方式，按照 Spring 的要求实现就行。只有两个需要特别注意的地方，也就是代码中标注 1 和 2 的地方。</p><p>首先说 1 这一行，也就是<code>supports</code>方法，这个方法是校验是否需要调用<code>beforeBodyWrite</code>方法的前置判断，返回<code>true</code>则执行<code>beforeBodyWrite</code>方法，这里根据 Controller 方法返回类型来判断是否需要执行<code>beforeBodyWrite</code>，也可以一律返回<code>true</code>，在后面判断是否需要进行类型转换。</p><p>然后重点说下 2 这一行，这行是坑，是大坑，如果对 Spring 结构不熟悉的，绝对会在这徘徊许久，不得妙法。</p><p>代码 2 这一行是判断<code>Controller</code>的方法是否返回的是<code>String</code>类型的结果，如果是，将返回的对象序列化之后返回。</p><p>这是因为<code>Spring</code>对<code>String</code>类型的响应类型单独处理了，使用<code>StringHttpMessageConverter</code>类进行数据转换。在处理响应结果的时候，会在方法<code>getContentLength</code>中计算响应体大小，其父类方法定义是<code>protected Long getContentLength(T t, @Nullable MediaType contentType)</code>，而<code>StringHttpMessageConverter</code>将方法重写为<code>protected Long getContentLength(String str, @Nullable MediaType contentType)</code>，第一个参数是响应对象，固定写死是<code>String</code>类型，如果我们强制返回<code>Response</code>对象，就会报<code>ClassCastException</code>。</p><p>当然，直接返回<code>String</code>的场景不多，这个坑可能会在某天特殊接口中突然出现。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>上面只是展示了<code>ResponseBodyAdvice</code>类最简单的应用，我们还可以实现更多的扩展使用。比如：</p><ol><li>返回请求ID：这个需要与与<code>RequestBodyAdvice</code>联动，获取到请求ID后，在响应是放在响应体中；</li><li>结果数据加密：通过<code>ResponseBodyAdvice</code>实现响应数据加密，不会侵入业务代码，而且可以通过注解方式灵活处理接口的加密等级；</li><li>有选择的包装响应体：比如定义注解<code>IgnoreResponseWrap</code>，在不需要包装响应体的接口上定义，然后在<code>supports</code>方法上判断方法的注解即可，比如：</li></ol><pre><code class="java">@Overridepublic boolean supports(final MethodParameter returnType, final Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {    final IgnoreResponseWrap[] declaredAnnotationsByType = returnType.getExecutable().getDeclaredAnnotationsByType(IgnoreResponseWrap.class);    return !(declaredAnnotationsByType.length &gt; 0 || returnType.getGenericParameterType().equals(Response.class));}</code></pre><p>很多其他玩法就不一一列举了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面说了正常响应的数据，只做到了一点优雅，想要完整，还需要考虑接口异常情况，总不能来个大大的<code>try/catch/finally</code>包住业务逻辑吧，那也太丑了。后面会再来一篇，重点说说接口如何在出现异常时，也能返回统一的结果响应。</p><p>本文只是抛出一块砖，玉还得自己去找。</p><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/107970059" target="_blank" rel="noopener">SpringBoot 实战：一招实现结果的优雅响应</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      无论系统规模大小，大部分 Spring Boot 项目是提供 Restful + json 接口，供前端或其他服务调用，格式统一规范，是程序猿彼此善待彼此的象征，也是减少联调挨骂的基本保障。
    
    </summary>
    
    
      <category term="springboot" scheme="https://www.howardliu.cn/categories/springboot/"/>
    
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="实战" scheme="https://www.howardliu.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>系统设计系列之如何设计一个短链服务</title>
    <link href="https://www.howardliu.cn/tiny-url-system/"/>
    <id>https://www.howardliu.cn/tiny-url-system/</id>
    <published>2020-07-28T14:11:59.000Z</published>
    <updated>2020-07-28T14:11:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/system-design/snail-5353573_1920.jpg" alt="系统设计系列之如何设计一个短链服务"></p><p>短链服务的鼻祖是 <a href="https://tinyurl.com/" target="_blank" rel="noopener">TinyURL</a>，是最早提供短链服务的网站，目前国内也有很多短链服务：新浪（t.cn）、百度（dwz.cn）、腾讯（url.cn）等等。</p><p>不得不问一句，为什么要用短链？这个问题的另外一层意思是，短链服务有必要存在吗？</p><p>套用万金油答案：存在即合理。</p><a id="more"></a><h2 id="短链服务存在的合理性"><a href="#短链服务存在的合理性" class="headerlink" title="短链服务存在的合理性"></a>短链服务存在的合理性</h2><p>我们先说说短链服务存在的合理性。</p><p>短链唯一的一个优点是<strong>短</strong>。</p><p>微博的早期用户都知道，每条微博只能限制在 140 个字以内，如果想要分享一个链接，就需要减少描述的文字。</p><p>同样，如果想要在营销短信中放入一个链接，就需要考虑成本问题。如果是早期的手机，还需要考虑用户可能接收到三条断开的短信，严重影响短信触达和点击。</p><p>这个情况下，如果链接足够短，那其他内容就可以更加丰富了。但是我们可能根据不同业务定义不同长度的链接，而且为了满足其他需求（比如，统计营销数据），还会在普通链接上增加参数。因此短链由此而生，通过重定向跳转，通过一个很短的链接代替一条其他链接，比如只需要通过 <a href="http://t.cn/A6ULvJho" target="_blank" rel="noopener">http://t.cn/A6ULvJho</a> 这种 20 个字符的链接，就可以重定向到长度为 146 个字符的原始链接 <a href="https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html?spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989">https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html?spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989</a>。</p><p>上面的两个例子证明了短链有存在的价值，我们总结几个短链的附加用处：</p><ol><li><p>发送营销短信，更省钱：链接变短，短信长度就变小，所需要支付的短信费用就减少了，比如上面短链 20 个字符，原始链接 146 个字符，差出来的都是钱啊。</p></li><li><p>转为二维码，可识别度更高，比如下面两个二维码的图片，相同尺寸，因为内容数量的不同，单元格的密度也就随之不同</p><p><img src="http://static.howardliu.cn/thinking/tinyurl-1.png" alt="http://t.cn/A6ULvJho"><br><img src="http://static.howardliu.cn/thinking/tinyurl-2.png" alt="https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html??spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989"></p></li><li><p>灵活可配置，因为短链跳转原始链接经过了一次重定向，如果在某个时间发现原始链接中有问题，或者需要跳转到其他地方，可以通过修改重定向的目标地址就可以了。这点对于线下物料投放非常有利，比如已经投放了二维码物料，这个时候发现期望跳转到其他网站或者活动，只需要修改短链的目标地址就行，而不需要全部替换已经投放的物料。</p></li></ol><h2 id="短链的原理"><a href="#短链的原理" class="headerlink" title="短链的原理"></a>短链的原理</h2><p>其实前面已经提到，短链是通过服务器重定向到原始链接实现的。我们来观察下新浪微博的短链，控制台执行命令<code>curl -i http://t.cn/A6ULvJho</code>，结果如下：</p><pre><code class="HTML">HTTP/1.1 302 FoundDate: Thu, 30 Jul 2020 13:59:13 GMTContent-Type: text/html;charset=UTF-8Content-Length: 328Connection: keep-aliveSet-Cookie: aliyungf_tc=AQAAAJuaDFpOdQYARlNadFi502DO2kaj; Path=/; HttpOnlyServer: nginxLocation: https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html??spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Moved Temporarily&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY BGCOLOR=&quot;#FFFFFF&quot; TEXT=&quot;#000000&quot;&gt;&lt;H1&gt;Moved Temporarily&lt;/H1&gt;The document has moved &lt;A HREF=&quot;https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html??spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989&quot;&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt;</code></pre><p>从上面的信息可以看出来，新浪做了 302 跳转，同时为了兼容性，还返回用于手动调整的 HTML 内容。整个交互流程如下：</p><p><img src="http://static.howardliu.cn/thinking/tinyurl-3.png" alt="短链跳转流程"></p><h2 id="短链生成方式"><a href="#短链生成方式" class="headerlink" title="短链生成方式"></a>短链生成方式</h2><p>根据 <a href="https://www.worldwidewebsize.com" target="_blank" rel="noopener">网页数量统计</a> 信息，目前全球有 58 亿的网页，Java 中 int 取值最多是 2^32 = 4294967296 &lt; 43 亿 &lt; 58 亿，long 取值是 2^64 &gt; 58 亿。所以如果是用数字的话，int 勉强能够支撑（毕竟不是所有网址都会调用短链服务创建短链），使用 long 就比较保险，但会造成空间浪费，具体使用哪种类型，需要根据业务自己判断了。</p><p>新浪微博使用 8 位字符串表示原始链接，这种字符串可以理解为数字的 62 进制表示，62^8 = 3521614606208 &gt; 3521 亿 &gt; 58 亿，也就是可以解决目前全球已知的网址。62 进制就是由 10 个数字 + (a-z)26 个小写字母 + (A-Z)26 个大写字母组成的数。</p><h3 id="生成方式1：Hash"><a href="#生成方式1：Hash" class="headerlink" title="生成方式1：Hash"></a>生成方式1：Hash</h3><p>对原始链接取 Hash 值，是一种比较简单的思路。有很多现成的算法可以实现，但是有个避不开的问题就是：Hash 碰撞，所以选一个碰撞率低的算法比较重要。</p><p>推荐 <a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">MurmurHash 算法</a>，这种算法是一种非加密型哈希函数，适用于一般的哈希检索操作，目前 Redis，Memcached，Cassandra，HBase，Lucene 都在用这种算法。</p><p>借助 Guava 中的 MurmurHash 实现：</p><pre><code class="java">final String url = &quot;https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html?spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989&quot;;final HashFunction hf = Hashing.murmur3_128();final HashCode hashCode = hf.newHasher().putString(url, Charsets.UTF_8).hash();final int hashCodeAsInt = hashCode.asInt();// 这里选择返回 int 值，也可以选择返回 long 值System.out.println(hashCodeAsInt);// 输出的结果是：1810437348，转换成 62 进制是：1Ywpso</code></pre><p>对于碰撞问题，最简单的一种思路是，如果发生碰撞，就给原始 URL 附加上特殊字符串，直到躲开碰撞为止。具体操作如下图：</p><p><img src="http://static.howardliu.cn/system-design/murmurhash-bloom.png" alt="Hash+Bloom"></p><h3 id="生成方式2：统一发号器"><a href="#生成方式2：统一发号器" class="headerlink" title="生成方式2：统一发号器"></a>生成方式2：统一发号器</h3><p>这个就是不管来的是什么，通过集中的统一发号器，分配一个 ID，这个 ID 就是短链的内容，比如第一个来的就是<a href="https://tinyurl.com/1，第二个就是https://tinyurl.com/2，以此类推。当然可能一些分布式ID算法上来就是很长的一个序号了。为了获取更短路，还可以将其转为" target="_blank" rel="noopener">https://tinyurl.com/1，第二个就是https://tinyurl.com/2，以此类推。当然可能一些分布式ID算法上来就是很长的一个序号了。为了获取更短路，还可以将其转为</a> 62 进制字符串。</p><ol><li>Redis 自增：Redis性能好，单机就能支撑10W+请求，如果作为发号器，需要考虑Redis持久化和灾备。</li><li>MySQL 自增主键：这种方案和Redis的方案类似，是利用数据库自增主键的提醒实现，保证ID不重复且连续自动创建。</li><li>Snowflake：这是一种目前应用比较广的ID序列生成算法，美团的Leaf是对这种算法的封装升级服务。但是这个算法依赖于服务器时钟，如果有时钟回拨，可能会有ID冲突。（有人会较真毫秒中的序列值是这个算法的瓶颈，话说回来了，这个算法只是提供了一种思路，如果觉得序列长度不够，自己加就好，但是每秒百万级的服务真的又这么多吗？）</li><li>等等。。。</li></ol><blockquote><p>后续会有一篇单独介绍统一发号器的文章，完后会修改这里，并附上链接，或者你也可以关注我（微信号：看山的小屋），获取第一手资料。</p></blockquote><p>对于统一发号器这种方式，还需要解决的一个问题是：如果同一个原始链接，应该返回相同的短链还是不同的短链？</p><p>答案是根据用户、地点等维度，相同的原始链接，返回不同的短链。如果判断维度都相同，则返回相同短链。这样做的好处是，我们可以根据短链的点击、请求信息，做数据统计。对于短链，我们牺牲的只是一些存储和运算，但是收集的信息却是无价的。</p><h2 id="存储短链"><a href="#存储短链" class="headerlink" title="存储短链"></a>存储短链</h2><p>一般这种数据的存储无非就两种：关系型数据库或NoSQL数据库。有了上面的创建逻辑，存储就是水到渠成的了。下面给出MySQL存储的建表语句：</p><pre><code class="sql">CREATE TABLE IF NOT EXISTS tiny_url(    sid                INT AUTO_INCREMENT PRIMARY KEY,    create_time        DATETIME  DEFAULT CURRENT_TIMESTAMP NULL,    update_time        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP,    version            INT       DEFAULT 0                 NULL COMMENT &#39;版本号&#39;,    tiny_url           VARCHAR(10)                         NULL COMMENT &#39;短链&#39;,    original_url       TEXT                                NOT NULL COMMENT &#39;原始链接&#39;,    # 其他附加信息    creator_ip         INT       DEFAULT 0                 NOT NULL,    creator_user_agent TEXT                                NOT NULL,    # 用户其他信息，用于后续统计，对于这些数据，只要存储影响创建短链的必要字段就行，其他的都可以直接发送到数据服务中    instance_id        INT       DEFAULT 0                 NOT NULL,    # 创建短链服务实例ID    state              TINYINT   DEFAULT 1                 NULL COMMENT &#39;-1无效 1有效&#39;);</code></pre><p>再啰嗦一句，存储需要考虑数据量级，提前规划是否需要分表分库。</p><h2 id="短链请求"><a href="#短链请求" class="headerlink" title="短链请求"></a>短链请求</h2><p>存储完成后，接下来就该使用了。</p><p>通常的做法是会根据请求的短链字符串，从存储中找到数据，然后返回HTTP重定向到原始地址。如果存储使用关系型数据库，对于短链字段一般需要创建索引，而且为了避免数据库成为瓶颈，数据库前面还会通过缓存铺路。而且为了提高缓存合理使用，一般通过LRU算法淘汰非热点短链数据。流程如下图：</p><p><img src="http://static.howardliu.cn/system-design/call-tiny-url.png" alt="短链请求"></p><p>图中的布隆过滤器是为了防止缓存击穿，造成服务器压力过大。</p><p>这里还有一个问题：HTTP返回重定向编码时使用301还是302，为什么新浪微博会返回302，而不是更加符合语义的 301 跳转？（对于 HTTP 状态码不太了解的同学，可以从 <a href="https://www.howardliu.cn/the-introduction-of-http-status-codes/">《HTTP 状态码总结》</a> 获得更多信息）</p><ul><li>301，代表永久重定向。也就是说，浏览器第一次请求拿到重定向地址后，以后的请求，都是直接从浏览器缓存中获取重定向地址，不会再请求短链服务。这样可以有效减少服务请求数，降低服务器负载，但是因为后续浏览器不再向后端发送请求，因此获取不到真实的点击数。</li><li>302，代表临时重定向。也就是说，每次浏览器都会向服务器发起请求获取新的地址，虽然会给服务器增加压力，但在硬件过剩的今天，这点压力比起数据简直不值一提。所以，302 重定向才是短链服务的首选。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>短链服务其实比较简单，没有太多的业务逻辑，主要考察对于分布式系统常用设计的理解，也是经常被用在面试过程中的一道题。这里只是提供大家一些设计思路，文中涉及到的发号器（分布式ID）、布隆过滤器、MurmurHash等都没有太过深入，因为每一个都不是三言两语可以说明白的，需要大家自行解决了。</p><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/tiny-url-system/">系统设计系列之如何设计一个短链服务</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/107754046" target="_blank" rel="noopener">系统设计系列之如何设计一个短链服务</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      短链服务其实比较简单，没有太多的业务逻辑，主要考察对于分布式系统常用设计的理解，也是经常被用在面试过程中的一道题。
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式" scheme="https://www.howardliu.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="架构设计" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="短链服务" scheme="https://www.howardliu.cn/tags/%E7%9F%AD%E9%93%BE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何在微服务团队中高效使用 Git 管理代码？</title>
    <link href="https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/"/>
    <id>https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/</id>
    <published>2020-07-22T13:38:11.000Z</published>
    <updated>2020-07-24T13:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/git/sunset-5371719_1920.jpg" alt="如何在微服务团队中高效使用 Git 管理代码"></p><p>用了 Git 多年，优势和挑战都是深有体会。</p><p>话不多说，直接上问题：如何在微服务团队中高效使用 Git 管理代码？</p><p>继续不多话，直接上答案：分支管理。</p><a id="more"></a><p>Git 的分支管理有很多实践，有些是从 SVN 类的集中式版本管理工具继承的，有些是根据 Git 自己的特性总结的，目前市面上比较有名的三种 Git 分支管理模型是：</p><ul><li>TrunkBased：主干在手，天下我有。所有代码都往主干上招呼，发版也只用主干。</li><li>GitFlow：严谨、规范、难用，主要是记不住该往哪个分支合并了。</li><li>AoneFlow：前两种都不行，那就借鉴各自的优点，达到阴阳平衡，中庸也。</li></ul><h2 id="TrunkBased"><a href="#TrunkBased" class="headerlink" title="TrunkBased"></a>TrunkBased</h2><p>TrunkBased，又叫主干开发，有一个网站专门介绍这种开发方式：<a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">Trunk Based Development</a>。</p><p>TrunkBased 是持续集成思想所崇尚的工作方式，它由单个主干分支和许多发布分支组成，每个发布分支在特定版本的提交点上从主干创建出来，用来进行上线部署和 Hotfix。在 TrunkBased 模式中，没有显性的特性分支。当然实际上 Git 的分布式特征天生允许每个人有本地分支，TrunkBased 也并非排斥短期的特性分支存在，只不过在说这种模式的时候，大家通常都不会明确强调它罢了。</p><p><img src="https://static.howardliu.cn/git/trunk-based.jpg" alt="TrunkBased"></p><p>使用主干开发后，我们的代码库原则上就只能有一个 Trunk 分支即 master 分支了，所有新功能的提交也都提交到 master 分支上，保证每次提交后 master 分支都是可随时发布的状态。没有了分支的代码隔离，测试和解决冲突都变得简单，持续集成也变得稳定了许多。</p><p>但是这种方案缺点也比较明显，如果大家都在主干进行开发，当代码提交合并时，将会异常痛苦，一不小心就会出现冲突。而且，这种因为这种方式没有明显的特性分支，想要移除已经上线的特性会变得非常困难。（如果你说把不要的功能注释，重新发版，那就当我什么也没说。）还有一种方案是引入特性开关，通过开关控制特性是否启用和关闭，但是增加开关就引入了复杂性，引入复杂性就引入了出 bug 的风险，毕竟多增加的每行代码都有可能是一个新的 bug。</p><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h2><p>GitFlow 来源于 Vincent Driessen 提出的 <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a>，整体来说，是一套完善的版本管理流程。缺点就是太过严格，不太适合喜欢自由而且懒的程序猿。当然，在程序猿这种物种中，没有完美的解决方案，总有那么一小撮人会觉得不好。参考 Ant、Maven 和 Gradle。</p><p>先上图：</p><p><img src="https://static.howardliu.cn/git/gitflow.png" alt="GitFlow：A successful Git branching model"></p><p>GitFlow 常用分支：</p><ul><li>主干分支（<code>master</code>）：最近发布到生产环境代码的分支，这个分支只能从其他分支合并，不能再 Master 分支直接修改。</li><li>主开发分支（<code>develop</code>）：包含所有要发布到下一个 Release 版本的代码。可以在 Develop 直接开发，也可以将 Feature 的特性代码合并到 Develop 中。<br><img src="https://static.howardliu.cn/git/gitflow-develop.png" alt="主开发分支"></li><li>特性分支（<code>feature/*</code>）：功能项开发分支，以<code>feature/</code>开头命名分支，当功能项开发完成，将被合并到主开发分支进入下一个 Release，合并完分支后一般会删掉这个特性分支。<br><img src="https://static.howardliu.cn/git/gitflow-feature.png" alt="特性分支"></li><li>发布分支（<code>release/*</code>）：基于主开发分支创建的一个发布分支，以<code>release/</code>开头命名分支，用于测试、bug 修复及上线。完成后，合并到主干分支和主开发分支，同时在主干分支上打个 Tag 记住 Release 版本号，然后可以删除发布分支。<br><img src="https://static.howardliu.cn/git/gitflow-release.png" alt="发布分支"></li><li>热修复分支（<code>hotfix/*</code>）：用于解决线上 Release 版本出现的 bug，以<code>hotfix/</code>开头命名分支，修复线上问题，完成后，合并到主干分支和主开发分支，同时在主干分支上打个 tag。<br><img src="https://static.howardliu.cn/git/gitflow-hotfix.png" alt="热修复分支"></li></ul><p>根据上面描述，GitFlow 是一套完整的从开发到生产的管理方式，但是各种分支来回切换及合并，很容易把人搞晕，所以用的人也是越来越少。</p><h2 id="AoneFlow"><a href="#AoneFlow" class="headerlink" title="AoneFlow"></a>AoneFlow</h2><p>AoneFlow 是阿里内部的一套版本管理模型，兼顾了 TrunkBased 易于持续集成和 GitFlow 易于管理需求的特点，又规避了 GitFlow 分支繁琐的缺点，也就是中庸。</p><p>AoneFlow 使用三个分支：主干分支（<code>master</code>）、特性分支（<code>feature/*</code>）、发布分支（<code>release/*</code>），以及三条原则：</p><p><strong>规则一，开始工作前，从主干分支创建特性分支。</strong></p><p>这条规则借鉴了 GitFlow，每当开始一件新的工作项（比如新的功能或是待解决的问题，可以是一个人完成，或是多个人协作完成）时，从代表最新已发布版本的主干分支上创建一个通常以<code>feature/</code>前缀命名的特性分支，然后在这个分支上提交代码修改。也就是说，每个工作项对应一个特性分支，所有的修改都不允许直接提交到主干。</p><p><img src="https://static.howardliu.cn/git/aoneflow-feature.jpg" alt="从主干创建特性分支"></p><p>特性分支不止承担了新功能，也是待解决问题的分支。对于我们团队，为了避免歧义，会将新功能以<code>feature/</code>为前缀，待解决问题以<code>hotfix/</code>为前缀，除了名称外，其他都按照规则一执行。</p><p><strong>规则二，通过合并特性分支，形成发布分支。</strong></p><p>GitFlow 先将已经完成的特性分支合并回主干分支和主开发分支，然后在主干分支上打 Tag 记录发布信息。TrunkBased 是等所有需要的特性都在主干分支上开发完成，然后从主干分支的特定位置拉出发布分支。而 AoneFlow 的思路是，从主干上拉出一条新分支，将所有本次要集成或发布的特性分支依次合并过去，从而得到发布分支，发布分支通常以<code>release/</code>前缀命名。</p><p><img src="https://static.howardliu.cn/git/aoneflow-release.jpg" alt="合并特性分支，形成发布分支"></p><p>我们可以将每条发布分支与具体的环境相对应，<code>release/test</code>对应部署测试环境，<code>release/prod</code>对应线上正式环境等，并与流水线工具相结合，串联各个环境上的代码质量扫描和自动化测试关卡，将产出的部署包直接发布到相应环境上。</p><p>另外，发布分支的特性组成是动态的，调整起来特别容易。在一些市场瞬息万变的互联网企业，以及采用“敏捷运作”的乙方企业经常会遇到这种情况，已经完成就等待上线的需求，随时可能由于市场策略调整或者甲方的一个临时决定，其中某个功能忽然要求延迟发布或者干脆不要了。再或者是某个特性在上线前发现存在严重的开发问题，需要排除。按往常的做法，这时候就要来手工“剔代码”了，将已经合并到开发分支或者主干分支的相关提交一个个剔除出去，做过的同学都知道很麻烦。在 AoneFlow 模式下，重建发布分支，只需要将原本的发布分支删掉，从主干拉出新的同名发布分支，再把需要保留的各特性分支合并过来就搞定，而且代码是干净的，没有包含不必要的特性。</p><p>此外，发布分支之间是松耦合的，这样就可以有多个集成环境分别进行不同的特性组合的集成测试，也能方便的管理各个特性进入到不同环境上部署的时机。松耦合并不代表没有相关性，由于测试环境、集成环境、预发布环境、灰度环境和线上正式环境等发布流程通常是顺序进行的，在流程上可以要求只有通过前一环境验证的特性，才能传递到下一个环境做部署，形成漏斗形的特性发布流。当然，这种玩法比较适合有完整开发集成平台的公司，小团队玩不转，比如我们团队就玩不动这种高级玩法。</p><p><strong>规则三，发布到线上正式环境后，合并相应的发布分支到主干，在主干添加 Tag，同时删除该发布分支关联的特性分支。</strong></p><p>当一条发布分支上的流水线完成了一次线上正式环境的部署，就意味着相应的功能真正的发布了，此时应该将这条发布分支合并到主干。为了避免在代码仓库里堆积大量历史上的特性分支，还应该清理掉已经上线部分特性分支。与 GitFlow 相似，主干分支上的最新版本始终与线上版本一致，如果要回溯历史版本，只需在主干分支上找到相应的版本标签即可。</p><p><img src="https://static.howardliu.cn/git/aoneflow-master.jpg" alt="合并相应的发布分支到主干，在主干添加 Tag，同时删除该发布分支关联的特性分支"></p><p>除了基本规则，还有一些实际操作中不成文的技巧。比如上线后的热修复，正常的处理方法应该是，创建一条新的发布分支，对应线上环境（相当于 Hotfix 分支），同时为这个分支创建临时流水线，以保障必要的发布前检查和冒烟测试能够自动执行。</p><h2 id="再啰嗦几句废话"><a href="#再啰嗦几句废话" class="headerlink" title="再啰嗦几句废话"></a>再啰嗦几句废话</h2><p>不管哪种方式，既然存在，都会有一定合理性。所以，不管最终翻了哪个牌子，不是因为这个好看，而是因为这个更适合自己。</p><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/">如何在微服务团队中高效使用 Git 管理代码？</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/107570189" target="_blank" rel="noopener">如何在微服务团队中高效使用 Git 管理代码？</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      TrunkBased：主干在手，天下我有。所有代码都往主干上招呼，发版也只用主干。GitFlow：严谨、规范、难用，主要是记不住该往哪个分支合并了。AoneFlow：前两种都不行，那就借鉴各自的优点，达到阴阳平衡，中庸也。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Git" scheme="https://www.howardliu.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>IPv4 与 int 之间互相转换</title>
    <link href="https://www.howardliu.cn/convert-ipv4-to-int/"/>
    <id>https://www.howardliu.cn/convert-ipv4-to-int/</id>
    <published>2020-07-20T13:11:13.000Z</published>
    <updated>2020-07-20T13:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前数据存储设备越来越便宜，已经不存在为了节省空间而引入复杂计算的场景，但是有时候，将 IPv4 这种长字符串数据转换为数字，更加便于比较和查询。</p><a id="more"></a><h2 id="1-直接转换"><a href="#1-直接转换" class="headerlink" title="1. 直接转换"></a>1. 直接转换</h2><p>直接能够想到的方式是把网段之间的“.”去掉，组成一个长数字就行。但是在“255.255.255.255”地址时，去掉“.”的数字是255255255255，大于int能够表示的最大数字，所以，真正使用的时候，只能使用长整型Long型。但是这种方式有两个严重的问题：</p><ol><li>单向转换：只适合那种需要从 IPv4 到数字单向转换的场景，如果想要转回来，就不容易了，比如：“192.168.10.10”和“192.168.101.0”转换成数字都是1921681010，想要从数字转换会IP地址，就会有歧义，除非搭配某些约定规则才能实现</li><li>转换之后存在歧义：也是第一条中说的，两个IP地址转换得到同一个数字，如果在需要IP比较的场景，就容易出现问题了。</li></ol><h2 id="2-移位转换"><a href="#2-移位转换" class="headerlink" title="2. 移位转换"></a>2. 移位转换</h2><p>既然直接去掉“.”有歧义的问题，那就将4段数字分开存储，IPv4的某段数字取值范围是0~255，也就是2^8个数字，恰巧int类型占32个字节，那通过简单的移位和或运算，就能得到最后的结果，而且支持从int到IPv4的转换。</p><p>比如：192.168.30.68，计算结果就是：</p><pre><code class="java">192 &lt;&lt; 24 | 168 &lt;&lt; 16 | 30 &lt;&lt; 8 | 68 = 0b11000000101010000001111001000100 = -1062724028</code></pre><p>逆向转换就是：</p><pre><code class="java">((-1062724028 &gt;&gt; 24) &amp; 0xFF) + &quot;.&quot; + ((-1062724028 &gt;&gt; 16) &amp; 0xFF) + &quot;.&quot; + ((-1062724028 &gt;&gt; 8) &amp; 0xFF) + &quot;.&quot; + (-1062724028 &amp; 0xFF) = &quot;192.168.30.68&quot;</code></pre><p>所以第二种方式除了计算麻烦一些，可以完美解决第一种方式的两个问题。</p><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/convert-ipv4-to-int">IPv4 与 int 之间互相转换</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/107475967" target="_blank" rel="noopener">IPv4 与 int 之间互相转换</a></p>]]></content>
    
    <summary type="html">
    
      目前数据存储设备越来越便宜，已经不存在为了节省空间而引入复杂计算的场景，但是有时候，将 IPv4 这种长字符串数据转换为数字，更加便于比较和查询。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="ipv4" scheme="https://www.howardliu.cn/tags/ipv4/"/>
    
      <category term="int" scheme="https://www.howardliu.cn/tags/int/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：建造者模式</title>
    <link href="https://www.howardliu.cn/the-builder-pattern/"/>
    <id>https://www.howardliu.cn/the-builder-pattern/</id>
    <published>2020-03-22T10:11:21.000Z</published>
    <updated>2020-03-22T10:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/design-patterns/star-4903819_1920.jpg" alt="Design Patterns"></p><p>之前说过了<a href="https://www.howardliu.cn/singleton-pattern/">单例模式</a>，这周想说说建造者模式，它是另外一个比较常用的创建型设计模式。</p><p>每种设计模式的出现，都是为了解决一些编程不够优雅的问题，建造者模式也是这样。</p><p>维基百科解释是：建造者模式，Builder Pattern，又名生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><a id="more"></a><h1 id="先上一个例子"><a href="#先上一个例子" class="headerlink" title="先上一个例子"></a>先上一个例子</h1><p>借用并改造下《Effective Java》中给出的例子：每种食品包装上都会有一个营养成分表，每份的含量、每罐的含量、每份卡路里、脂肪、碳水化合物、钠等，还可能会有其他N种可选数据，大多数产品的某几个成分都有值，该如何定义营养成分这个类呢？</p><h2 id="重叠构造器"><a href="#重叠构造器" class="headerlink" title="重叠构造器"></a>重叠构造器</h2><p>因为有多个参数，有必填、有选填，最先想到的就是定义多个有参构造器：第一个构造器只有必传参数，第二个构造器在第一个基础上加一个可选参数，第三个加两个，以此类推，直到最后一个包含所有参数，这种写法称为重叠构造器，有点像叠罗汉。还有一种常见写法是只写一个构造函数，包含所有参数。</p><p>代码如下：</p><pre><code class="java">public class Nutrition {    private int servingSize;// required    private int servings;// required    private int calories;// optional    private int fat;// optional    private int sodium;// optional    private int carbohydrate;// optional    public Nutrition(final int servingSize, final int servings) {        this(servingSize, servings, 0, 0, 0, 0);    }    public Nutrition(final int servingSize, final int servings, final int calories) {        this(servingSize, servings, calories, 0, 0, 0);    }    public Nutrition(final int servingSize, final int servings, final int calories, final int fat) {        this(servingSize, servings, calories, fat, 0, 0);    }    public Nutrition(final int servingSize, final int servings, final int calories, final int fat, final int sodium) {        this(servingSize, servings, calories, fat, sodium, 0);    }    public Nutrition(final int servingSize, final int servings, final int calories, final int fat, final int sodium, final int carbohydrate) {        this.servingSize = servingSize;        this.servings = servings;        this.calories = calories;        this.fat = fat;        this.sodium = sodium;        this.carbohydrate = carbohydrate;    }    // getter}</code></pre><p>这种写法还可以有效解决参数校验，只要在构造器中加入参数校验就可以了。</p><p>如果想要初始化实例，只需要<code>new</code>一下就行：<code>new Nutrition(100, 50, 0, 35, 0, 10)</code>。这种写法，不够优雅的地方是，当<code>calories</code>和<code>sodium</code>值为0的时候，也需要在构造函数中明确定义是0，示例中才6个参数，也能勉强接受。但是如果参数达到20个呢？可选参数中只有一个值不是0或空，写起来很好玩了，满屏全是0和null的混合体。</p><p>还有一个隐藏缺点，那就是如果同类型参数比较多，比如上面这个例子，都是<code>int</code>类型，除非每次创建实例的时候仔细对比方法签名，否则很容易传错参数，而且这种错误编辑器检查不出来，只有在运行时会出现各种诡异错误，排错的时候不知道要薅掉多少根头发了。</p><p>想要解决上面两个问题，不难想到，可以通过set方法一个个赋值就行了。</p><h2 id="set方式赋值"><a href="#set方式赋值" class="headerlink" title="set方式赋值"></a>set方式赋值</h2><p>既然构造函数中放太多参数不够优雅，还有缺点，那就换种写法，构造函数只保留必要字段，其他参数的赋值都用setter方法就行了。</p><p>代码如下：</p><pre><code class="java">public class Nutrition {    private final int servingSize;// required    private final int servings;// required    private int calories;// optional    private int fat;// optional    private int sodium;// optional    private int carbohydrate;// optional    public Nutrition(int servingSize, int servings) {        this.servingSize = servingSize;        this.servings = servings;    }    // getter and setter}</code></pre><p>这样就可以解决构造函数参数太多、容易传错参数的问题，只在需要的时候<code>set</code>指定参数就行了。</p><p>如果没有特殊需求，到这里可以解决大部分问题了。</p><p>但是需求总是多变的，总会有类似“五彩斑斓的黑”这种奇葩要求：</p><ol><li>如果必填参数比较多，或者大部分参数是必填参数。这个时候这种方式又会出现重叠构造器那些缺点。</li><li>如果把所有参数都用set方法赋值，那又没有办法进行必填项的校验。</li><li>如果非必填参数之间有关联关系，比如上面例子中，脂肪<code>fat</code>和碳水化合物<code>carbohydrate</code>有值的话，卡路里<code>calories</code>一定不会为0。但是使用现在这种设计思路，属性之间的依赖关系或者约束条件的校验逻辑就没有地方定义了。</li><li>如果想要把<code>Nutrition</code>定义成不可变对象的话，就不能使用<code>set</code>方法修改属性值。</li></ol><p>这个时候就该祭出今天的主角了。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>先上代码</p><pre><code class="java">public class Nutrition {    private int servingSize;// required    private int servings;// required    private int calories;// optional    private int fat;// optional    private int sodium;// optional    private int carbohydrate;// optional    public static class Builder {        private final int servingSize;// required        private final int servings;// required        private int calories;// optional        private int fat;// optional        private int sodium;// optional        private int carbohydrate;// optional        public Builder(final int servingSize, final int servings) {            this.servingSize = servingSize;            this.servings = servings;        }        public Builder setCalories(final int calories) {            this.calories = calories;            return this;        }        public Builder setFat(final int fat) {            this.fat = fat;            return this;        }        public Builder setSodium(final int sodium) {            this.sodium = sodium;            return this;        }        public Builder setCarbohydrate(final int carbohydrate) {            this.carbohydrate = carbohydrate;            return this;        }        public Nutrition build() {            // 这里定义依赖关系或者约束条件的校验逻辑            return new Nutrition(this);        }    }    private Nutrition(Builder builder) {        servingSize = builder.servingSize;        servings = builder.servings;        calories = builder.calories;        fat = builder.fat;        sodium = builder.sodium;        carbohydrate = builder.carbohydrate;    }    // getter}</code></pre><p>想要创建对象，只要调用<code>new Nutrition.Builder(100, 50).setFat(35).setCarbohydrate(10).build()</code>就可以了。这种方式兼具前两种方式的优点：</p><ul><li>能够毫无歧义且明确<code>set</code>指定属性的值；</li><li>在<code>build</code>方法或<code>Nutrition</code>构造函数中定义校验方法，可以在创建对象过程中完成校验。</li></ul><p>建造者模式的缺点就是代码变多了（好像所有的设计模式都有这个问题），这个缺点可以借助<code>lombok</code>来解决，通过注解<code>@Builder</code>，可以在编译过程自动生成对象的<code>Builder</code>类，相当省事。</p><h1 id="再来一个例子"><a href="#再来一个例子" class="headerlink" title="再来一个例子"></a>再来一个例子</h1><p>接下来分析下《大话设计模式》中的一个例子，这个例子从代码结构上，和建造者模式有很大的出入，但是作者却把它归为建造者模式。下面我们就来看看究竟：现在需要画个小人，一个小人需要头、身体、左手、右手、左脚、右脚。</p><p>代码如下：</p><pre><code class="java">public class Person {    private String head;    private String body;    private String leftHand;    private String rightHand;    private String leftLeg;    private String rightLeg;    // getter/setter}public class PersonBuilder {    private Person person = new Person();    public PersonBuilder buildHead() {        person.setHead(&quot;头&quot;);        return this;    }    public PersonBuilder buildBody() {        person.setBody(&quot;身体&quot;);        return this;    }    public PersonBuilder buildLeftHand() {        person.setLeftHand(&quot;左手&quot;);        return this;    }    public PersonBuilder buildRightHand() {        person.setRightHand(&quot;右手&quot;);        return this;    }    public PersonBuilder buildLeftLeg() {        person.setLeftLeg(&quot;左腿&quot;);        return this;    }    public PersonBuilder buildRightLeg() {        person.setRightLeg(&quot;右腿&quot;);        return this;    }    public Person getResult() {        return this.person;    }}</code></pre><p>但是，如果有个方法忘记调用了，比如画右手的方法忘记调用了，那就成杨过大侠了。这个时候就需要在<code>PersonBuilder</code>之上加一个<code>Director</code>类，俗称监工。</p><pre><code class="java">public class PersonDirector {    private final PersonBuilder pb;    public PersonDirector(final PersonBuilder pb) {        this.pb = pb;    }    public Person createPerson() {        this.pb            .buildHead()            .buildBody()            .buildLeftHand()            .buildRightHand()            .buildLeftLeg()            .buildRightLeg();        return this.pb.getResult();    }}</code></pre><p>这个时候，对于客户端来说，只需要关注<code>Director</code>类就行了，就相当于在客户端调用构造器之间，增加一个监工，一个对接人，保证客户端能够正确使用<code>Builder</code>类。</p><p>细心的朋友可能会发现，我这里的<code>Director</code>类的构造函数增加了一个<code>Builder</code>参数，这是为了更好的扩展，比如，这个时候需要增加一个胖子<code>Builder</code>类，那就只需要定义一个<code>FatPersonBuilder</code>，继承<code>PersonBuilder</code>，然后只需要将新增加的类传入<code>Director</code>的构造函数即可。</p><p>这也是建造者模式的另一个优点：可以定义不同的<code>Builder</code>类实现不同的构建属性，比如上面的普通人和胖子两个<code>Builder</code>类。</p><h1 id="最后来个总结"><a href="#最后来个总结" class="headerlink" title="最后来个总结"></a>最后来个总结</h1><p>有的朋友会说，这两个例子结构差别很大，怎么能是同一个模式？</p><p>那我们来看看官方给出的建造者模式的类图：</p><p><img src="https://static.howardliu.cn/design-patterns/builder-pattern.jpg" alt="Builder Patter"></p><p>这样结构就比较清晰了，两个例子都包含<code>Product</code>类和<code>Builder</code>类(或子类)，区别是，第一个例子对象的完整性操作交给了客户端，第二个例子由<code>Director</code>类保障对象的完整。</p><p>我们来看看建造者的本质：构建<strong>状态完整</strong>、<strong>结构复杂</strong>的对象。</p><ul><li>结构复杂：如果只有几个属性，通过构造函数就能实现，只有属性多了，结构复杂，建造者模式才能体现价值，建议属性值超过6个时使用建造者模式。</li><li>状态完整：状态是否完整可以通过客户端或<code>Director</code>来管理，不会出现因为忘记调用<code>set</code>或其他方法，是对象少定义一个属性。</li></ul><p>从某种意义上说，建造者模式是为了弥补构造函数的不足出现的，主要优点是下面3项：</p><ol><li>将一个复杂对象的创建过程封装起来，向客户端隐藏产品内部表现</li><li>允许对象通过多个步骤来创建，并可以改变过程</li><li>产品的实现可以变换，因为客户端只能看到一个抽象的接口</li></ol><p>建造者模式作为一种比较实用的设计模式，应用场景主要是下面两个：</p><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li><li>当构造过程必须允许被构造的对象有不同的表示时</li></ul><p>碰到上面两种情况，不要犹豫，果断使用建造者模式就行。</p><p>因为疫情的影响，今年的招聘和应聘变得与往年大不一样，原本金三银四的时间可能会延长到5、6月份，这样大家可以有更多的时间准备。但是也有一个不利于应聘者的情况是，随着大家准备的时间延长，基本功是否扎实就会使面试者的表现拉开距离，设计模式就是基本功中的一种。所以准备在最近开启“面向面试之设计模式”的系列，希望能够夯实自己基础的同时，帮助到更多的人。</p><ul><li><a href="https://www.howardliu.cn/singleton-pattern/">单例模式</a></li><li><a href="https://www.howardliu.cn/the-builder-pattern/">建造者模式</a></li></ul><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/the-builder-pattern/">设计模式：建造者模式</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/105038711" target="_blank" rel="noopener">设计模式：建造者模式</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      建造者模式，又名生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
    
    </summary>
    
    
      <category term="design pattern" scheme="https://www.howardliu.cn/categories/design-pattern/"/>
    
    
      <category term="设计模式" scheme="https://www.howardliu.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
