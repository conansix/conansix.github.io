<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>沉潜飞动</title>
  
  <subtitle>君子藏器于身，待时而动。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.howardliu.cn/"/>
  <updated>2021-02-20T13:21:45.000Z</updated>
  <id>https://www.howardliu.cn/</id>
  
  <author>
    <name>Howard Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件架构-事件驱动架构</title>
    <link href="https://www.howardliu.cn/event-driven-architecture/"/>
    <id>https://www.howardliu.cn/event-driven-architecture/</id>
    <published>2021-02-20T13:21:45.000Z</published>
    <updated>2021-02-20T13:21:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/software-architecture/jellyfish-2427426_1920.jpg" alt="软件架构-事件驱动架构"></p><p>你好，我是看山。</p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/software-architecture/index.html" target="_blank" rel="noopener">《软件架构》</a> 中关于事件驱动的内容，虽然是 2014 年的文章，但是从软件架构层面上，并不过时。</p></blockquote><p>以下是正文。</p><p>事件驱动架构是一种系统或组件之间通过发送事件和响应事件彼此交互的架构风格。当某个事件发生时，组件A不直接调用组件B，而只是发出一个事件。组件A不知道哪些组件监听并处理这些事件。事件驱动架构可以在进程内和进程间使用。比如，GUI框架中会大量使用事件驱动。【译者注：目前很多系统采用微服务架构，事件驱动使用的更加广泛了。】此外，正如我在<a href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html" target="_blank" rel="noopener">并发模型教程</a> 中所提到的，装配线并发模型（AKA reactive，非阻塞并发模型）也使用了事件驱动架构。</p><p>本文主要介绍进程之间的事件驱动架构，后文提到这个词的时候也是指进程交互方式。</p><a id="more"></a><h2 id="进程间的事件驱动架构"><a href="#进程间的事件驱动架构" class="headerlink" title="进程间的事件驱动架构"></a>进程间的事件驱动架构</h2><p>事件驱动架构是一种架构风格，先将请求事件集中存放在一个或多个事件队列中，然后事件从这些事件队列转发到后端服务，处理这些事件。</p><p>因为事件可以被看做是消息流，所以事件驱动架构也被称为消息驱动架构或者流处理架构。流处理架构又可以被称为lambda架构。为了保证统一，后文会继续使用事件驱动这个名词。</p><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p>在事件驱动架构中，你会有一个或多个集中的事件队列，所有的事件被处理前，会先保存在集中的事件队列中。下面给出一个简单示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-1.png" alt="event-driven-architecture"></p><p>事件插入队列时是有序的，这样就可以顺序处理这些事件。</p><h2 id="事件日志"><a href="#事件日志" class="headerlink" title="事件日志"></a>事件日志</h2><p>写入事件队列时，消息可能写入到事件日志（通常是磁盘存储）中。如果发生系统崩溃，系统只需要重放事件日志即可恢复到崩溃前的状态。下面是一个事件驱动架构的示例，其中包括一个用于持久化事件的事件日志：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-2.png" alt="event-driven-architecture"></p><p>我们还可以通过备份事件日志，来备份系统状态。在将新版本的系统部署在生产环境之前，可以使用这个备份数据对其性能进行测试。或者，通过重放事件日志的备份，来重现某些错误。</p><h2 id="事件收集器"><a href="#事件收集器" class="headerlink" title="事件收集器"></a>事件收集器</h2><p>请求都是通过网络传输，比如HTTP或者其他协议。为了保持一致，可以通过事件采集器接收来自不同来源的事件。下面是一个添加了事件收集器的事件驱动架构示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-3.png" alt="event-driven-architecture"></p><h2 id="响应队列"><a href="#响应队列" class="headerlink" title="响应队列"></a>响应队列</h2><p>有时，我们还需要向请求（即事件）返回响应，所以，很多事件驱动架构除了包含事件队列，还会有一个响应队列。下面是包含事件队列（入队队列）和响应队列（出队队列）的事件驱动架构示例：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-4.png" alt="event-driven-architecture"></p><p>如你所见，响应队列必须路由到正确的事件收集器。比如，如果HTTP收集器（本质上是web服务器）通过HTTP接收的请求发送到事件队列中，则该事件生成的响应可能也需要通过HTTP收集器发回客户端。</p><p>通常，响应队列不会持久化，也就意味着它不会写入事件日志，只有输入的事件才会持久化到事件日志中。</p><h2 id="读事件-vs-写事件"><a href="#读事件-vs-写事件" class="headerlink" title="读事件 vs. 写事件"></a>读事件 vs. 写事件</h2><p>如果将所有传入的请求都认为是事件，就需要将这些事件都推送到事件队列中。如果事件队列是实现了持久化（持久化到事件日志中），就意味着所有事件都需要持久化。通常持久化都比较慢，如果我们能够过滤掉一些不需要持久化的事件，我们就能够提升队列的性能。</p><p>我们将事件持久化到事件日志的原因是，我们可以重放事件日志，并重建因为事件引起的系统状态变化。为了支持这个特性，实际上只需要持久化更改系统状态的事件。换句话说，我们只需要将事件分为读事件和写事件。读事件只读取系统数据，不会更改，写事件会更改系统数据。</p><p>通过根据读和写划分事件，我们只需要持久化写事件的消息即可。这将提升事件队列的性能，提升比例大小，取决于读写事件之间的比例。</p><p>为了将事件划分为读写事件，需要在事件到达事件队列之前，也就是事件收集器中进行区分。否则，事件队列无法知道到达的事件是否需要持久化。</p><p>还可以将事件队列拆分为两个，一个用于存储读事件的事件队列，一个用于存储写事件的事件队列。这样读事件就不会慢于写事件，事件队列也不需要检查每条事件是否需要持久化。读事件队列不需要进行持久化，写事件队列始终持久化事件。</p><p>下面是一个事件驱动架构的示例，其中事件队列分为读和写事件队列：</p><p><img src="http://static.howardliu.cn/software-architecture/event-driven-architecture-5.png" alt="event-driven-architecture"></p><p>上图示例中箭头比较乱，但实际上创建3个丢列并在它们之间分发消息简单很多。</p><h2 id="事件日志重放的挑战"><a href="#事件日志重放的挑战" class="headerlink" title="事件日志重放的挑战"></a>事件日志重放的挑战</h2><p>事件驱动架构的一大优点是，在系统崩溃或系统重启情况下，只需要重放事件日志，就能够重建系统状态。在日志可以独立于时间和周边系统的情况下重放日志，这是一个很大的优势。</p><p>但是，完全独立于时间重放事件日志有时候很难实现。接下来介绍下事件日志重放的一些挑战。</p><h3 id="处理动态数据"><a href="#处理动态数据" class="headerlink" title="处理动态数据"></a>处理动态数据</h3><p>如前所述，写事件处理时可能会修改系统数据。有些情况，这种数据的修改受事件处理时动态数据的影响。比如，处理事件的日期和时间或者特定日期和时间的货币汇率。</p><p>这些动态数据会对事件重放造成困难。如果在不同的时间重放事件日志，处理该事件的服务可能会解析不同的动态值，比如其他的日期和时间或其他汇率。因此，在不同的日期重放事件日志，可能会出现重建系统数据与最初处理事件产生的数据不一致。</p><p>要解决动态数据的问题，可以让写事件队列将所需的动态数据标记在事件中。但是，要实现这种方案，需要事件队列知道每条事件消息需要哪些动态数据。这样会使事件队列的设计复杂化，每次需要新的动态数据时，事件队列都需要知道如何查找这些动态数据。</p><p>另外一种解决方案是，写事件队列只在写事件上标记事件的日期和时间。使用事件的原始日期和时间，处理事件的服务可以查找给定日期和时间对应的动态数据。比如，可以通过原始的日期和时间，查询当时有效的汇率。这就要求处理事件的服务需要基于日期和时间查询动态数据，但是这只是理想状态。</p><h3 id="与外部系统的交互"><a href="#与外部系统的交互" class="headerlink" title="与外部系统的交互"></a>与外部系统的交互</h3><p>事件日志重放的另一个挑战是与外部系统的协调。比如，事件日志中包含电商平台的订单，在第一次处理这个事件时，需要将订单发送到外部支付网关，以从客户信用卡中收费。</p><p>如果重放事件日志，就不希望再次为同一个订单向客户收费。因此，就不希望在事件重放时，将订单发送到外部支付网关。</p><h2 id="事件日志重放解决方案"><a href="#事件日志重放解决方案" class="headerlink" title="事件日志重放解决方案"></a>事件日志重放解决方案</h2><p>解决重放事件日志问题挺不容易的。有些系统没有问题，可以直接重放事件日志；有些系统可能需要知道原始事件的日期和时间；有些系统可能需要知道更多类似于事件原始处理过程中从外部系统获取的原始数据。</p><h3 id="重放模式"><a href="#重放模式" class="headerlink" title="重放模式"></a>重放模式</h3><p>在任何情况下，倾听写事件队列中事件的任何服务都必须知道传入事件是原始事件还是重放事件。这样，处理服务就能够确定如何处理动态数据或者如何与外部系统交互了。</p><h3 id="多步骤事件队列"><a href="#多步骤事件队列" class="headerlink" title="多步骤事件队列"></a>多步骤事件队列</h3><p>另外一个解决方案是采用多步骤事件队列。第一步，收集所有写事件；第二步，解析动态数据；第三步，与外部系统交互。如果需要重放事件日志，只需要跳过第一步和第二步，重放第三步即可。具体如何实现，需要取决于具体的系统设计。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老后端，Apache Storm、WxJava、Cynomys 开源贡献者。主业：程序猿，兼职：架构师。游于码界，戏享人生。</p><p>原文链接：<a href="http://tutorials.jenkov.com/software-architecture/event-driven-architecture.html" target="_blank" rel="noopener">Event-driven Architecture</a><br>翻译: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接: <a href="https://www.howardliu.cn/event-driven-architecture/">软件架构-事件驱动架构</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/103794938" target="_blank" rel="noopener">软件架构-事件驱动架构</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.howardliu.cn/software-architecture/jellyfish-2427426_1920.jpg&quot; alt=&quot;软件架构-事件驱动架构&quot;&gt;&lt;/p&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 &lt;a href=&quot;http://tutorials.jenkov.com/software-architecture/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《软件架构》&lt;/a&gt; 中关于事件驱动的内容，虽然是 2014 年的文章，但是从软件架构层面上，并不过时。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;p&gt;事件驱动架构是一种系统或组件之间通过发送事件和响应事件彼此交互的架构风格。当某个事件发生时，组件A不直接调用组件B，而只是发出一个事件。组件A不知道哪些组件监听并处理这些事件。事件驱动架构可以在进程内和进程间使用。比如，GUI框架中会大量使用事件驱动。【译者注：目前很多系统采用微服务架构，事件驱动使用的更加广泛了。】此外，正如我在&lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/concurrency-models.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;并发模型教程&lt;/a&gt; 中所提到的，装配线并发模型（AKA reactive，非阻塞并发模型）也使用了事件驱动架构。&lt;/p&gt;
&lt;p&gt;本文主要介绍进程之间的事件驱动架构，后文提到这个词的时候也是指进程交互方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="事件驱动" scheme="https://www.howardliu.cn/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</title>
    <link href="https://www.howardliu.cn/understanding-java-list/"/>
    <id>https://www.howardliu.cn/understanding-java-list/</id>
    <published>2021-02-09T06:18:59.000Z</published>
    <updated>2021-02-09T06:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/sunset-5299957_1920.jpg" alt="认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList"></p><p>你好，我是看山。</p><p>书接上文，上次聊了聊 <a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">在多线程中使用 ArrayList 会发生什么</a>，这次我们说说平时常用的列表：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList。</p><a id="more"></a><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p><code>Vector</code>是在 JDK 1.0 提供的，虽然没有被标记<code>Deprecated</code>，但是事实上已经没人使用了。主要原因是性能差，且不符合需求。</p><p>从源码可以看出（这里不贴源码了），<code>Vector</code>是基于数组实现，几乎在所有操作方法上，都用<code>synchronized</code>关键字实现方法同步，这种同步方式可以对单一操作进行加锁，比如多个线程同时执行<code>add</code>会同步阻塞执行，但是多线程执行<code>add</code>和<code>remove</code>时，就不会阻塞了。</p><p>但是，大部分需要对队列加锁的场景，是想对整个队列加锁，而不仅仅是对单一操作加锁。也就是说，<code>Vector</code>和我们的期望不同，但是又额外增加了同步操作带来的性能开销。所以，不是必须使用的场景，都可以使用<code>ArrayList</code>代替，即使是多线程情况下需要同步队列，也可以使用<code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>代替。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><code>ArrayList</code>是在 JDK 1.1 提供的，作为<code>Vector</code>的继任者（<code>ArrayList</code>实现方式与<code>Vector</code>几乎完全相同），<code>ArrayList</code>把方法上的<code>synchronized</code>全部去掉了，完全没有实现同步，是非线程安全的。</p><p>它的非线程安全，还体现在迭代器的快速失败上。在使用方法<code>iterator</code>和<code>listIterator</code>创建迭代器之后，如果还对原来的<code>ArrayList</code>队列进行修改（add 或 remove），迭代器迭代的时候就会报<code>ConcurrentModificationException</code>异常。从源码可以看出，迭代器在迭代过程中，会检查队列中修改次数<code>modCount</code>与创建迭代器时落下的修改次数快照<code>expectedModCount</code>是否相等，相等表示没有修改过，代码如下：</p><pre><code class="java">private class Itr implements Iterator&lt;E&gt; {    // 这段代码是从 ArrayList 中摘取的    // 只留下检查方法，略过其他代码，有兴趣的可以从源码中查看    final void checkForComodification() {        if (modCount != expectedModCount)            throw new ConcurrentModificationException();    }}</code></pre><p>第三点是在多线程场景中，添加元素可能会丢失数据，或者发生数组越界异常，<a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">在多线程中使用 ArrayList 会发生什么</a> 有详细描述，这里就不赘述了。</p><h2 id="SynchronizedList"><a href="#SynchronizedList" class="headerlink" title="SynchronizedList"></a>SynchronizedList</h2><p><code>SynchronizedList</code>是<code>Collections</code>的静态内部类，使用<code>Collections.synchronizedList()</code>静态方法创建，是一个通过组合<code>List</code>类实现的封装实现。它的大多数方法通过<code>synchronized (mutex){...}</code>代码块同步方式，因为加锁对象<code>mutex</code>是队列对象中定义的相同对象，所以对<code>mutex</code>加锁时，就实现对整个队列加锁，也就解决了<code>Vector</code>不能对整个队列加锁的问题。所以如果有多个线程同时操作<code>add</code>和<code>remove</code>方法，会阻塞同步执行。</p><p><code>ArrayList</code>中存在的迭代器快速失败情况，依然存在，正如下面源码中的注释：想要使用迭代器，需要用户手动实现同步。</p><pre><code class="java">static class SynchronizedList&lt;E&gt;    extends SynchronizedCollection&lt;E&gt;    implements List&lt;E&gt; {    // 代码摘自 Collections，省略很多代码    public void add(int index, E element) {        synchronized (mutex) {list.add(index, element);}    }    public ListIterator&lt;E&gt; listIterator() {        return list.listIterator(); // Must be manually synched by user    }    public ListIterator&lt;E&gt; listIterator(int index) {        return list.listIterator(index); // Must be manually synched by user    }}</code></pre><p>手动同步的时候需要注意，既然我们关注的全局同步，在迭代器设置同步的时候，要保证锁定对象与<code>add</code>等方法中对象相同。这个在后续补充说明，这里就不展开了。</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>CopyOnWriteArrayList</code>是从 JDK 1.5 开始提供的，先看看<code>add</code>方法的源码：</p><pre><code class="java">public class CopyOnWriteArrayList&lt;E&gt;    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {    /** The lock protecting all mutators */    final transient ReentrantLock lock = new ReentrantLock();    /** The array, accessed only via getArray/setArray. */    private transient volatile Object[] array;    // 代码摘自 CopyOnWriteArrayList，省略很多代码    public boolean add(E e) {        final ReentrantLock lock = this.lock;        lock.lock();        try {            Object[] elements = getArray();            int len = elements.length;            Object[] newElements = Arrays.copyOf(elements, len + 1);            newElements[len] = e;            setArray(newElements);            return true;        } finally {            lock.unlock();        }    }    public boolean addAll(Collection&lt;? extends E&gt; c) {        Object[] cs = (c.getClass() == CopyOnWriteArrayList.class) ?            ((CopyOnWriteArrayList&lt;?&gt;)c).getArray() : c.toArray();        if (cs.length == 0)            return false;        final ReentrantLock lock = this.lock;        lock.lock();        try {            Object[] elements = getArray();            int len = elements.length;            if (len == 0 &amp;&amp; cs.getClass() == Object[].class)                setArray(cs);            else {                Object[] newElements = Arrays.copyOf(elements, len + cs.length);                System.arraycopy(cs, 0, newElements, len, cs.length);                setArray(newElements);            }            return true;        } finally {            lock.unlock();        }    }    private E get(Object[] a, int index) {        return (E) a[index];    }    /**     * {@inheritDoc}     *     * @throws IndexOutOfBoundsException {@inheritDoc}     */    public E get(int index) {        return get(getArray(), index);    }}</code></pre><p>可以看到，<code>CopyOnWriteArrayList</code>借助<code>ReentrantLock</code>实现同步，在<code>synchronized</code>优化之前，<code>ReentrantLock</code>性能高于<code>synchronized</code>。<code>CopyOnWriteArrayList</code>也是通过数组实现的，但是在数组前面增加了<code>volatile</code>关键字，实现了多线程情况下数组的可见性，更加安全。更重要的一点是，<code>CopyOnWriteArrayList</code>在<code>add</code>添加元素的时候，实现方式是重建数组对象，替换原来的数组引用。与<code>ArrayList</code>的扩容方式相比，减少了空间，但是也增加了赋值数组的性能开销。在<code>get</code>获取元素的时候，没有任何锁，直接数据返回。</p><p><code>CopyOnWriteArrayList</code>的迭代器时通过<code>COWIterator</code>实现的，调用<code>iterator</code>方法时，将当前队列中数组的快照赋值到迭代器中的数组引用上。如果原来的队列发生修改，队列中数组会指向别的引用，而迭代器中的数组不会发生变化，所以在多线程执行过程中，通过迭代器遍历数组，也可以修改队列中的数据。这种方式保障线程安全的同时，也可能会出现数据不一致的情况，只能是使用的使用多注意了。</p><pre><code class="java">static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; {    /** Snapshot of the array */    private final Object[] snapshot;    /** Index of element to be returned by subsequent call to next.  */    private int cursor;    private COWIterator(Object[] elements, int initialCursor) {        cursor = initialCursor;        snapshot = elements;    }}</code></pre><h2 id="对比-CopyOnWriteArrayList-和-SynchronizedList"><a href="#对比-CopyOnWriteArrayList-和-SynchronizedList" class="headerlink" title="对比 CopyOnWriteArrayList 和 SynchronizedList"></a>对比 CopyOnWriteArrayList 和 SynchronizedList</h2><p><code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>都实现了同步，实现方式上采用的是不同策略，各自的侧重点不同。</p><p><code>CopyOnWriteArrayList</code>侧重于读写分离，发生数据写操作（<code>add</code>或<code>remove</code>）时，会加锁，各个线程阻塞执行，执行过程会创建数据副本，替换对象引用；如果同时有读操作（<code>get</code>或<code>iterator</code>），读操作读取的是老数据，或者成为历史数据快照，或者成为缓存数据。这会造成读写同时发生时，数据不一致的情况，但是数据最终会一致。这种方式与数据库读写分离模式几乎相同，很多特性可以类比。</p><p><code>SynchronizedList</code>侧重数据强一致，也就是说当发生数据写操作（<code>add</code>或<code>remove</code>）时，会加锁，各个线程阻塞执行，而且也会通过相同的锁阻塞<code>get</code>操作。</p><p>从<code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>两种不同事项方式，可以推断<code>CopyOnWriteArrayList</code>在写少读多的场景中执行效率高，<code>SynchronizedList</code>的读写操作效率很均衡，所以在写多读多、写多读少的场景执行效率都会高于<code>CopyOnWriteArrayList</code>。借用网上的测试结果：</p><p><img src="http://static.howardliu.cn/java/CopyOnWriteArrayList-SynchronizedList-Vector.jpg" alt="对比 CopyOnWriteArrayList 和 SynchronizedList"></p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><ol><li><code>synchronized</code>关键字在 JDK 8 之前性能比较差，可以看到 JDK1.5 之后实现的同步代码，很多是通过<code>ReentrantLock</code>实现的。</li><li>多线程场景中除了需要考虑同步外，还需要考虑数据可见性，可以通过<code>volatile</code>关键字实现。</li><li><code>ArrayList</code>完全没有同步操作，是非线程安全的</li><li><code>CopyOnWriteArrayList</code>和<code>SynchronizedList</code>属于线程安全队列</li><li><code>CopyOnWriteArrayList</code>实现读写分离，适合场景是写少读多的场景</li><li><code>SynchronizedList</code>要求数据强一致，是队列全局加锁方式，读操作也会加锁</li><li><code>Vector</code>只是在迭代器遍历性能很差，如果不考虑全局锁定队列，单纯读操作和单独写操作性能与<code>SynchronizedList</code>相差不大。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated" target="_blank" rel="noopener">Why is Java Vector (and Stack) class considered obsolete or deprecated?</a></li><li><a href="https://blog.csdn.net/yangzl2008/article/details/39456817" target="_blank" rel="noopener">CopyOnWriteArrayList 与 Collections.synchronizedList 的性能对比</a></li><li><a href="https://juejin.cn/post/6844904054745743367" target="_blank" rel="noopener">Collections.synchronizedList 、CopyOnWriteArrayList、Vector 介绍、源码浅析与性能对比</a></li></ol><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol><li><a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用 ArrayList 会发生什么？</a></li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老后端，Apache Storm、WxJava、Cynomys 开源贡献者。主业：程序猿，兼职：架构师。游于码界，戏享人生。</p><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/understanding-java-list/">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/113780875" target="_blank" rel="noopener">认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://static.howardliu.cn/java/sunset-5299957_1920.jpg&quot; alt=&quot;认识 Java 中的队列：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList&quot;&gt;&lt;/p&gt;
&lt;p&gt;你好，我是看山。&lt;/p&gt;
&lt;p&gt;书接上文，上次聊了聊 &lt;a href=&quot;https://www.howardliu.cn/arraylist-is-not-thread-safe/&quot;&gt;在多线程中使用 ArrayList 会发生什么&lt;/a&gt;，这次我们说说平时常用的列表：Vector、ArrayList、CopyOnWriteArrayList、SynchronizedList。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="队列" scheme="https://www.howardliu.cn/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>如果非要在多线程中使用ArrayList会发生什么？</title>
    <link href="https://www.howardliu.cn/arraylist-is-not-thread-safe/"/>
    <id>https://www.howardliu.cn/arraylist-is-not-thread-safe/</id>
    <published>2021-02-04T13:08:09.000Z</published>
    <updated>2021-02-04T13:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/road-5837403_1920.jpg" alt="如果非要在多线程中使用ArrayList会发生什么？"></p><p>你好，我是看山。</p><p>我们都知道，Java中的ArrayList是非线程安全的，这个知识点太熟了，甚至面试的时候都很少问了。</p><p>但是我们真的清楚原理吗？或者知道多线程情况下使用ArrayList会发生什么？</p><p>前段时间，我们就踩坑了，而且直接踩了两个坑，今天就来扒一扒。</p><a id="more"></a><h2 id="翠花，上源码"><a href="#翠花，上源码" class="headerlink" title="翠花，上源码"></a>翠花，上源码</h2><p>上代码之前先说下<code>ArrayList</code>的<code>add</code>逻辑：</p><ol><li>检查队列中数组是否还没有添加过元素</li><li>如果是，设置当前需要长度为10，如果否，设置当前需要长度为当前队列长度+1</li><li>判断需要长度是否大于数组大小</li><li>如果是，需要扩容，将数组长度扩容1.5倍（第一次扩容会从0直接到10，后续会按照1.5倍的步幅增长）</li><li>数组中添加元素，队列长度+1</li></ol><p>附上代码，有兴趣的可以在看看源码。</p><pre><code class="java">/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add}) */public boolean add(E e) {    // 判断数组容量是否足够，如果不足，增加1.5倍，size是当前队列长度    ensureCapacityInternal(size + 1);  // Increments modCount!!    // 给下标为size的赋值，同时队列长度+1，下标从0开始    elementData[size++] = e;    return true;}private void ensureCapacityInternal(int minCapacity) {    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));}private static int calculateCapacity(Object[] elementData, int minCapacity) {    // 判断是否首次添加元素，如果是，返回默认队列长度，现在是10    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {        return Math.max(DEFAULT_CAPACITY, minCapacity);    }    // 如果不是首次添加元素，就返回当前队列长度+1    return minCapacity;}private void ensureExplicitCapacity(int minCapacity) {    modCount++;    // overflow-conscious code    // 如果需要的长度大于队列中数组长度，扩容，如果可以满足需求，就不用扩容    if (minCapacity - elementData.length &gt; 0)        grow(minCapacity);}/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) {    // overflow-conscious code    int oldCapacity = elementData.length;    // 这里就是扩容1.5倍的代码    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);    if (newCapacity - minCapacity &lt; 0)        newCapacity = minCapacity;    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)        newCapacity = hugeCapacity(minCapacity);    // minCapacity is usually close to size, so this is a win:    elementData = Arrays.copyOf(elementData, newCapacity);}</code></pre><h2 id="就是这么不安全"><a href="#就是这么不安全" class="headerlink" title="就是这么不安全"></a>就是这么不安全</h2><p>从上面代码可以看出，<code>ArrayList</code>中一丁点考虑多线程的元素都没有，完全的效率优先。</p><h3 id="奇怪的ArrayIndexOutOfBoundsException"><a href="#奇怪的ArrayIndexOutOfBoundsException" class="headerlink" title="奇怪的ArrayIndexOutOfBoundsException"></a>奇怪的ArrayIndexOutOfBoundsException</h3><p>先做一个假设，此时数组长度达到临界边缘，比如目前容量是10，现在已经有9个元素，也就是size=9，然后有两个线程同时向队列中增加元素：</p><ol><li>线程1开始进入<code>add</code>方法，获取size=9，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量是10，不需要扩容</li><li>线程2也进入<code>add</code>方法，获取size=9，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量还是10，也不需要扩容</li><li>线程1开始赋值值了，也就是<code>elementData[size++] = e</code>，此时size变成10，达到数组容量极限</li><li>线程2此次开始执行赋值操作，使用的size=10，也就是<code>elementData[10] = e</code>，因为下标从0开始，目前数组容量是10，直接报数组越界<code>ArrayIndexOutOfBoundsException</code>。</li></ol><p>仅仅差了一步，线程2就成为了抛异常的凶手。但是抛出异常还是好的，因为我们知道出错了，可以沿着异常</p><h3 id="诡异的null元素"><a href="#诡异的null元素" class="headerlink" title="诡异的null元素"></a>诡异的null元素</h3><p>这种情况不太容易从代码中发现，得对代码稍加改造，<code>elementData[size++] = e</code>这块代码其实执行了两步：</p><pre><code class="java">elementData[size] = e;size++;</code></pre><p>假设还是有两个线程要赋值，此时数组长度还比较富裕，比如数组长度是10，目前size=5：</p><ol><li>线程1开始进入<code>add</code>方法，获取size=5，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量是10，不需要扩容</li><li>线程2也进入<code>add</code>方法，获取size=5，调用<code>ensureCapacityInternal</code>方法进行容量判断，此时数组容量还是10，也不需要扩容</li><li>线程1开始赋值，执行<code>elementData[size] = e</code>，此时size=5，在执行<code>size++</code>之前，线程2开始赋值了</li><li>线程2开始赋值，执行<code>elementData[size] = e</code>，此时size还是5，所以线程2把线程1赋的值覆盖了</li><li>线程1开始执行<code>size++</code>，此时size=6</li><li>线程2开始执行<code>size++</code>，此时size=7</li></ol><p>也就是说，添加了2个元素，队列长度+2，但是真正加入队列的元素只有1个，有一个被覆盖了。</p><p>这种情况不会立马报错，排查起来就很麻烦了。而且随着JDK 8的普及，可能随手使用filter过滤空元素，这样就不会立马出错，直到出现业务异常之后才能发现，到那时，错误现场已经不见了，排查起来一头雾水。</p><p>有同学会问，源码中是<code>elementData[size++] = e</code>，是一行操作，为什么会拆成两步执行呢？其实这得从JVM字节码说起了。</p><h3 id="通过JVM字节码说说第二种异常出现的原因"><a href="#通过JVM字节码说说第二种异常出现的原因" class="headerlink" title="通过JVM字节码说说第二种异常出现的原因"></a>通过JVM字节码说说第二种异常出现的原因</h3><p>先来一段简单的代码：</p><pre><code class="java">public class Main {    public static void main(String[] args) {        int[] nums = new int[3];        int index = 0;        nums[index++] = 5;    }}</code></pre><p>通过<code>javac Main.java</code>和<code>javap -v -l Main.class</code>组合操作得到字节码：</p><blockquote><p>下面那些中文是我后加的备注，备注中还列出了局部变量表和栈值的变化，需要有点耐心。</p></blockquote><pre><code class="class">public class Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #3.#12         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #13            // Main   #3 = Class              #14            // java/lang/Object   #4 = Utf8               &lt;init&gt;   #5 = Utf8               ()V   #6 = Utf8               Code   #7 = Utf8               LineNumberTable   #8 = Utf8               main   #9 = Utf8               ([Ljava/lang/String;)V  #10 = Utf8               SourceFile  #11 = Utf8               Main.java  #12 = NameAndType        #4:#5          // &quot;&lt;init&gt;&quot;:()V  #13 = Utf8               Main  #14 = Utf8               java/lang/Object{  public Main();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 1: 0  public static void main(java.lang.String[]);    descriptor: ([Ljava/lang/String;)V    flags: ACC_PUBLIC, ACC_STATIC    Code:      stack=3, locals=3, args_size=1                                                                               局部变量表                             栈         0: iconst_3                     // 将int型(3)推送至栈顶                                                      args                                3         1: newarray       int           // 创建一个指定原始类型（如int, float, char…）的数组，并将其引用值压入栈顶          args                                数组引用         3: astore_1                     // 将栈顶引用型数值存入第二个本地变量                                            args, nums=数组引用                  null         4: iconst_0                     // 将int型(0)推送至栈顶                                                       args, nums=数组引用                  0         5: istore_2                     // 将栈顶int型数值存入第三个本地变量                                             args, nums=数组引用, index=0         null         6: aload_1                      // 将第二个引用类型本地变量推送至栈顶                                             args, nums=数组引用, index=0         数组引用         7: iload_2                      // 将第三个int型本地变量推送至栈顶                                               args, nums=数组引用, index=0         0, 数组引用         8: iinc          2, 1           // 将指定int型变量增加指定值（i++, i--, i+=2），也就是第三个本地变量增加1            args, nums=数组引用, index=1         0, 数组引用        11: iconst_5                     // 将int型(5)推送至栈顶                                                        args, nums=数组引用, index=1         5, 0, 数组引用        12: iastore                      // 将栈顶int型数值存入指定数组的指定索引位置                                       args, nums=数组引用, index=1         null        13: return                       // 从当前方法返回void      LineNumberTable:        line 3: 0                        // int[] nums = new int[3];        line 4: 4                        // int index = 0;        line 5: 6                        // nums[index++] = 5;        line 6: 13                       // 方法结尾默认的return}</code></pre><p>从上面的字节码可以看到，<code>nums[index++] = 5</code>这一句会被转为5个指令，是从6到12。大体操作如下：</p><ol><li>将数组、下标压入栈</li><li>给下标加值</li><li>将新值压入栈</li><li>取栈顶三个元素开始给元素指定下标赋值</li></ol><p>也即是说，错误出在数组赋值操作时先将数组引用和下标同时压入栈顶，与下标赋值是两步，在多线程环境中，就有可能出现上面说到的null值存在。</p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>其实解法也很简单，就是要意识到多线程环境，然后不使用ArrayList。可以使用<code>Collections.synchronizedList()</code>返回的同步队列，也可以使用<code>CopyOnWriteArrayList</code>这个队列，或者自己扩展<code>ArrayList</code>，将add方法做成同步方法。</p><h2 id="文末总结"><a href="#文末总结" class="headerlink" title="文末总结"></a>文末总结</h2><p><code>ArrayList</code>整个类的操作都是非线程安全的，一旦在多线程环境中使用，就可能会出现问题。上面提到<code>add</code>操作就会有两种异常行为，一个是数组越界异常，一个是出现丢数且出现空值。这还只是最简单的<code>add</code>操作，如果<code>add</code>、<code>addAll</code>和<code>get</code>混合使用使用时，异常情况就更多了。所以，使用的时候一定要注意是不是单线程操作，如果不是，果断使用其他队列防雷。</p><hr><p>你好，我是看山，公众号：看山的小屋，10 年老后端，Apache Storm、WxJava、Cynomys 开源贡献者。主业：程序猿，兼职：架构师。游于码界，戏享人生。</p><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/arraylist-is-not-thread-safe/">如果非要在多线程中使用ArrayList会发生什么？</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113666581" target="_blank" rel="noopener">如果非要在多线程中使用ArrayList会发生什么？</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      我们真的清楚多线程情况下使用ArrayList会发生什么吗？
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="Java" scheme="https://www.howardliu.cn/tags/Java/"/>
    
      <category term="ArrayList" scheme="https://www.howardliu.cn/tags/ArrayList/"/>
    
      <category term="线程安全" scheme="https://www.howardliu.cn/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>java import 导入包时，我们需要注意什么呢？</title>
    <link href="https://www.howardliu.cn/java-import-package/"/>
    <id>https://www.howardliu.cn/java-import-package/</id>
    <published>2021-01-31T10:54:40.000Z</published>
    <updated>2021-01-31T10:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/java/still-life-5322950_1920.jpg" alt="java import 导入包"></p><p>你好，我是看山。</p><p>这篇文章起因是 code review 时和同事关于 import 导入声明的分歧。</p><p>用过 IDEA 的都知道，默认情况下，通过 import 导入类时，当数量达到设置数量（类 5 个、静态变量 3 个），就会改为按需导入方式，也就是使用使用*号折叠导入。</p><p>同事建议不要采用按需导入，要使用单类型导入 (single-type-import)。而我是觉得既然 IDEA 作为宇宙级的 IDE，不会在这种地方出现纰漏，所以想继续按照 IDEA 默认配置来。</p><p>所以总结一下这两种方式的差异。如果对 java import 不熟悉，可以从 <a href="https://javagoal.com/java-import-package/" target="_blank" rel="noopener">这里</a> 看看。</p><a id="more"></a><h2 id="import-的两种导入声明"><a href="#import-的两种导入声明" class="headerlink" title="import 的两种导入声明"></a>import 的两种导入声明</h2><p>在 java 中，通过 import 导入类的方式有两种：</p><ul><li>单类型导入（single-type-import），例如 <code>import java.io.File</code>：这种方式比较容易理解，而且大部分时候我们用的都是这种方式。通过明确指明类和接口路径，将他们导入进来。</li><li>按需类型导入（type-import-on-demand），例如 <code>import java.io.*</code>：通过通配符<code>*</code>定义导入方式，但是并不是直接导入这个包下的所有类，而是可以导入所有类。也就是说，如果需要就导入，不需要就不导入。</li></ul><p>有如下属性：</p><ol><li>java 以这样两种方式导入包中的任何一个<code>public</code>的类和接口（只有 public 类和接口才能被导入）</li><li>上面说到导入声明仅导入声明目录下面的类而不导入子包，这也是为什么称它们为类型导入声明的原因。</li><li>导入的类或接口的简名（simple name）具有编译单元作用域。这表示该类型简名可以在导入语句所在的编译单元的任何地方使用。这并不意味着你可以使用该类型所有成员的简名，而只能使用类型自身的简名。例如：java.lang 包中的 public 类都是自动导入的，包括<code>Math</code>和<code>System</code>类。但是，你不能使用它们的成员的简名<code>PI()</code>和<code>gc()</code>, 而必须使用<code>Math.PI()</code>和<code>System.gc()</code>. 你不需要键入的是<code>java.lang.Math.PI()</code>和<code>java.lang.System.gc()</code>。</li><li>程序员有时会导入当前包或<code>java.lang</code>包，这是不需要的，因为当前包的成员本身就在作用域内，而<code>java.lang</code>包是自动导入的。java 编译器会忽略这些冗余导入声明 (redundant import declarations)。</li></ol><h2 id="按需导入机制"><a href="#按需导入机制" class="headerlink" title="按需导入机制"></a>按需导入机制</h2><p>按需类型导入在大部分情况用起来更加方便，一个通配符可以导入包下的所有类，就不用费劲写一堆导入了。</p><p>但是，根据能量守恒，在敲代码时节省下来的能量，必然会在其他地方消耗。</p><p>比如，<code>Date</code>类，如果完全使用按需类型导入，可以写做<code>import java.util.*</code>。当这个类恰好需要，<code>PrepareStatement</code>时，又需要加上<code>import java.sql.*</code>导入，这个时候，编译器不知道<code>Date</code>类是要用<code>java.util</code>包里的还是<code>java.sql</code>里面的了，就会报出<code>Reference to &#39;Date&#39; is ambiguous, both &#39;java.util.Date&#39; and &#39;java.sql.Date&#39; match</code>异常，也就是所说的<strong>命名冲突</strong>。</p><p>解决办法就是指明<code>Date</code>类的全路径，也就是使用单类型导入：<code>import java.util.Date</code>。</p><p>除了命名冲突，还有一些不太明显的缺点：</p><ol><li>编译速度：因为按需导入机制的特性，需要在 CLASSPATH 下找到所有符合包名的类，在编译时会消耗性能。在小项目中，这个速度可以忽略。如果在大项目中，就会有明细差异。</li><li>可读性：在使用 IDE 开发过程中，我们很少会在<code>import</code>中查看类的路径。但是如果需要我们在其他环境编辑文件，比如 vim，从<code>import</code>查看类的路径就很便捷了。</li></ol><h2 id="导入不需要的类会发生什么呢"><a href="#导入不需要的类会发生什么呢" class="headerlink" title="导入不需要的类会发生什么呢"></a>导入不需要的类会发生什么呢</h2><p>从理性讲，java 编译器一定会在这里做优化，不会把不需要的导入声明加入到 class 文件中，但是之前没有看到哪里有说明，所以动手做一下实验：</p><p>先定义 java 类：</p><pre><code class="java">package cn.howardliu;// 需要用到的单类型导入import java.util.Date;// 需要用到的按需类型导入import java.math.*;// 不需要用到的单类型导入import java.sql.PreparedStatement;// 不需要用到的按需类型导入import java.awt.*;public class Main {    private Date date1;    private BigDecimal num1;    public void test(){        Date date2 = new Date();        BigDecimal num2 = new BigDecimal(0);    }}</code></pre><p>通过命令<code>javac Main.java</code>编译，然后通过<code>javap -verbose Main.class</code>查看编译结果：</p><pre><code class="class">Classfile /path/to/Main.class  Last modified 2021-1-31; size 439 bytes  MD5 checksum 81e13559f738197b4875c2c2afd6fc41  Compiled from &quot;Main.java&quot;public class cn.howardliu.Main  minor version: 0  major version: 52  flags: ACC_PUBLIC, ACC_SUPERConstant pool:   #1 = Methodref          #7.#19         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V   #2 = Class              #20            // java/util/Date   #3 = Methodref          #2.#19         // java/util/Date.&quot;&lt;init&gt;&quot;:()V   #4 = Class              #21            // java/math/BigDecimal   #5 = Methodref          #4.#22         // java/math/BigDecimal.&quot;&lt;init&gt;&quot;:(I)V   #6 = Class              #23            // cn/howardliu/Main   #7 = Class              #24            // java/lang/Object   #8 = Utf8               date1   #9 = Utf8               Ljava/util/Date;  #10 = Utf8               num1  #11 = Utf8               Ljava/math/BigDecimal;  #12 = Utf8               &lt;init&gt;  #13 = Utf8               ()V  #14 = Utf8               Code  #15 = Utf8               LineNumberTable  #16 = Utf8               test  #17 = Utf8               SourceFile  #18 = Utf8               Main.java  #19 = NameAndType        #12:#13        // &quot;&lt;init&gt;&quot;:()V  #20 = Utf8               java/util/Date  #21 = Utf8               java/math/BigDecimal  #22 = NameAndType        #12:#25        // &quot;&lt;init&gt;&quot;:(I)V  #23 = Utf8               cn/howardliu/Main  #24 = Utf8               java/lang/Object  #25 = Utf8               (I)V{  public cn.howardliu.Main();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=1, locals=1, args_size=1         0: aload_0         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 12: 0  public void test();    descriptor: ()V    flags: ACC_PUBLIC    Code:      stack=3, locals=3, args_size=1         0: new           #2                  // class java/util/Date         3: dup         4: invokespecial #3                  // Method java/util/Date.&quot;&lt;init&gt;&quot;:()V         7: astore_1         8: new           #4                  // class java/math/BigDecimal        11: dup        12: iconst_0        13: invokespecial #5                  // Method java/math/BigDecimal.&quot;&lt;init&gt;&quot;:(I)V        16: astore_2        17: return      LineNumberTable:        line 17: 0        line 18: 8        line 19: 17}SourceFile: &quot;Main.java&quot;</code></pre><p>从 class 文件内容可以看出：</p><ol><li>按需类型导入方式在 class 文件中的表现形式，与按类型导入一样，也会找到需要的类导入，不会导入包中的所有类。</li><li>不需要的类导入声明，最终都会被优化掉，不会出现在 class 文件中。</li><li>java 中的<code>import</code>与 C 语言中的<code>include</code>不同，不会将导入声明的类写入到 class 文件中，各自还是独立的 class 文件。</li></ol><h2 id="JDK-推荐哪种方式"><a href="#JDK-推荐哪种方式" class="headerlink" title="JDK 推荐哪种方式"></a>JDK 推荐哪种方式</h2><p>JDK 绝对是 java 编程的标杆，我们很多都可以从 JDK 中学习：</p><pre><code class="java">import java.io.IOException;import java.io.PrintStream;import java.io.PrintWriter;import java.io.InputStream;import java.io.OutputStream;import java.io.Reader;import java.io.Writer;import java.io.OutputStreamWriter;import java.io.BufferedWriter;import java.security.AccessController;import java.security.PrivilegedAction;import sun.util.spi.XmlPropertiesProvider;</code></pre><p>这是<code>java.util.Properties</code>中的 import 声明，可以看出，使用了单类型导入声明，所以，在没有其他要求的情况下，我们尽量还是使用单类型导入。</p><h2 id="文末思考"><a href="#文末思考" class="headerlink" title="文末思考"></a>文末思考</h2><ol><li>java 的<code>import</code>是类导入声明，不会将文件写入到编译后的 class 文件中</li><li>java 的<code>import</code>有两种导入方式：单类型导入、按需类型导入</li><li>按需类型导入只会在编译过程中有性能损失，在运行期与单类型导入无差别</li><li>JDK 源码中，大部分使用了单类型导入。</li></ol><hr><p>你好，我是看山，公众号：看山的小屋，10 年老后端，Apache Storm、WxJava、Cynomys开源贡献者。主业：程序猿，兼职：架构师。游于码界，戏享人生。</p><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/java-import-package/">java import 导入包</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113487825" target="_blank" rel="noopener">java import 导入包</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      java 的`import`是类导入声明，不会将文件写入到编译后的 class 文件中；java 的`import`有两种导入方式：单类型导入、按需类型导入；按需类型导入只会在编译过程中有性能损失，在运行期与单类型导入无差别；JDK 源码中，大部分使用了单类型导入。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="import" scheme="https://www.howardliu.cn/tags/import/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾收集算法</title>
    <link href="https://www.howardliu.cn/algo-for-jvm-gc/"/>
    <id>https://www.howardliu.cn/algo-for-jvm-gc/</id>
    <published>2021-01-24T13:48:58.000Z</published>
    <updated>2021-01-24T13:48:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是根据周志明老师的《深入理解Java虚拟机》整理的学习笔记，后续会更新在<a href="https://github.com/howardliu-cn/Rebuild2020/tree/master/Java/JVM/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">深入理解Java虚拟机</a>中，希望能够帮到一些需要速成的同学。</p></blockquote><p>从如何判断对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两大类也常被称作“直接垃圾收集”和“间接垃圾收集”。</p><a id="more"></a><blockquote><p>主流 GC 算法均未涉及引用计数式垃圾收集，所以本文所有算法均为追踪式垃圾收集的范畴。</p></blockquote><h2 id="1-分代收集理论"><a href="#1-分代收集理论" class="headerlink" title="1. 分代收集理论"></a>1. 分代收集理论</h2><p>分代收集（Generational Collection），建立在三个假设上：</p><ol><li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li><li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难消亡。</li><li>跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</li></ol><p>根据前两个分代假说，奠定了多款常用垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据年龄分配到不同的区域中存储。</p><p>一般至少将 Java 堆划分为新生代（Young Generation）和老年代（Old Generation）。</p><p>分代收集理论除了划分内存区域，还需要解决其他问题，比如：<strong>对象不是孤立的，对象之间会存在跨代引用</strong>。为了解决这个问题，就出现了第三条假说。</p><p>第三条假说是根据前两条假说逻辑推理得出的隐含推论：存在相互引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。</p><p>依据这条假说，我们就不应再为少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每个对象是否存在及存在哪个跨代引用，只需在新生代上建立一个全局的数据结构，被称为记忆集（Remembered Set），这个结构把老年代划分成若干小块，标识老年代哪一块内存会存在跨代引用。当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。</p><p>名词解释：</p><ul><li>部分收集（Partial GC）：指目标不是完整收集整个 Java 堆的垃圾收集<ul><li>新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集</li><li>老年代收集（Major GC/Old GC）：值目标只是老年代的垃圾收集。目前只有 CMS 收集器会有单独收集老年代的行为。</li></ul></li><li>混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。<ul><li>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</li></ul></li></ul><h2 id="2-标记-清除算法"><a href="#2-标记-清除算法" class="headerlink" title="2. 标记-清除算法"></a>2. 标记-清除算法</h2><p>标记-清除（Mark-Sweep）算法：标记所有需要回收对象，在标记完成后，统一回收掉所有被标记的对象；或者，标记存活的对象，统一回收所有未被标记的对象。</p><p>缺点：</p><ol><li>执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分需要被回收，这时必须进行大量标记和清除的动作，导致标记和清除的执行效率随对象数量增长而降低；</li><li>内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后程序运行过程中需要分配较大对象时无法找到足够连续的内存而不得不触发另一次垃圾收集动作。</li></ol><p><img src="http://static.howardliu.cn/java/mark-sweep.jpg" alt="标记-清除算法"></p><h2 id="3-标记-复制算法"><a href="#3-标记-复制算法" class="headerlink" title="3. 标记-复制算法"></a>3. 标记-复制算法</h2><p>半区复制（Semispace Copying）算法：将可用内存按容量划分大小相等的两块，每次只使用其中一块。当一块内存用完了，就将还存活着的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。</p><p><img src="http://static.howardliu.cn/java/mark-copying.jpg" alt="标记-复制算法"></p><p>Appel 式回收：把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾收集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。如果 Survivor 空间不足以容纳 Minor GC 后存活对象时，这些对象通常分配进入老年代。</p><p>HotSpot 虚拟机默认 Eden 和 Survivor 大小比例是 8:1，即每次新生代中可用内存空间为整个新生代容量的 90%，只有一个 Survivor 空间被浪费。</p><p>Appel 式回收的理论依据：IBM 公司的研究表明，新生代中的对象有 98%熬不过第一轮收集。</p><h2 id="4-标记-整理算法"><a href="#4-标记-整理算法" class="headerlink" title="4. 标记-整理算法"></a>4. 标记-整理算法</h2><p>标记-整理（Mark-Compact）算法，其中标记过程与“标记-清除”算法一样，整理过程是让所有存储对象都向内存空间的一端移动，然后直接清理掉边界以外的内存。</p><p><img src="http://static.howardliu.cn/java/mark-compact.jpg" alt="标记-整理算法"></p><p>标记整理算法的弊端是移动存活对象并更新所有引用工作量比较大，而且需要 Stop The World，会造成延迟。</p><p>标记清除算法的弊端是由于空间碎片化，需要复杂的内存分配器和内存访问器，会影响吞吐量。</p><p>HotSpot 虚拟机里面关注吞吐量的的 Parallel Scavenge 收集器是基于标记-整理算法的，关注延迟的 CMS 收集器是基于标记-清除算法的。</p><p>还有一种“和稀泥”的方式，大部分时间使用标记-清除算法，容忍内存碎片，当内存碎片影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/algo-for-jvm-gc/">JVM 垃圾收集算法</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/113098581" target="_blank" rel="noopener">JVM 垃圾收集算法</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      从如何判断对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和“追踪式垃圾收集”（Tracing GC）两大类，这两大类也常被称作“直接垃圾收集”和“间接垃圾收集”。
    
    </summary>
    
    
      <category term="jvm" scheme="https://www.howardliu.cn/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://www.howardliu.cn/tags/jvm/"/>
    
      <category term="gc" scheme="https://www.howardliu.cn/tags/gc/"/>
    
  </entry>
  
  <entry>
    <title>软件架构-缓存技术</title>
    <link href="https://www.howardliu.cn/caching-techniques/"/>
    <id>https://www.howardliu.cn/caching-techniques/</id>
    <published>2021-01-17T06:57:07.000Z</published>
    <updated>2021-01-17T06:57:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/software-architecture/pipit-5683656_1920.jpg" alt="软件架构-缓存技术"></p><blockquote><p>本文源自并发编程网的翻译邀请，翻译的是 Jakob Jenkov 的 <a href="http://tutorials.jenkov.com/software-architecture/index.html" target="_blank" rel="noopener">《软件架构》</a> 中关于缓存技术的内容，虽然是 2014 年的文章，但是从软件架构层面上，并不过时。</p></blockquote><a id="more"></a><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>缓存是一种加速数据查找（数据读取）的技术，直接读取本地缓存的数据，而不是从数据源读取数据，数据源包括数据库、其他远程系统。</p><p><img src="http://static.howardliu.cn/software-architecture/caching-1.png" alt="caching"></p><p>缓存是比源数据更靠近使用方的一块存储空间，可以更快的读取操作。缓存的存储介质一般是内存或磁盘，很多时候会选择内存作为缓存介质，但是内存缓存会在系统重启时丢失数据。</p><p>在软件系统中，数据缓存存在多层缓存级别或多层缓存系统。在 web 应用中，缓存至少有 3 种存储位置，如下图所示：</p><p><img src="http://static.howardliu.cn/software-architecture/caching-1-2.png" alt="caching"></p><p>在 web 应用中，我们会使用各种各样的数据库存储数据，这些数据库可以将数据存放在内存中，以便我们直接读取，而不需要从磁盘中读取数据。web 服务器可以在内存中缓存图片、css 文件、js 文件等，不需要每次需要的时候从硬盘中访问文件。web 应用可以将从数据库读取的数据缓存起来，这样就不需要每次使用的时候都通过网络从数据库中读取数据了。最后，浏览器也可能存储静态文件和数据。在支持 HTML5 的浏览器中，有 localstorage 存储空间、应用数据缓存、本地 sql 存储等技术支持缓存。</p><p>当我们提到缓存的时候，有下面几项内容需要考虑：</p><ul><li>写缓存</li><li>保持缓存和远程系统数据同步</li><li>管理缓存大小</li></ul><p>我会在接下来的内容中讨论这几项内容。</p><h2 id="写缓存"><a href="#写缓存" class="headerlink" title="写缓存"></a>写缓存</h2><p>第一项挑战是从远程系统中读取数据写到缓存中，一般有两种方式：</p><ul><li>提前写缓存</li><li>用时写缓存</li></ul><p>提前写缓存是在系统启动的时候，就将需要的数据缓存起来。要做到这一点，需要提前知道哪些数据需要缓存。但是我们有时候并不知道哪些数据需要在系统启动时候就缓存起来。</p><p>用时写缓存是说，在第一次使用数据的时候，将数据缓存起来，之后就可以使用缓存中的数据了。这种操作的方式是，首先检查缓存中是否有数据，有就直接使用，如果没有，就从远程系统读取数据，然后写入缓存中。</p><p>下表中我列出了提前写入和用时写入的优缺点：</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>提前写缓存</td><td>比用时写入减少了第一次缓存数据的延迟</td><td>系统启动初始化缓存数据的时候，需要比较长的时间。而且，有可能缓存的数据永远不会被用到。</td></tr><tr><td>用时写缓存</td><td>缓存的数据都是需要被用到的数据，而且没有启动延迟</td><td>在第一次缓存数据的时候，用的时间比较长，可能导致用户体验不一致</td></tr></tbody></table><p>当然，在真正实践过程中，我们可能两种方式并用：我们可以对热点数据使用提前缓存的方式，对其他数据使用用时缓存的方式。</p><h2 id="保持缓存和远程系统数据同步"><a href="#保持缓存和远程系统数据同步" class="headerlink" title="保持缓存和远程系统数据同步"></a>保持缓存和远程系统数据同步</h2><p>缓存数据的一个巨大挑战是保持缓存数据与远程系统数据保持同步，也就是数据一致。根据系统结构的不同，一般有不同的方式实现这个，我们来聊聊这几种方式。</p><h3 id="直接式缓存"><a href="#直接式缓存" class="headerlink" title="直接式缓存"></a>直接式缓存</h3><p>直写式缓存是允许读写缓存的一种方式，这种方式是，保存缓存数据的计算机，在将数据写入缓存的同时，将数据写到远程系统中。简单说就是，写入操作被写到远程系统中。</p><p>只有远程系统的数据只能被直写式缓存修改时，这种方式才起作用。如果所有的数据读写都要经过直写式缓存系统，那就很容易将写入的数据更新到远程系统中，保持缓存与远程系统数据的一致性。</p><h3 id="基于过期时间"><a href="#基于过期时间" class="headerlink" title="基于过期时间"></a>基于过期时间</h3><p>如果远程系统可以不依赖远程系统进行数据更新，那缓存和远程系统之间数据同步就很难通过直写式缓存方式保证了。</p><p>保持缓存数据同步的一种方法是，为数据设置一个缓存时间。当数据过期时，就把这些数据从缓存中清除。如果再次需要读取这些数据，可以从远程系统中读取最新的数据缓存起来。</p><p>数据过期时间取决于系统需要，有些类型的数据（比如文章），可能不需要随时的完全更新，可以设置 1 小时的过期时间。对于某些文章，你甚至可以忍受 24 小时的过期时间。</p><p>需要注意的是，如果过期时间比较短，可能会频繁读取远程系统，降低缓存的作用。</p><h3 id="主动过期"><a href="#主动过期" class="headerlink" title="主动过期"></a>主动过期</h3><p>还有一种方式是主动过期，是指主动更新缓存数据。比如，远程系统数据更新时，发送一条消息到缓存系统中，指示系统数据已被更新，可以将数据设置为过期。</p><p>主动过期的优点是，可能保证远程系统数据更新后，缓存数据被尽快的更新。还有一个附加好处是“基于过期时间”方式没有办法是实现的，就是不会频繁更新没有修改的数据。</p><p>主动过期的缺点是，需要能够检测远程系统数据的变化。如果远程系统是一个关系型数据库，可以被不同的机制更新数据，那每种更新机制都需要报告他们更新了哪些数据，否则，就没有办法向缓存数据的系统通知过期消息了。</p><h2 id="管理缓存大小"><a href="#管理缓存大小" class="headerlink" title="管理缓存大小"></a>管理缓存大小</h2><p>管理缓存大小，是一个重要的方面。许多系统存储了大量数据，以至于不可能将所有数据都存储在缓存中。因此，需要一种机制来管理缓存的数据量。管理缓存大小通常是将不需要的缓存数据清除，来腾出足够的空间。一般有下面几种方式：</p><ul><li>基于时间清理</li><li>先进先出（FIFO）</li><li>先进后出（FILO）</li><li>最少被使用</li><li>最小访问间隔</li></ul><p>基于时间清理方式是类似于前面提到的基于时间过期。除了可以保持数据与远程系统同步，还能够减少缓存数据的大小。可以开启一个单独的监听线程，也可以在读写新值的时候清理数据。</p><p>先进先出清理方式意味着，当写入一个新的缓存的时候，就需要删除最早插入的缓存值。如果空间足够，也是可以不删除任何数据的。</p><p>先进后出的方式正好和先进先出相反，这种方式对于先存储的数据时热点数据的情况比较有用。</p><p>最少被使用清理方式是首先清理访问次数最少的缓存数据。这种方式的目的是避免清理热点数据，为了实现这种方式，需要记录缓存数据被访问的次数。需要注意一个问题，缓存中的旧值可能有较高的访问次数，这样就意味着这些旧值不会被清理。比如一篇旧文章的缓存，以前被访问过很多次，但是最近很少访问了，但是因为原来的访问量很高，尽管目前访问量较低，也不会被清理。为了避免这种情况，访问次数可以是针对 N 个小时统计。</p><p>最小访问间隔清理方式是将访问时间间隔考虑在内。访问某个缓存数据时，就需要标记访问该数据的时间并增加访问次数。第二次访问这个缓存数据时，就增加访问次数，并计算平均访问时间。那些曾经是热点数据，被频繁访问，但是最近访问时间间隔变长，访问频率下降的数据，其平均访问时间会降低，当降到足够低的时候，就会被清理。</p><p>有一种变化方式是，只计算最后 N 次访问的时间。N 可以是 100、1 或者其他任何有意义的数。每当访问计数到 N 时，访问计数被重置为 0，记录下来访问时间。这种方式可以更快的清理热度下降的数据。</p><p>还有一种变化方式是，定期重置访问计数，并且只使用最小访问的清理方式。比如，每缓存一个小时的数据，前一个小时的访问计数会存储在另一个变量中，以便决策清理时使用。下一个小时访问计数重置为 0。这种机制具有上次变化相同的效果。</p><p>最后两个变体之间的差异总结起来就是在每次缓存检查时，访问计数是否已达到 N，或者时间间隔是否已超过 Y。第一种方式是每隔 N 次访问一次系统时钟，而第二种方式在每次访问时都读取一次系统时钟（查看时间间隔是否已过期）。因为检查一个整数通常比读取系统时钟快，所以我会选择第一种方式。</p><p>请记住，即使使用缓存大小管理系统，也需要清理、读取和存储数据，以保证他们能够与远程系统保持一致。尽管缓存的数据被大量访问而驻留在系统中，有时候也需要与远程系统同步。</p><h2 id="服务器集群中的缓存"><a href="#服务器集群中的缓存" class="headerlink" title="服务器集群中的缓存"></a>服务器集群中的缓存</h2><p>单一服务中的缓存设计更加简单，因为你能够保证，所有写入操作都通过一个服务器，可以使用直写式缓存方式。但是在分布式集群中，情况会比较复杂，下图说明了这种情况：</p><p><img src="http://static.howardliu.cn/software-architecture/caching-2.png" alt="caching"></p><p>简单的使用直写式缓存只会更新写操作的服务器上的缓存，集群中其他服务器对此完全不知情，也就不会更新数据。</p><p>在服务器集群中，可以使用基于时间的过期策略或者主动过期策略，来保证缓存数据与远程系统的同步。</p><h2 id="缓存产品"><a href="#缓存产品" class="headerlink" title="缓存产品"></a>缓存产品</h2><p>实现自己的缓存系统并不难弄，取决于是否需要深度定制。如果没有必要自己实现缓存系统，可以用已经现成的缓存产品。比如：</p><ul><li><a href="http://memcached.org/" target="_blank" rel="noopener">Memcached</a></li><li><a href="http://ehcache.org/" target="_blank" rel="noopener">Ehcache</a></li><li><a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>【译者加】</li></ul><p>我不知道这些产品是否能够满足需要，但是我知道他们用的比较广泛。</p><hr><p>原文链接：<a href="http://tutorials.jenkov.com/software-architecture/caching-techniques.html" target="_blank" rel="noopener">Caching Techniques</a><br>翻译: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>译文链接: <a href="https://www.howardliu.cn/caching-techniques/">软件架构-缓存技术</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/112759115" target="_blank" rel="noopener">软件架构-缓存技术</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      缓存是一种加速数据查找（数据读取）的技术，直接读取本地缓存的数据，而不是从数据源读取数据，数据源包括数据库、其他远程系统。
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="缓存" scheme="https://www.howardliu.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>学非探其花 要自拔其根</title>
    <link href="https://www.howardliu.cn/keep-moving-forward/"/>
    <id>https://www.howardliu.cn/keep-moving-forward/</id>
    <published>2021-01-10T12:20:18.000Z</published>
    <updated>2021-01-10T12:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/raving/coast-5870088_1920.jpg" alt="学非探其花 要自拔其根"></p><p>昨天训练营最后一次直播答疑，问了老师一个问题：“课程中很多内容，感觉自己会，但是让自己讲却讲不出来，或者就算讲出来也不够专业，请老师指点一下？”</p><p>老师耐心做了解答，主要说了两点：</p><ol><li>不够透彻，没有抓住核心，更深层次的东西，浮于表面，没有把握和底气。</li><li>缺乏实践，想办法用，想办法深入进去。</li></ol><p>思考一下转化成自己的理解：</p><ol><li>学非探其花，要深拔其根。想要能够讲出来，必须得抓住核心，而不是流于表面。</li><li>世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。想要成长，就得比别人付出更多的努力。</li></ol><p>然后就想到自己14年的一篇旧文，这里再翻出来。</p><a id="more"></a><p>这段时间因为种种事情，感觉自己很浮躁。作为一名IT民工，把自己当做是一个做技术的人，所以一直希望自己是能够踏踏实实做事的人。不管周围如何变化，希望自己能够沉下心来好好的工作、好好学习。</p><p>毕业到现在两年多了，工作上有一些富裕时间可以自己自由安排。刚开始充分利用这些时间，深入学习一些工作中使用的技术，也算是小有成效。也是因为那段时间自己的努力，先是修改项目中使用的一个下拉菜单的插件，深得开发经理的赞赏，在之后移植手机APP的开发过程中，担任骨干开发人员。</p><p>但随着时间的推进，在项目组中担任角色的变化，看到了当前很多流行的技术后，开始这一头、那一脚的学习，Shell、Python、Pro C、NodeJS、Lucene、Solr、Hadoop等等等等，很多都是蜻蜓点水般的了解一下，有的甚至连水都没有沾到。有时候还自以为是的觉得自己很牛X，幸好有一天，突然感觉自己什么都不懂，什么都不会了，才算是幡然悔悟，开始反省自己。</p><p>佛家有三种境界：</p><ul><li>第一境界：看山是山，看水是水；</li><li>第二境界：看山不是山，看水不是水；</li><li>第三境界：看山是山，看水是水。</li></ul><p>跟朋友描述了一下当前的状态，朋友笑称境界提升了。但自己知自家事，我现在还在第一境界中，甚至连第二境界还没有达到，不禁心中很是失落，自己这段时间算是浪费了。</p><p>软件行业本就是新技术层出不穷，更新迭代频繁，想要学会所有的技术是不可能的。我就是陷入的追逐新技术的怪圈中，就像是捉蝴蝶，一会捉这只，一会捉那只，到最后，一只也没有捉到。</p><p>庄子有言：吾生也有涯，而知也无涯，以有涯随无涯，殆已。</p><p>古人诚不我欺。</p><p>知道了自己错在哪，似乎“怎么做”也就呼之欲出。有句话叫做“大道同途”，用在软件方面，应该可以理解为，很多类似的技术其本质都是一样的，没有必要学习所有的技术，只要掌握其中的一部分，其他的可以根据这一部分进行推导，由点及面，就仿佛一张蜘蛛网，掌握了中间的一个点，慢慢的向外扩展，逐步掌握周边的技术。</p><p>杜牧曾经劝诫其子：学非探其花，要自拔其根。</p><p>学习并不能像观赏花卉，应该探其根本，掌握其精髓。当真正掌握精髓之后，便能够举一反三，掌握很多东西了。之前自己学习新技术的时候，只是流于表面，写个Hello World就以为看到了全世界，没有深入学习其中的原理、精髓。</p><p>“练武不练功，到老一场空。”,这些技术就相当于武，是招式架子，而其中的原理，就相当于功，内家功法。</p><p>“阿弥陀佛，善哉善哉，施主悟了。”</p><p>“呵呵。”</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/keep-moving-forward/">学非探其花 要自拔其根</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      学非探其花，要深拔其根。想要能够讲出来，必须得抓住核心，而不是流于表面。世之奇伟、瑰怪，非常之观，常在于险远，而人之所罕至焉，故非有志者不能至也。想要成长，就得比别人付出更多的努力。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="学非探其花" scheme="https://www.howardliu.cn/tags/%E5%AD%A6%E9%9D%9E%E6%8E%A2%E5%85%B6%E8%8A%B1/"/>
    
      <category term="要自拔其根" scheme="https://www.howardliu.cn/tags/%E8%A6%81%E8%87%AA%E6%8B%94%E5%85%B6%E6%A0%B9/"/>
    
  </entry>
  
  <entry>
    <title>我从 HX 辞职了</title>
    <link href="https://www.howardliu.cn/i-resigned-from-hx/"/>
    <id>https://www.howardliu.cn/i-resigned-from-hx/</id>
    <published>2020-12-31T10:53:57.000Z</published>
    <updated>2020-12-31T10:53:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/thinking/fire-4892711_1920.jpg" alt="我从 HX 辞职了"></p><blockquote><p>这篇文章早就想写了，结果一直拖到 2020 最后一天，借着年终总结的感觉，记一下流水账，算是给这段经历画上一个句号。</p></blockquote><p>2020 年十一假期后和领导提了离职，思考很久的结果。在这待了整三年，一届高中生毕业了。</p><a id="more"></a><p>因为一些原因，离职过程匆匆忙忙的，没有好好告别，总感觉差点意思，这里先胡乱说几句，算是开始画句号，毕竟三年时间，没做什么事，但也做了很多事。本文通篇灌水，记一下流水账。</p><p>HX 旗下有一个钻戒品牌相信很多人听过或者见过，全国线下门店 600 多家，近两年 618、双十一钻石类目第一。这样想来，好像待过的几家公司，都在各自业务领域做的比较牛。</p><p>这 3 年里，我算是见证了它在线上营销从 0 到 1，再到第一的过程，虽然我就是个程序猿，但是那个时候，开发和线上运营都在一个中心，虽然荣誉和奖金都是别人的事，但吃个牛还是挺爽的。</p><p>到 HX 是大哥叫去了，2017 年 11 月 1 号入职。因为当时官方商城和天猫旗舰店都没什么量，而且双十一那天有考试，所以妥妥的在家睡了个好觉，三年来唯一一次。听说那天晚上大哥、周老板、小文几个人熬了个大夜，从 0 到 1 的阶段真的挺难的。在大家都关心流量的时候，想要从平台分一些流量、从别人嘴里抢一些流量太难了。</p><p>刚去 HX，就碰到了坑人的官网改版，而且当时开发负责人闹情绪离职，啥也没交接就休假了。我和来福一脸懵逼的开始弄，偌大一个工程 12 月 20 上线。当时特别希望有个人可以给说一下业务，可惜没有，只能摸着石头过河。万幸的是，组里其他人都很负责任，而且需要改造的系统比较 low，有问题就直接暴力改造。最后准时上线，挺好。</p><p>后来是甜蜜秀项目，通过活动奖品引诱用户发文拉赞，用来获客。第一次活动正好是春节期间，结果有人刷赞，我还以为是系统 bug，过年期间查了 N 遍，也没多休息，初七就赶回了公司。万没想到是，是花钱买赞的。也是这次之后，知道风控的重要性了。</p><p>后续就是会员中心升级和模块化、香水项目、门店二维码、亲子品牌官网改版……太多了，不想流水账了，说下几个大的就好。</p><p>18 年因为香水项目折腾的太惨，启动了中台项目，9 月份开始，第二年 5 月份一期上线。我也是在这个过程中，经历了架构设计、系统设计、功能开发、团队管理，每一个都有很多值得总结的点，立个 flag，要在 2021 年总结出来，要不然，那段痛苦的经历就白白浪费了。</p><p>中台其实是比较挑公司的，对于 HX 这种有 N 多个品牌独立运营、对接 N 多个渠道的公司，挺需要一个可以支撑这种变化的 IT 系统的。只不过是公司的人不清楚其中的价值，当然也不能全怪他们，这个系统当时做的比较匆忙，很多地方有问题，而且后期人手太少、资源不足，很多问题没有时间修复，即使这样，也是在疫情期间支持了 7 天完成 3 个完整电商小程序项目、从 0 开始的优惠券营销系统的上线。所以说，即使是这个到处是破洞的系统，也不是随便一个系统就可以替换的，就算百胜的系统也不行。（说到百胜，是因为听说我走了之后要换中台，要用百胜的系统，调研结果是，需要 300w，还只能满足 50%的功能。）</p><p>其实对于 HX 是有感情的，毕竟待了三年，光加班时间加起来都可以调休好几个月了（可惜都过期了），我走的时候，看到了对系统研发的不重视，就在刚才，得知对线上营销也不重视了。感觉现在她在逆风而行，毕竟现在 IT 建设是一个公司发展的基石，可能我辈凡人体会不到大领导的苦心吧。所以，思考了很久，还是离开吧。</p><p>交接的时候，交接文档写了 30 多页，有两页是我负责过的 34 个研发项目，剩下都是给运维的一些介绍。挺无奈的，被交接人完全没有参与过这些项目，还很轻视这些，那个目录，本意是根据他提出的问题，完善交接文档，结果人家一点不看，这就没有办法了。不过后来听说，他很长一段时间，都没办法在本地启动项目，挺嘲讽的一件事。</p><p>休假的时候，做了个小手术，在医院呆了 17 天，算是 3 年来完全放空自己的一段时间，也能好好思考这三年的得失，收获挺多。所以，2021 年，无论多忙，都要留出思考的时间。</p><p>在 HX 的流水账写完了，说一下接下来的计划：</p><ul><li>伤口恢复差不多之后，请老同事吃顿散伙饭</li><li>补上架构师训练营落下的作业，先达到毕业标准</li><li>在新公司多学多看，之前吃亏在没有见识，现在有见识的机会得抓住</li><li>完成代办里面那些要写的总结，经历过的不能白经历</li><li>2021 年至少每周一篇更新</li><li>继续 Rebuild2020 那个项目</li></ul><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/i-resigned-from-hx/">我从 HX 辞职了</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/112055786" target="_blank" rel="noopener">我从 HX 辞职了</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      2020 年最后一篇博文，记一些流水账。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="辞职" scheme="https://www.howardliu.cn/tags/%E8%BE%9E%E8%81%8C/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：如何优雅的处理异常</title>
    <link href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/"/>
    <id>https://www.howardliu.cn/springboot-action-gracefully-response-exception/</id>
    <published>2020-09-11T02:55:46.000Z</published>
    <updated>2020-09-11T02:55:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/springboot/sea-4841142_1920.jpg" alt="SpringBoot 实战：如何优雅的处理异常"></p><p>前段时间写了一篇<a href="https://www.howardliu.cn/springboot-action-gracefully-response/">关于实现统一响应信息的博文</a>，根据文中实战操作，能够解决正常响应的一致性，但想要实现优雅响应，还需要优雅的处理异常响应，所以有了这篇内容。</p><p>作为后台服务，能够正确的处理程序抛出的异常，并返回友好的异常信息是非常重要的，毕竟我们大部分代码都是为了 处理异常情况。而且，统一的异常响应，有助于客户端理解服务端响应，并作出正确处理，而且能够提升接口的服务质量。</p><a id="more"></a><p>SpringBoot提供了异常的响应，可以通过<code>/error</code>请求查看效果：</p><p><img src="http://static.howardliu.cn/springboot/springboot-error.png" alt="SpringBoot错误页面"></p><p>这是从浏览器打开的场景，也就是请求头不包括<code>content-type: applicaton/json</code>，大白板一个，和友好完全不搭边。</p><p><img src="http://static.howardliu.cn/springboot/springboot-error-json.png" alt="SpringBoot错误响应"></p><p>这是请求头包括<code>content-type: applicaton/json</code>时的响应，格式还行，但是我们还需要加工一下，实现自定义的异常码和异常信息。</p><p>本文主要是针对RESTful请求的统一响应，想要实现的功能包括：</p><ol><li>自动封装异常，返回统一响应</li><li>异常信息国际化</li></ol><h2 id="定义异常响应类"><a href="#定义异常响应类" class="headerlink" title="定义异常响应类"></a>定义异常响应类</h2><p>当程序发送错误时，不应该将晦涩的堆栈报告信息返回给API客户端，从某种意义讲，这是一种不礼貌的和不负责任的行为。</p><p>我们在<a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a>中，定义了一个响应类，为什么还要再定义一个异常响应类呢？其实是为了语义明确且职责单一。类图如下：</p><p><img src="http://static.howardliu.cn/springboot/ErrorResponse1.png" alt="定义异常响应类"></p><p>具体代码如下：</p><p>基础类<code>BaseResponse</code>：</p><pre><code class="java">@Datapublic abstract class BaseResponse {    private Integer code;    private String desc;    private Date timestamp = new Date();    private String path;    public BaseResponse() {    }    public BaseResponse(final Integer code, final String desc) {        this.code = code;        this.desc = desc;    }    public BaseResponse(final Integer code, final String desc, final String path) {        this.code = code;        this.desc = desc;        this.path = path;    }}</code></pre><p>异常类<code>ErrorResponse</code>：</p><pre><code class="java">@EqualsAndHashCode(callSuper = true)@Datapublic class ErrorResponse extends BaseResponse {    public ErrorResponse(final Integer code, final String desc) {        super(code, desc);    }    public ErrorResponse(final Integer code, final String desc, final WebRequest request) {        super(code, desc, extractRequestURI(request));    }    public ErrorResponse(final HttpStatus status, final Exception e) {        super(status.value(), status.getReasonPhrase() + &quot;: &quot; + e.getMessage());    }    public ErrorResponse(final HttpStatus status, final Exception e, final WebRequest request) {        super(status.value(), status.getReasonPhrase() + &quot;: &quot; + e.getMessage(), extractRequestURI(request));    }    private static String extractRequestURI(WebRequest request) {        final String requestURI;        if (request instanceof ServletWebRequest) {            ServletWebRequest servletWebRequest = (ServletWebRequest) request;            requestURI = servletWebRequest.getRequest().getRequestURI();        } else {            requestURI = request.getDescription(false);        }        return requestURI;    }}</code></pre><h2 id="定义异常枚举类"><a href="#定义异常枚举类" class="headerlink" title="定义异常枚举类"></a>定义异常枚举类</h2><p>为了能够规范响应码和响应信息，我们可以定义一个枚举类。</p><p><img src="http://static.howardliu.cn/springboot/ResponseEnum.png" alt="定义异常枚举类"></p><p>枚举接口<code>ResponseEnum</code>：</p><pre><code class="java">public interface ResponseEnum {    Integer getCode();    String getMessage();    default String getLocaleMessage() {        return getLocaleMessage(null);    }    String getLocaleMessage(Object[] args);}</code></pre><p>枚举类<code>CommonResponseEnum</code>：</p><pre><code class="java">public enum CommonResponseEnum implements ResponseEnum {    BAD_REQUEST(HttpStatus.BAD_REQUEST.value(), &quot;Bad Request&quot;),    NOT_FOUND(HttpStatus.NOT_FOUND.value(), &quot;Not Found&quot;),    METHOD_NOT_ALLOWED(HttpStatus.METHOD_NOT_ALLOWED.value(), &quot;Method Not Allowed&quot;),    NOT_ACCEPTABLE(HttpStatus.NOT_ACCEPTABLE.value(), &quot;Not Acceptable&quot;),    REQUEST_TIMEOUT(HttpStatus.REQUEST_TIMEOUT.value(), &quot;Request Timeout&quot;),    UNSUPPORTED_MEDIA_TYPE(HttpStatus.UNSUPPORTED_MEDIA_TYPE.value(), &quot;Unsupported Media Type&quot;),    INTERNAL_SERVER_ERROR(HttpStatus.INTERNAL_SERVER_ERROR.value(), &quot;Server Error&quot;),    SERVICE_UNAVAILABLE(HttpStatus.SERVICE_UNAVAILABLE.value(), &quot;Service Unavailable&quot;),    ILLEGAL_ARGUMENT(4000, &quot;Illegal Argument&quot;),    DATA_NOT_FOUND(4004, &quot;Data Not Found&quot;),    USER_NOT_FOUND(4104, &quot;User Not Found&quot;),    MENU_NOT_FOUND(4204, &quot;Menu Not Found&quot;),    INTERNAL_ERROR(9999, &quot;Server Error&quot;),    ;    private final Integer code;    private final String message;    private MessageSource messageSource;    CommonResponseEnum(final Integer code, final String message) {        this.code = code;        this.message = message;    }    @Override    public Integer getCode() {        return code;    }    @Override    public String getMessage() {        return message;    }    @Override    public String getLocaleMessage(Object[] args) {        return messageSource.getMessage(&quot;response.error.&quot; + code, args, message, LocaleContextHolder.getLocale());    }    public void setMessageSource(final MessageSource messageSource) {        this.messageSource = messageSource;    }    @Component    public static class ReportTypeServiceInjector {        private final MessageSource messageSource;        public ReportTypeServiceInjector(final MessageSource messageSource) {            this.messageSource = messageSource;        }        @PostConstruct        public void postConstruct() {            for (final CommonResponseEnum anEnum : CommonResponseEnum.values()) {                anEnum.setMessageSource(messageSource);            }        }    }}</code></pre><p>需要注意的是，我们在异常枚举类中定义了<code>ReportTypeServiceInjector</code>类，这个类的作用是为枚举类注入<code>MessageSource</code>对象，是为了实现异常信息的国际化。这部分功能Spring已经封装好了，我们只需要在resources目录中定义一组<code>messages.properties</code>文件就可以了，比如：</p><p>message.properties定义默认描述：</p><pre><code class="properties">response.error.4000=[DEFAULT] Illegal Argumentsresponse.error.4004=[DEFAULT] Not Found</code></pre><p>messages_zh_CN.properties定义中文描述：</p><pre><code class="properties">response.error.4004=对应数据未找到response.error.9999=系统异常，请求参数: {0}</code></pre><p>messages_en_US.properties定义英文描述：</p><pre><code class="properties">response.error.4004=Not Found</code></pre><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>Java和Spring中提供了很多可用的异常类，可以满足大部分场景，但是有时候我们希望异常类可以携带更多信息，所以还是需要自定义异常类：</p><ul><li>可以携带我们想要的信息；</li><li>有更加明确语义；</li><li>附带效果，可以知道这是手动抛出的业务异常。</li></ul><p>上代码：</p><pre><code class="java">@Data@EqualsAndHashCode(callSuper = true)public class CodeBaseException extends RuntimeException {    private final ResponseEnum anEnum;    private final Object[] args;// 打印参数    private final String message;// 异常信息    private final Throwable cause;// 异常栈    public CodeBaseException(final ResponseEnum anEnum) {        this(anEnum, null, anEnum.getMessage(), null);    }    public CodeBaseException(final ResponseEnum anEnum, final String message) {        this(anEnum, null, message, null);    }    public CodeBaseException(final ResponseEnum anEnum, final Object[] args, final String message) {        this(anEnum, args, message, null);    }    public CodeBaseException(final ResponseEnum anEnum, final Object[] args, final String message, final Throwable cause) {        this.anEnum = anEnum;        this.args = args;        this.message = message;        this.cause = cause;    }}</code></pre><h2 id="自定义异常信息处理类"><a href="#自定义异常信息处理类" class="headerlink" title="自定义异常信息处理类"></a>自定义异常信息处理类</h2><p>前期准备工作完成，接下来定义异常信息处理类。</p><p>Spring自带的异常信息处理类往往不能满足我们实际的业务需求，这就需要我们定义符合具体情况的异常信息处理类，在自定义异常信息处理类中，我们可以封装更为详细的异常报告。我们可以扩展Spring提供的ResponseEntityExceptionHandler类定义自己的异常信息处理类，站在巨人的肩膀上，快速封装自己需要的类。</p><p>通过源码可以看到，<code>ResponseEntityExceptionHandler</code>类的核心方法是<code>public final ResponseEntity&lt;Object&gt; handleException(Exception ex, WebRequest request)</code>，所有的异常都在这个方法中根据类型进行处理，我们只需要实现具体的处理方法即可：</p><pre><code class="java">@RestControllerAdvice@Slf4jpublic class UnifiedExceptionHandlerV2 extends ResponseEntityExceptionHandler {    private static final String ENV_PROD = &quot;prod&quot;;    private final MessageSource messageSource;    private final Boolean isProd;    public UnifiedExceptionHandlerV2(@Value(&quot;${spring.profiles.active:dev}&quot;) final String activeProfile, final MessageSource messageSource) {        this.messageSource = messageSource;        this.isProd = new HashSet&lt;&gt;(Arrays.asList(activeProfile.split(&quot;,&quot;))).contains(ENV_PROD);    }    @Override    protected ResponseEntity&lt;Object&gt; handleExceptionInternal(final Exception e, final Object body, final HttpHeaders headers, final HttpStatus status, final WebRequest request) {        log.info(&quot;请求异常：&quot; + e.getMessage(), e);        if (HttpStatus.INTERNAL_SERVER_ERROR.equals(status)) {            request.setAttribute(WebUtils.ERROR_EXCEPTION_ATTRIBUTE, e, WebRequest.SCOPE_REQUEST);        }        return new ResponseEntity&lt;&gt;(new ErrorResponse(status, e), headers, HttpStatus.OK);    }    @Override    protected ResponseEntity&lt;Object&gt; handleBindException(final BindException ex, final HttpHeaders headers, final HttpStatus status, final WebRequest request) {        log.info(&quot;参数绑定异常&quot;, ex);        final ErrorResponse response = wrapperBindingResult(status, ex.getBindingResult());        return new ResponseEntity&lt;&gt;(response, headers, HttpStatus.OK);    }    @Override    protected ResponseEntity&lt;Object&gt; handleMethodArgumentNotValid(final MethodArgumentNotValidException ex, final HttpHeaders headers, final HttpStatus status, final WebRequest request) {        log.info(&quot;参数校验异常&quot;, ex);        final ErrorResponse response = wrapperBindingResult(status, ex.getBindingResult());        return new ResponseEntity&lt;&gt;(response, headers, HttpStatus.OK);    }    @ExceptionHandler(value = CodeBaseException.class)    @ResponseBody    public ErrorResponse handleBusinessException(CodeBaseException e) {        log.error(&quot;业务异常：&quot; + e.getMessage(), e);        final ResponseEnum anEnum = e.getAnEnum();        return new ErrorResponse(anEnum.getCode(), anEnum.getLocaleMessage(e.getArgs()));    }    @ExceptionHandler(value = Exception.class)    @ResponseBody    public ErrorResponse handleExceptionInternal(Exception e) {        log.error(&quot;未捕捉异常：&quot; + e.getMessage(), e);        final Integer code = INTERNAL_SERVER_ERROR.getCode();        return new ErrorResponse(code, getLocaleMessage(code, e.getMessage()));    }    /**     * 包装绑定异常结果     *     * @param status        HTTP状态码     * @param bindingResult 参数校验结果     * @return 异常对象     */    private ErrorResponse wrapperBindingResult(HttpStatus status, BindingResult bindingResult) {        final List&lt;String&gt; errorDesc = new ArrayList&lt;&gt;();        for (ObjectError error : bindingResult.getAllErrors()) {            final StringBuilder msg = new StringBuilder();            if (error instanceof FieldError) {                msg.append(((FieldError) error).getField()).append(&quot;: &quot;);            }            msg.append(error.getDefaultMessage() == null ? &quot;&quot; : error.getDefaultMessage());            errorDesc.add(msg.toString());        }        final String desc = isProd ? getLocaleMessage(status.value(), status.getReasonPhrase()) : String.join(&quot;, &quot;, errorDesc);        return new ErrorResponse(status.value(), desc);    }    private String getLocaleMessage(Integer code, String defaultMsg) {        try {            return messageSource.getMessage(&quot;&quot; + code, null, defaultMsg, LocaleContextHolder.getLocale());        } catch (Throwable t) {            log.warn(&quot;本地化异常消息发生异常: {}&quot;, code);            return defaultMsg;        }    }}</code></pre><p>如果感觉Spring的<code>ResponseEntityExceptionHandler</code>类不够灵活，也可以完全自定义异常处理类：</p><pre><code class="java">@RestControllerAdvice@Slf4jpublic class UnifiedExceptionHandler {    private static final String ENV_PROD = &quot;prod&quot;;    private final MessageSource messageSource;    private final Boolean isProd;    public UnifiedExceptionHandler(@Value(&quot;${spring.profiles.active:dev}&quot;) final String activeProfile, final MessageSource messageSource) {        this.messageSource = messageSource;        this.isProd = new HashSet&lt;&gt;(Arrays.asList(activeProfile.split(&quot;,&quot;))).contains(ENV_PROD);    }    @ExceptionHandler({            MissingServletRequestParameterException.class,// 缺少servlet请求参数异常处理方法            ServletRequestBindingException.class,// servlet请求绑定异常            TypeMismatchException.class,// 类型不匹配            HttpMessageNotReadableException.class,// 消息无法检索            MissingServletRequestPartException.class// 缺少servlet请求部分    })    public ErrorResponse badRequestException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(BAD_REQUEST.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            NoHandlerFoundException.class// 没有发现处理程序异常    })    public ErrorResponse noHandlerFoundException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(NOT_FOUND.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            HttpRequestMethodNotSupportedException.class// 不支持的HTTP请求方法异常信息处理方法    })    public ErrorResponse httpRequestMethodNotSupportedException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(METHOD_NOT_ALLOWED.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            HttpMediaTypeNotAcceptableException.class// 不接受的HTTP媒体类型异常处方法    })    public ErrorResponse httpMediaTypeNotAcceptableException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(NOT_ACCEPTABLE.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            HttpMediaTypeNotSupportedException.class// 不支持的HTTP媒体类型异常处理方法    })    public ErrorResponse httpMediaTypeNotSupportedException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(UNSUPPORTED_MEDIA_TYPE.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            AsyncRequestTimeoutException.class// 异步请求超时异常    })    public ErrorResponse asyncRequestTimeoutException(Exception e, WebRequest request) {        log.info(e.getMessage(), e);        return new ErrorResponse(SERVICE_UNAVAILABLE.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            MissingPathVariableException.class,// 请求路径参数缺失异常处方法            HttpMessageNotWritableException.class,// HTTP消息不可写            ConversionNotSupportedException.class,// 不支持转换    })    public ErrorResponse handleServletException(Exception e, WebRequest request) {        log.error(e.getMessage(), e);        return new ErrorResponse(INTERNAL_SERVER_ERROR.getCode(), e.getMessage(), request);    }    @ExceptionHandler({            BindException.class// 参数绑定异常    })    @ResponseBody    public ErrorResponse handleBindException(BindException e, WebRequest request) {        log.error(&quot;参数绑定异常&quot;, e);        return wrapperBindingResult(e.getBindingResult(), request);    }    /**     * 参数校验异常，将校验失败的所有异常组合成一条错误信息     */    @ExceptionHandler({            MethodArgumentNotValidException.class// 方法参数无效    })    @ResponseBody    public ErrorResponse handleValidException(MethodArgumentNotValidException e, WebRequest request) {        log.error(&quot;参数校验异常&quot;, e);        return wrapperBindingResult(e.getBindingResult(), request);    }    /**     * 包装绑定异常结果     */    private ErrorResponse wrapperBindingResult(BindingResult bindingResult, WebRequest request) {        final List&lt;String&gt; errorDesc = new ArrayList&lt;&gt;();        for (ObjectError error : bindingResult.getAllErrors()) {            final StringBuilder msg = new StringBuilder();            if (error instanceof FieldError) {                msg.append(((FieldError) error).getField()).append(&quot;: &quot;);            }            msg.append(error.getDefaultMessage() == null ? &quot;&quot; : error.getDefaultMessage());            errorDesc.add(msg.toString());        }        final String desc = isProd ? getLocaleMessage(BAD_REQUEST.getCode(), &quot;&quot;) : String.join(&quot;, &quot;, errorDesc);        return new ErrorResponse(BAD_REQUEST.getCode(), desc, request);    }    /**     * 业务异常     */    @ExceptionHandler(value = CodeBaseException.class)    @ResponseBody    public ErrorResponse handleBusinessException(CodeBaseException e, WebRequest request) {        log.error(&quot;业务异常：&quot; + e.getMessage(), e);        final ResponseEnum anEnum = e.getAnEnum();        return new ErrorResponse(anEnum.getCode(), anEnum.getLocaleMessage(e.getArgs()), request);    }    /**     * 未定义异常     */    @ExceptionHandler(value = Exception.class)    @ResponseBody    public ErrorResponse handleExceptionInternal(Exception e, WebRequest request) {        log.error(&quot;未捕捉异常：&quot; + e.getMessage(), e);        final Integer code = INTERNAL_SERVER_ERROR.getCode();        return new ErrorResponse(code, getLocaleMessage(code, e.getMessage()), request);    }    private String getLocaleMessage(Integer code, String defaultMsg) {        try {            return messageSource.getMessage(&quot;&quot; + code, null, defaultMsg, LocaleContextHolder.getLocale());        } catch (Throwable t) {            log.warn(&quot;本地化异常消息发生异常: {}&quot;, code);            return defaultMsg;        }    }}</code></pre><p>从上面两个类可以看出，比较核心的是这么几个注解：</p><ul><li>@ExceptionHandle：负责处理controller标注的类中抛出的异常的注解</li><li>@RestControllerAdvice：能够将@ExceptionHandler标注的方法集中到一个地方进行处理的注解，这个注解是复合注解，实现了<code>@ControllerAdvice</code>和<code>@ResponseBody</code>的功能。</li></ul><p>借用谭朝红博文中的图片（蓝色箭头表示正常的请求和响应，红色箭头表示发生异常的请求和响应）：</p><p><img src="http://static.howardliu.cn/springboot/1141452688-5ce176fbd4a9b_articlex.png" alt="异常信息处理类"></p><h2 id="写个Demo测试一下"><a href="#写个Demo测试一下" class="headerlink" title="写个Demo测试一下"></a>写个Demo测试一下</h2><p>接下来我们写个demo测试一下是否能够实现异常的优雅响应：</p><pre><code class="java">@RestController@RequestMapping(&quot;index&quot;)@Slf4jpublic class IndexController {    private final IndexService indexService;    public IndexController(final IndexService indexService) {        this.indexService = indexService;    }    @GetMapping(&quot;hello1&quot;)    public Response&lt;String&gt; hello1() {        Response&lt;String&gt; response = new Response&lt;&gt;();        try {            response.setCode(200);            response.setDesc(&quot;请求成功&quot;);            response.setData(indexService.hello());        } catch (Exception e) {            log.error(&quot;hello1方法请求异常&quot;, e);            response.setCode(500);            response.setDesc(&quot;请求异常:&quot; + e.getMessage());        } finally {            log.info(&quot;执行controller的finally结构&quot;);        }        return response;    }    @GetMapping(&quot;hello2&quot;)    public Response&lt;String&gt; hello2(@RequestParam(&quot;ex&quot;) String ex) {        switch (ex) {            case &quot;ex1&quot;:                throw new CodeBaseException(CommonResponseEnum.USER_NOT_FOUND, &quot;用户信息不存在&quot;);            case &quot;ex2&quot;:                throw new CodeBaseException(CommonResponseEnum.MENU_NOT_FOUND, &quot;菜单信息不存在&quot;);            case &quot;ex3&quot;:                throw new CodeBaseException(CommonResponseEnum.ILLEGAL_ARGUMENT, &quot;请求参数异常&quot;);            case &quot;ex4&quot;:                throw new CodeBaseException(CommonResponseEnum.DATA_NOT_FOUND, &quot;数据不存在&quot;);        }        throw new CodeBaseException(INTERNAL_ERROR, new Object[]{ex}, &quot;请求异常&quot;, new RuntimeException(&quot;运行时异常信息&quot;));    }}</code></pre><p>启动服务之后，传入不同参数获取不同的异常信息：</p><pre><code class="javascript">// 请求 /index/hello2?ex=ex1{    &quot;code&quot;: 4104,    &quot;desc&quot;: &quot;User Not Found&quot;,    &quot;timestamp&quot;: &quot;2020-10-10T05:58:39.433+00:00&quot;,    &quot;path&quot;: &quot;/index/hello2&quot;}// 请求 /index/hello2?ex=ex2{    &quot;code&quot;: 4204,    &quot;desc&quot;: &quot;Menu Not Found&quot;,    &quot;timestamp&quot;: &quot;2020-10-10T06:00:34.141+00:00&quot;,    &quot;path&quot;: &quot;/index/hello2&quot;}// 请求 /index/hello2?ex=ex3{    &quot;code&quot;: 4000,    &quot;desc&quot;: &quot;[DEFAULT] Illegal Arguments&quot;,    &quot;timestamp&quot;: &quot;2020-10-10T06:00:44.233+00:00&quot;,    &quot;path&quot;: &quot;/index/hello2&quot;}// 请求 /index/hello2?ex=ex4{    &quot;code&quot;: 4004,    &quot;desc&quot;: &quot;对应数据未找到&quot;,    &quot;timestamp&quot;: &quot;2020-10-10T06:00:54.178+00:00&quot;,    &quot;path&quot;: &quot;/index/hello2&quot;}</code></pre><p>附上文中的代码：<a href="https://github.com/howardliu-cn/effective-spring/tree/main/spring-exception-handler" target="_blank" rel="noopener">https://github.com/howardliu-cn/effective-spring/tree/main/spring-exception-handler</a>，收工。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/springboot-action-gracefully-response-exception/">SpringBoot 实战：如何优雅的处理异常</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/108996938" target="_blank" rel="noopener">SpringBoot 实战：如何优雅的处理异常</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      作为后台服务，能够正确的处理程序抛出的异常，并返回友好的异常信息是非常重要的，毕竟我们大部分代码都是为了 处理异常情况。而且，统一的异常响应，有助于客户端理解服务端响应，并作出正确处理，而且能够提升接口的服务质量。
    
    </summary>
    
    
      <category term="springboot" scheme="https://www.howardliu.cn/categories/springboot/"/>
    
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="实战" scheme="https://www.howardliu.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 实战：一招实现结果的优雅响应</title>
    <link href="https://www.howardliu.cn/springboot-action-gracefully-response/"/>
    <id>https://www.howardliu.cn/springboot-action-gracefully-response/</id>
    <published>2020-08-12T12:26:56.000Z</published>
    <updated>2020-08-12T12:26:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/springboot/red-panda-5475574_1280.png" alt="SpringBoot 实战：一招实现结果的优雅响应"></p><p>因为最近事比较杂，很多文章都没有连续性，想到哪写到哪，大家海涵，后面理清思绪，会连贯输出，形成系列，供大家找茬。</p><p>今天说一下 Spring Boot 如何实现优雅的数据响应：统一的结果响应格式、简单的数据封装。</p><a id="more"></a><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>无论系统规模大小，大部分 Spring Boot 项目是提供 Restful + json 接口，供前端或其他服务调用，格式统一规范，是程序猿彼此善待彼此的象征，也是减少联调挨骂的基本保障。</p><p>通常响应结果中需要包含业务状态码、响应描述、响应时间戳、响应内容，比如：</p><pre><code class="json">{  &quot;code&quot;: 200,  &quot;desc&quot;: &quot;查询成功&quot;,  &quot;timestamp&quot;: &quot;2020-08-12 14:37:11&quot;,  &quot;data&quot;: {    &quot;uid&quot;: &quot;1597242780874&quot;,    &quot;name&quot;: &quot;测试 1&quot;  }}</code></pre><p>对于业务状态码分为两个派系：一个是推荐使用 HTTP 响应码作为接口业务返回；另一种是 HTTP 响应码全部返回 200，在响应体中通过单独的字段表示响应状态。两种方式各有优劣，个人推荐使用第二种，因为很多 Web 服务器对 HTTP 状态码有拦截处理功能，而且状态码数量有限，不够灵活。比如返回 200 表示接口处理成功且正常响应，现在需要有一个状态码表示接口处理成功且正常响应，但是请求数据状态不对，可以返回 2001 表示。</p><h2 id="自定义响应体"><a href="#自定义响应体" class="headerlink" title="自定义响应体"></a>自定义响应体</h2><p>定义一个数据响应体是返回统一响应格式的第一步，无论接口正常返回，还是发生异常，返回给调用方的结构格式都应该不变。给出一个示例：</p><pre><code class="java">@ApiModel@Datapublic class Response&lt;T&gt; {    @ApiModelProperty(value = &quot;返回码&quot;, example = &quot;200&quot;)    private Integer code;    @ApiModelProperty(value = &quot;返回码描述&quot;, example = &quot;ok&quot;)    private String desc;    @ApiModelProperty(value = &quot;响应时间戳&quot;, example = &quot;2020-08-12 14:37:11&quot;)    private Date timestamp = new Date();    @ApiModelProperty(value = &quot;返回结果&quot;)    private T data;}</code></pre><p>这样，只要在 Controller 的方法返回<code>Response</code>就可以了，接口响应就一致了，但是这样会形成很多格式固定的代码模板，比如下面这种写法：</p><pre><code class="java">@RequestMapping(&quot;hello1&quot;)public Response&lt;String&gt; hello1() {    final Response&lt;String&gt; response = new Response&lt;&gt;();    response.setCode(200);    response.setDesc(&quot;返回成功&quot;);    response.setData(&quot;Hello, World!&quot;);    return response;}</code></pre><p>调用接口响应结果为：</p><pre><code class="json">{  &quot;code&quot;: 200,  &quot;desc&quot;: &quot;返回成功&quot;,  &quot;timestamp&quot;: &quot;2020-08-12 14:37:11&quot;,  &quot;data&quot;: &quot;Hello, World!&quot;}</code></pre><p>这种重复且没有技术含量的代码，怎么能配得上程序猿这种优（lan）雅（duo）的生物呢？最好能在返回响应结果的前提下，减去那些重复的代码，比如：</p><pre><code class="java">@RequestMapping(&quot;hello2&quot;)public String hello2() {    return &quot;Hello, World!&quot;;}</code></pre><p>这就需要借助 Spring 提供的<code>ResponseBodyAdvice</code>来实现了。</p><h2 id="全局处理响应数据"><a href="#全局处理响应数据" class="headerlink" title="全局处理响应数据"></a>全局处理响应数据</h2><p>先上代码：</p><pre><code class="java">/** * &lt;br&gt;created at 2020/8/12 * * @author www.howardliu.cn * @since 1.0.0 */@RestControllerAdvicepublic class ResultResponseAdvice implements ResponseBodyAdvice&lt;Object&gt; {    @Override    public boolean supports(final MethodParameter returnType, final Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {        return !returnType.getGenericParameterType().equals(Response.class);// 1    }    @Override    public Object beforeBodyWrite(final Object body, final MethodParameter returnType, final MediaType selectedContentType,                                  final Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,                                  final ServerHttpRequest request, final ServerHttpResponse response) {        if (body == null || body instanceof Response) {            return body;        }        final Response&lt;Object&gt; result = new Response&lt;&gt;();        result.setCode(200);        result.setDesc(&quot;查询成功&quot;);        result.setData(body);        if (returnType.getGenericParameterType().equals(String.class)) {// 2            ObjectMapper objectMapper = new ObjectMapper();            try {                return objectMapper.writeValueAsString(result);            } catch (JsonProcessingException e) {                throw new RuntimeException(&quot;将 Response 对象序列化为 json 字符串时发生异常&quot;, e);            }        }        return result;    }}/** * &lt;br&gt;created at 2020/8/12 * * @author www.howardliu.cn * @since 1.0.0 */@RestControllerpublic class HelloWorldController {    @RequestMapping(&quot;hello2&quot;)    public String hello2() {        return &quot;Hello, World!&quot;;    }    @RequestMapping(&quot;user1&quot;)    public User user1() {        User u = new User();        u.setUid(System.currentTimeMillis() + &quot;&quot;);        u.setName(&quot;测试1&quot;);        return u;    }}</code></pre><p>上面代码是实现了 Spring <code>ResponseBodyAdvice</code>类的模板方式，按照 Spring 的要求实现就行。只有两个需要特别注意的地方，也就是代码中标注 1 和 2 的地方。</p><p>首先说 1 这一行，也就是<code>supports</code>方法，这个方法是校验是否需要调用<code>beforeBodyWrite</code>方法的前置判断，返回<code>true</code>则执行<code>beforeBodyWrite</code>方法，这里根据 Controller 方法返回类型来判断是否需要执行<code>beforeBodyWrite</code>，也可以一律返回<code>true</code>，在后面判断是否需要进行类型转换。</p><p>然后重点说下 2 这一行，这行是坑，是大坑，如果对 Spring 结构不熟悉的，绝对会在这徘徊许久，不得妙法。</p><p>代码 2 这一行是判断<code>Controller</code>的方法是否返回的是<code>String</code>类型的结果，如果是，将返回的对象序列化之后返回。</p><p>这是因为<code>Spring</code>对<code>String</code>类型的响应类型单独处理了，使用<code>StringHttpMessageConverter</code>类进行数据转换。在处理响应结果的时候，会在方法<code>getContentLength</code>中计算响应体大小，其父类方法定义是<code>protected Long getContentLength(T t, @Nullable MediaType contentType)</code>，而<code>StringHttpMessageConverter</code>将方法重写为<code>protected Long getContentLength(String str, @Nullable MediaType contentType)</code>，第一个参数是响应对象，固定写死是<code>String</code>类型，如果我们强制返回<code>Response</code>对象，就会报<code>ClassCastException</code>。</p><p>当然，直接返回<code>String</code>的场景不多，这个坑可能会在某天特殊接口中突然出现。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>上面只是展示了<code>ResponseBodyAdvice</code>类最简单的应用，我们还可以实现更多的扩展使用。比如：</p><ol><li>返回请求ID：这个需要与与<code>RequestBodyAdvice</code>联动，获取到请求ID后，在响应是放在响应体中；</li><li>结果数据加密：通过<code>ResponseBodyAdvice</code>实现响应数据加密，不会侵入业务代码，而且可以通过注解方式灵活处理接口的加密等级；</li><li>有选择的包装响应体：比如定义注解<code>IgnoreResponseWrap</code>，在不需要包装响应体的接口上定义，然后在<code>supports</code>方法上判断方法的注解即可，比如：</li></ol><pre><code class="java">@Overridepublic boolean supports(final MethodParameter returnType, final Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {    final IgnoreResponseWrap[] declaredAnnotationsByType = returnType.getExecutable().getDeclaredAnnotationsByType(IgnoreResponseWrap.class);    return !(declaredAnnotationsByType.length &gt; 0 || returnType.getGenericParameterType().equals(Response.class));}</code></pre><p>很多其他玩法就不一一列举了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面说了正常响应的数据，只做到了一点优雅，想要完整，还需要考虑接口异常情况，总不能来个大大的<code>try/catch/finally</code>包住业务逻辑吧，那也太丑了。后面会再来一篇，重点说说接口如何在出现异常时，也能返回统一的结果响应。</p><p>本文只是抛出一块砖，玉还得自己去找。</p><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/springboot-action-gracefully-response/">SpringBoot 实战：一招实现结果的优雅响应</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/107970059" target="_blank" rel="noopener">SpringBoot 实战：一招实现结果的优雅响应</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      无论系统规模大小，大部分 Spring Boot 项目是提供 Restful + json 接口，供前端或其他服务调用，格式统一规范，是程序猿彼此善待彼此的象征，也是减少联调挨骂的基本保障。
    
    </summary>
    
    
      <category term="springboot" scheme="https://www.howardliu.cn/categories/springboot/"/>
    
    
      <category term="SpringBoot" scheme="https://www.howardliu.cn/tags/SpringBoot/"/>
    
      <category term="实战" scheme="https://www.howardliu.cn/tags/%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>系统设计系列之如何设计一个短链服务</title>
    <link href="https://www.howardliu.cn/tiny-url-system/"/>
    <id>https://www.howardliu.cn/tiny-url-system/</id>
    <published>2020-07-28T14:11:59.000Z</published>
    <updated>2020-07-28T14:11:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/system-design/snail-5353573_1920.jpg" alt="系统设计系列之如何设计一个短链服务"></p><p>短链服务的鼻祖是 <a href="https://tinyurl.com/" target="_blank" rel="noopener">TinyURL</a>，是最早提供短链服务的网站，目前国内也有很多短链服务：新浪（t.cn）、百度（dwz.cn）、腾讯（url.cn）等等。</p><p>不得不问一句，为什么要用短链？这个问题的另外一层意思是，短链服务有必要存在吗？</p><p>套用万金油答案：存在即合理。</p><a id="more"></a><h2 id="短链服务存在的合理性"><a href="#短链服务存在的合理性" class="headerlink" title="短链服务存在的合理性"></a>短链服务存在的合理性</h2><p>我们先说说短链服务存在的合理性。</p><p>短链唯一的一个优点是<strong>短</strong>。</p><p>微博的早期用户都知道，每条微博只能限制在 140 个字以内，如果想要分享一个链接，就需要减少描述的文字。</p><p>同样，如果想要在营销短信中放入一个链接，就需要考虑成本问题。如果是早期的手机，还需要考虑用户可能接收到三条断开的短信，严重影响短信触达和点击。</p><p>这个情况下，如果链接足够短，那其他内容就可以更加丰富了。但是我们可能根据不同业务定义不同长度的链接，而且为了满足其他需求（比如，统计营销数据），还会在普通链接上增加参数。因此短链由此而生，通过重定向跳转，通过一个很短的链接代替一条其他链接，比如只需要通过 <a href="http://t.cn/A6ULvJho" target="_blank" rel="noopener">http://t.cn/A6ULvJho</a> 这种 20 个字符的链接，就可以重定向到长度为 146 个字符的原始链接 <a href="https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html?spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989">https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html?spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989</a>。</p><p>上面的两个例子证明了短链有存在的价值，我们总结几个短链的附加用处：</p><ol><li><p>发送营销短信，更省钱：链接变短，短信长度就变小，所需要支付的短信费用就减少了，比如上面短链 20 个字符，原始链接 146 个字符，差出来的都是钱啊。</p></li><li><p>转为二维码，可识别度更高，比如下面两个二维码的图片，相同尺寸，因为内容数量的不同，单元格的密度也就随之不同</p><p><img src="http://static.howardliu.cn/thinking/tinyurl-1.png" alt="http://t.cn/A6ULvJho"><br><img src="http://static.howardliu.cn/thinking/tinyurl-2.png" alt="https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html??spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989"></p></li><li><p>灵活可配置，因为短链跳转原始链接经过了一次重定向，如果在某个时间发现原始链接中有问题，或者需要跳转到其他地方，可以通过修改重定向的目标地址就可以了。这点对于线下物料投放非常有利，比如已经投放了二维码物料，这个时候发现期望跳转到其他网站或者活动，只需要修改短链的目标地址就行，而不需要全部替换已经投放的物料。</p></li></ol><h2 id="短链的原理"><a href="#短链的原理" class="headerlink" title="短链的原理"></a>短链的原理</h2><p>其实前面已经提到，短链是通过服务器重定向到原始链接实现的。我们来观察下新浪微博的短链，控制台执行命令<code>curl -i http://t.cn/A6ULvJho</code>，结果如下：</p><pre><code class="HTML">HTTP/1.1 302 FoundDate: Thu, 30 Jul 2020 13:59:13 GMTContent-Type: text/html;charset=UTF-8Content-Length: 328Connection: keep-aliveSet-Cookie: aliyungf_tc=AQAAAJuaDFpOdQYARlNadFi502DO2kaj; Path=/; HttpOnlyServer: nginxLocation: https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html??spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Moved Temporarily&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY BGCOLOR=&quot;#FFFFFF&quot; TEXT=&quot;#000000&quot;&gt;&lt;H1&gt;Moved Temporarily&lt;/H1&gt;The document has moved &lt;A HREF=&quot;https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html??spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989&quot;&gt;here&lt;/A&gt;.&lt;/BODY&gt;&lt;/HTML&gt;</code></pre><p>从上面的信息可以看出来，新浪做了 302 跳转，同时为了兼容性，还返回用于手动调整的 HTML 内容。整个交互流程如下：</p><p><img src="http://static.howardliu.cn/thinking/tinyurl-3.png" alt="短链跳转流程"></p><h2 id="短链生成方式"><a href="#短链生成方式" class="headerlink" title="短链生成方式"></a>短链生成方式</h2><p>根据 <a href="https://www.worldwidewebsize.com" target="_blank" rel="noopener">网页数量统计</a> 信息，目前全球有 58 亿的网页，Java 中 int 取值最多是 2^32 = 4294967296 &lt; 43 亿 &lt; 58 亿，long 取值是 2^64 &gt; 58 亿。所以如果是用数字的话，int 勉强能够支撑（毕竟不是所有网址都会调用短链服务创建短链），使用 long 就比较保险，但会造成空间浪费，具体使用哪种类型，需要根据业务自己判断了。</p><p>新浪微博使用 8 位字符串表示原始链接，这种字符串可以理解为数字的 62 进制表示，62^8 = 3521614606208 &gt; 3521 亿 &gt; 58 亿，也就是可以解决目前全球已知的网址。62 进制就是由 10 个数字 + (a-z)26 个小写字母 + (A-Z)26 个大写字母组成的数。</p><h3 id="生成方式1：Hash"><a href="#生成方式1：Hash" class="headerlink" title="生成方式1：Hash"></a>生成方式1：Hash</h3><p>对原始链接取 Hash 值，是一种比较简单的思路。有很多现成的算法可以实现，但是有个避不开的问题就是：Hash 碰撞，所以选一个碰撞率低的算法比较重要。</p><p>推荐 <a href="https://zh.wikipedia.org/wiki/Murmur%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">MurmurHash 算法</a>，这种算法是一种非加密型哈希函数，适用于一般的哈希检索操作，目前 Redis，Memcached，Cassandra，HBase，Lucene 都在用这种算法。</p><p>借助 Guava 中的 MurmurHash 实现：</p><pre><code class="java">final String url = &quot;https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/index.html?spm=5176.12825654.gzwmvexct.d118.e9392c4aP1UUdv&amp;scm=20140722.2007.2.1989&quot;;final HashFunction hf = Hashing.murmur3_128();final HashCode hashCode = hf.newHasher().putString(url, Charsets.UTF_8).hash();final int hashCodeAsInt = hashCode.asInt();// 这里选择返回 int 值，也可以选择返回 long 值System.out.println(hashCodeAsInt);// 输出的结果是：1810437348，转换成 62 进制是：1Ywpso</code></pre><p>对于碰撞问题，最简单的一种思路是，如果发生碰撞，就给原始 URL 附加上特殊字符串，直到躲开碰撞为止。具体操作如下图：</p><p><img src="http://static.howardliu.cn/system-design/murmurhash-bloom.png" alt="Hash+Bloom"></p><h3 id="生成方式2：统一发号器"><a href="#生成方式2：统一发号器" class="headerlink" title="生成方式2：统一发号器"></a>生成方式2：统一发号器</h3><p>这个就是不管来的是什么，通过集中的统一发号器，分配一个 ID，这个 ID 就是短链的内容，比如第一个来的就是<a href="https://tinyurl.com/1，第二个就是https://tinyurl.com/2，以此类推。当然可能一些分布式ID算法上来就是很长的一个序号了。为了获取更短路，还可以将其转为" target="_blank" rel="noopener">https://tinyurl.com/1，第二个就是https://tinyurl.com/2，以此类推。当然可能一些分布式ID算法上来就是很长的一个序号了。为了获取更短路，还可以将其转为</a> 62 进制字符串。</p><ol><li>Redis 自增：Redis性能好，单机就能支撑10W+请求，如果作为发号器，需要考虑Redis持久化和灾备。</li><li>MySQL 自增主键：这种方案和Redis的方案类似，是利用数据库自增主键的提醒实现，保证ID不重复且连续自动创建。</li><li>Snowflake：这是一种目前应用比较广的ID序列生成算法，美团的Leaf是对这种算法的封装升级服务。但是这个算法依赖于服务器时钟，如果有时钟回拨，可能会有ID冲突。（有人会较真毫秒中的序列值是这个算法的瓶颈，话说回来了，这个算法只是提供了一种思路，如果觉得序列长度不够，自己加就好，但是每秒百万级的服务真的又这么多吗？）</li><li>等等。。。</li></ol><blockquote><p>后续会有一篇单独介绍统一发号器的文章，完后会修改这里，并附上链接，或者你也可以关注我（微信号：看山的小屋），获取第一手资料。</p></blockquote><p>对于统一发号器这种方式，还需要解决的一个问题是：如果同一个原始链接，应该返回相同的短链还是不同的短链？</p><p>答案是根据用户、地点等维度，相同的原始链接，返回不同的短链。如果判断维度都相同，则返回相同短链。这样做的好处是，我们可以根据短链的点击、请求信息，做数据统计。对于短链，我们牺牲的只是一些存储和运算，但是收集的信息却是无价的。</p><h2 id="存储短链"><a href="#存储短链" class="headerlink" title="存储短链"></a>存储短链</h2><p>一般这种数据的存储无非就两种：关系型数据库或NoSQL数据库。有了上面的创建逻辑，存储就是水到渠成的了。下面给出MySQL存储的建表语句：</p><pre><code class="sql">CREATE TABLE IF NOT EXISTS tiny_url(    sid                INT AUTO_INCREMENT PRIMARY KEY,    create_time        DATETIME  DEFAULT CURRENT_TIMESTAMP NULL,    update_time        TIMESTAMP DEFAULT CURRENT_TIMESTAMP NULL ON UPDATE CURRENT_TIMESTAMP,    version            INT       DEFAULT 0                 NULL COMMENT &#39;版本号&#39;,    tiny_url           VARCHAR(10)                         NULL COMMENT &#39;短链&#39;,    original_url       TEXT                                NOT NULL COMMENT &#39;原始链接&#39;,    # 其他附加信息    creator_ip         INT       DEFAULT 0                 NOT NULL,    creator_user_agent TEXT                                NOT NULL,    # 用户其他信息，用于后续统计，对于这些数据，只要存储影响创建短链的必要字段就行，其他的都可以直接发送到数据服务中    instance_id        INT       DEFAULT 0                 NOT NULL,    # 创建短链服务实例ID    state              TINYINT   DEFAULT 1                 NULL COMMENT &#39;-1无效 1有效&#39;);</code></pre><p>再啰嗦一句，存储需要考虑数据量级，提前规划是否需要分表分库。</p><h2 id="短链请求"><a href="#短链请求" class="headerlink" title="短链请求"></a>短链请求</h2><p>存储完成后，接下来就该使用了。</p><p>通常的做法是会根据请求的短链字符串，从存储中找到数据，然后返回HTTP重定向到原始地址。如果存储使用关系型数据库，对于短链字段一般需要创建索引，而且为了避免数据库成为瓶颈，数据库前面还会通过缓存铺路。而且为了提高缓存合理使用，一般通过LRU算法淘汰非热点短链数据。流程如下图：</p><p><img src="http://static.howardliu.cn/system-design/call-tiny-url.png" alt="短链请求"></p><p>图中的布隆过滤器是为了防止缓存击穿，造成服务器压力过大。</p><p>这里还有一个问题：HTTP返回重定向编码时使用301还是302，为什么新浪微博会返回302，而不是更加符合语义的 301 跳转？（对于 HTTP 状态码不太了解的同学，可以从 <a href="https://www.howardliu.cn/the-introduction-of-http-status-codes/">《HTTP 状态码总结》</a> 获得更多信息）</p><ul><li>301，代表永久重定向。也就是说，浏览器第一次请求拿到重定向地址后，以后的请求，都是直接从浏览器缓存中获取重定向地址，不会再请求短链服务。这样可以有效减少服务请求数，降低服务器负载，但是因为后续浏览器不再向后端发送请求，因此获取不到真实的点击数。</li><li>302，代表临时重定向。也就是说，每次浏览器都会向服务器发起请求获取新的地址，虽然会给服务器增加压力，但在硬件过剩的今天，这点压力比起数据简直不值一提。所以，302 重定向才是短链服务的首选。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>短链服务其实比较简单，没有太多的业务逻辑，主要考察对于分布式系统常用设计的理解，也是经常被用在面试过程中的一道题。这里只是提供大家一些设计思路，文中涉及到的发号器（分布式ID）、布隆过滤器、MurmurHash等都没有太过深入，因为每一个都不是三言两语可以说明白的，需要大家自行解决了。</p><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/tiny-url-system/">系统设计系列之如何设计一个短链服务</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/107754046" target="_blank" rel="noopener">系统设计系列之如何设计一个短链服务</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      短链服务其实比较简单，没有太多的业务逻辑，主要考察对于分布式系统常用设计的理解，也是经常被用在面试过程中的一道题。
    
    </summary>
    
    
      <category term="architect" scheme="https://www.howardliu.cn/categories/architect/"/>
    
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式" scheme="https://www.howardliu.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="架构设计" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="短链服务" scheme="https://www.howardliu.cn/tags/%E7%9F%AD%E9%93%BE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何在微服务团队中高效使用 Git 管理代码？</title>
    <link href="https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/"/>
    <id>https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/</id>
    <published>2020-07-22T13:38:11.000Z</published>
    <updated>2020-07-24T13:30:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/git/sunset-5371719_1920.jpg" alt="如何在微服务团队中高效使用 Git 管理代码"></p><p>用了 Git 多年，优势和挑战都是深有体会。</p><p>话不多说，直接上问题：如何在微服务团队中高效使用 Git 管理代码？</p><p>继续不多话，直接上答案：分支管理。</p><a id="more"></a><p>Git 的分支管理有很多实践，有些是从 SVN 类的集中式版本管理工具继承的，有些是根据 Git 自己的特性总结的，目前市面上比较有名的三种 Git 分支管理模型是：</p><ul><li>TrunkBased：主干在手，天下我有。所有代码都往主干上招呼，发版也只用主干。</li><li>GitFlow：严谨、规范、难用，主要是记不住该往哪个分支合并了。</li><li>AoneFlow：前两种都不行，那就借鉴各自的优点，达到阴阳平衡，中庸也。</li></ul><h2 id="TrunkBased"><a href="#TrunkBased" class="headerlink" title="TrunkBased"></a>TrunkBased</h2><p>TrunkBased，又叫主干开发，有一个网站专门介绍这种开发方式：<a href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener">Trunk Based Development</a>。</p><p>TrunkBased 是持续集成思想所崇尚的工作方式，它由单个主干分支和许多发布分支组成，每个发布分支在特定版本的提交点上从主干创建出来，用来进行上线部署和 Hotfix。在 TrunkBased 模式中，没有显性的特性分支。当然实际上 Git 的分布式特征天生允许每个人有本地分支，TrunkBased 也并非排斥短期的特性分支存在，只不过在说这种模式的时候，大家通常都不会明确强调它罢了。</p><p><img src="https://static.howardliu.cn/git/trunk-based.jpg" alt="TrunkBased"></p><p>使用主干开发后，我们的代码库原则上就只能有一个 Trunk 分支即 master 分支了，所有新功能的提交也都提交到 master 分支上，保证每次提交后 master 分支都是可随时发布的状态。没有了分支的代码隔离，测试和解决冲突都变得简单，持续集成也变得稳定了许多。</p><p>但是这种方案缺点也比较明显，如果大家都在主干进行开发，当代码提交合并时，将会异常痛苦，一不小心就会出现冲突。而且，这种因为这种方式没有明显的特性分支，想要移除已经上线的特性会变得非常困难。（如果你说把不要的功能注释，重新发版，那就当我什么也没说。）还有一种方案是引入特性开关，通过开关控制特性是否启用和关闭，但是增加开关就引入了复杂性，引入复杂性就引入了出 bug 的风险，毕竟多增加的每行代码都有可能是一个新的 bug。</p><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h2><p>GitFlow 来源于 Vincent Driessen 提出的 <a href="https://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a>，整体来说，是一套完善的版本管理流程。缺点就是太过严格，不太适合喜欢自由而且懒的程序猿。当然，在程序猿这种物种中，没有完美的解决方案，总有那么一小撮人会觉得不好。参考 Ant、Maven 和 Gradle。</p><p>先上图：</p><p><img src="https://static.howardliu.cn/git/gitflow.png" alt="GitFlow：A successful Git branching model"></p><p>GitFlow 常用分支：</p><ul><li>主干分支（<code>master</code>）：最近发布到生产环境代码的分支，这个分支只能从其他分支合并，不能再 Master 分支直接修改。</li><li>主开发分支（<code>develop</code>）：包含所有要发布到下一个 Release 版本的代码。可以在 Develop 直接开发，也可以将 Feature 的特性代码合并到 Develop 中。<br><img src="https://static.howardliu.cn/git/gitflow-develop.png" alt="主开发分支"></li><li>特性分支（<code>feature/*</code>）：功能项开发分支，以<code>feature/</code>开头命名分支，当功能项开发完成，将被合并到主开发分支进入下一个 Release，合并完分支后一般会删掉这个特性分支。<br><img src="https://static.howardliu.cn/git/gitflow-feature.png" alt="特性分支"></li><li>发布分支（<code>release/*</code>）：基于主开发分支创建的一个发布分支，以<code>release/</code>开头命名分支，用于测试、bug 修复及上线。完成后，合并到主干分支和主开发分支，同时在主干分支上打个 Tag 记住 Release 版本号，然后可以删除发布分支。<br><img src="https://static.howardliu.cn/git/gitflow-release.png" alt="发布分支"></li><li>热修复分支（<code>hotfix/*</code>）：用于解决线上 Release 版本出现的 bug，以<code>hotfix/</code>开头命名分支，修复线上问题，完成后，合并到主干分支和主开发分支，同时在主干分支上打个 tag。<br><img src="https://static.howardliu.cn/git/gitflow-hotfix.png" alt="热修复分支"></li></ul><p>根据上面描述，GitFlow 是一套完整的从开发到生产的管理方式，但是各种分支来回切换及合并，很容易把人搞晕，所以用的人也是越来越少。</p><h2 id="AoneFlow"><a href="#AoneFlow" class="headerlink" title="AoneFlow"></a>AoneFlow</h2><p>AoneFlow 是阿里内部的一套版本管理模型，兼顾了 TrunkBased 易于持续集成和 GitFlow 易于管理需求的特点，又规避了 GitFlow 分支繁琐的缺点，也就是中庸。</p><p>AoneFlow 使用三个分支：主干分支（<code>master</code>）、特性分支（<code>feature/*</code>）、发布分支（<code>release/*</code>），以及三条原则：</p><p><strong>规则一，开始工作前，从主干分支创建特性分支。</strong></p><p>这条规则借鉴了 GitFlow，每当开始一件新的工作项（比如新的功能或是待解决的问题，可以是一个人完成，或是多个人协作完成）时，从代表最新已发布版本的主干分支上创建一个通常以<code>feature/</code>前缀命名的特性分支，然后在这个分支上提交代码修改。也就是说，每个工作项对应一个特性分支，所有的修改都不允许直接提交到主干。</p><p><img src="https://static.howardliu.cn/git/aoneflow-feature.jpg" alt="从主干创建特性分支"></p><p>特性分支不止承担了新功能，也是待解决问题的分支。对于我们团队，为了避免歧义，会将新功能以<code>feature/</code>为前缀，待解决问题以<code>hotfix/</code>为前缀，除了名称外，其他都按照规则一执行。</p><p><strong>规则二，通过合并特性分支，形成发布分支。</strong></p><p>GitFlow 先将已经完成的特性分支合并回主干分支和主开发分支，然后在主干分支上打 Tag 记录发布信息。TrunkBased 是等所有需要的特性都在主干分支上开发完成，然后从主干分支的特定位置拉出发布分支。而 AoneFlow 的思路是，从主干上拉出一条新分支，将所有本次要集成或发布的特性分支依次合并过去，从而得到发布分支，发布分支通常以<code>release/</code>前缀命名。</p><p><img src="https://static.howardliu.cn/git/aoneflow-release.jpg" alt="合并特性分支，形成发布分支"></p><p>我们可以将每条发布分支与具体的环境相对应，<code>release/test</code>对应部署测试环境，<code>release/prod</code>对应线上正式环境等，并与流水线工具相结合，串联各个环境上的代码质量扫描和自动化测试关卡，将产出的部署包直接发布到相应环境上。</p><p>另外，发布分支的特性组成是动态的，调整起来特别容易。在一些市场瞬息万变的互联网企业，以及采用“敏捷运作”的乙方企业经常会遇到这种情况，已经完成就等待上线的需求，随时可能由于市场策略调整或者甲方的一个临时决定，其中某个功能忽然要求延迟发布或者干脆不要了。再或者是某个特性在上线前发现存在严重的开发问题，需要排除。按往常的做法，这时候就要来手工“剔代码”了，将已经合并到开发分支或者主干分支的相关提交一个个剔除出去，做过的同学都知道很麻烦。在 AoneFlow 模式下，重建发布分支，只需要将原本的发布分支删掉，从主干拉出新的同名发布分支，再把需要保留的各特性分支合并过来就搞定，而且代码是干净的，没有包含不必要的特性。</p><p>此外，发布分支之间是松耦合的，这样就可以有多个集成环境分别进行不同的特性组合的集成测试，也能方便的管理各个特性进入到不同环境上部署的时机。松耦合并不代表没有相关性，由于测试环境、集成环境、预发布环境、灰度环境和线上正式环境等发布流程通常是顺序进行的，在流程上可以要求只有通过前一环境验证的特性，才能传递到下一个环境做部署，形成漏斗形的特性发布流。当然，这种玩法比较适合有完整开发集成平台的公司，小团队玩不转，比如我们团队就玩不动这种高级玩法。</p><p><strong>规则三，发布到线上正式环境后，合并相应的发布分支到主干，在主干添加 Tag，同时删除该发布分支关联的特性分支。</strong></p><p>当一条发布分支上的流水线完成了一次线上正式环境的部署，就意味着相应的功能真正的发布了，此时应该将这条发布分支合并到主干。为了避免在代码仓库里堆积大量历史上的特性分支，还应该清理掉已经上线部分特性分支。与 GitFlow 相似，主干分支上的最新版本始终与线上版本一致，如果要回溯历史版本，只需在主干分支上找到相应的版本标签即可。</p><p><img src="https://static.howardliu.cn/git/aoneflow-master.jpg" alt="合并相应的发布分支到主干，在主干添加 Tag，同时删除该发布分支关联的特性分支"></p><p>除了基本规则，还有一些实际操作中不成文的技巧。比如上线后的热修复，正常的处理方法应该是，创建一条新的发布分支，对应线上环境（相当于 Hotfix 分支），同时为这个分支创建临时流水线，以保障必要的发布前检查和冒烟测试能够自动执行。</p><h2 id="再啰嗦几句废话"><a href="#再啰嗦几句废话" class="headerlink" title="再啰嗦几句废话"></a>再啰嗦几句废话</h2><p>不管哪种方式，既然存在，都会有一定合理性。所以，不管最终翻了哪个牌子，不是因为这个好看，而是因为这个更适合自己。</p><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/how-to-use-branch-efficiently-in-git/">如何在微服务团队中高效使用 Git 管理代码？</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/107570189" target="_blank" rel="noopener">如何在微服务团队中高效使用 Git 管理代码？</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      TrunkBased：主干在手，天下我有。所有代码都往主干上招呼，发版也只用主干。GitFlow：严谨、规范、难用，主要是记不住该往哪个分支合并了。AoneFlow：前两种都不行，那就借鉴各自的优点，达到阴阳平衡，中庸也。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Git" scheme="https://www.howardliu.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>IPv4 与 int 之间互相转换</title>
    <link href="https://www.howardliu.cn/convert-ipv4-to-int/"/>
    <id>https://www.howardliu.cn/convert-ipv4-to-int/</id>
    <published>2020-07-20T13:11:13.000Z</published>
    <updated>2020-07-20T13:11:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前数据存储设备越来越便宜，已经不存在为了节省空间而引入复杂计算的场景，但是有时候，将 IPv4 这种长字符串数据转换为数字，更加便于比较和查询。</p><a id="more"></a><h2 id="1-直接转换"><a href="#1-直接转换" class="headerlink" title="1. 直接转换"></a>1. 直接转换</h2><p>直接能够想到的方式是把网段之间的“.”去掉，组成一个长数字就行。但是在“255.255.255.255”地址时，去掉“.”的数字是255255255255，大于int能够表示的最大数字，所以，真正使用的时候，只能使用长整型Long型。但是这种方式有两个严重的问题：</p><ol><li>单向转换：只适合那种需要从 IPv4 到数字单向转换的场景，如果想要转回来，就不容易了，比如：“192.168.10.10”和“192.168.101.0”转换成数字都是1921681010，想要从数字转换会IP地址，就会有歧义，除非搭配某些约定规则才能实现</li><li>转换之后存在歧义：也是第一条中说的，两个IP地址转换得到同一个数字，如果在需要IP比较的场景，就容易出现问题了。</li></ol><h2 id="2-移位转换"><a href="#2-移位转换" class="headerlink" title="2. 移位转换"></a>2. 移位转换</h2><p>既然直接去掉“.”有歧义的问题，那就将4段数字分开存储，IPv4的某段数字取值范围是0~255，也就是2^8个数字，恰巧int类型占32个字节，那通过简单的移位和或运算，就能得到最后的结果，而且支持从int到IPv4的转换。</p><p>比如：192.168.30.68，计算结果就是：</p><pre><code class="java">192 &lt;&lt; 24 | 168 &lt;&lt; 16 | 30 &lt;&lt; 8 | 68 = 0b11000000101010000001111001000100 = -1062724028</code></pre><p>逆向转换就是：</p><pre><code class="java">((-1062724028 &gt;&gt; 24) &amp; 0xFF) + &quot;.&quot; + ((-1062724028 &gt;&gt; 16) &amp; 0xFF) + &quot;.&quot; + ((-1062724028 &gt;&gt; 8) &amp; 0xFF) + &quot;.&quot; + (-1062724028 &amp; 0xFF) = &quot;192.168.30.68&quot;</code></pre><p>所以第二种方式除了计算麻烦一些，可以完美解决第一种方式的两个问题。</p><hr><p>个人主页：<a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文：<a href="https://www.howardliu.cn/convert-ipv4-to-int">IPv4 与 int 之间互相转换</a><br>CSDN 主页：<a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN 博文：<a href="https://blog.csdn.net/liuxinghao/article/details/107475967" target="_blank" rel="noopener">IPv4 与 int 之间互相转换</a></p>]]></content>
    
    <summary type="html">
    
      目前数据存储设备越来越便宜，已经不存在为了节省空间而引入复杂计算的场景，但是有时候，将 IPv4 这种长字符串数据转换为数字，更加便于比较和查询。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
    
      <category term="java" scheme="https://www.howardliu.cn/tags/java/"/>
    
      <category term="ipv4" scheme="https://www.howardliu.cn/tags/ipv4/"/>
    
      <category term="int" scheme="https://www.howardliu.cn/tags/int/"/>
    
  </entry>
  
  <entry>
    <title>设计模式：建造者模式</title>
    <link href="https://www.howardliu.cn/the-builder-pattern/"/>
    <id>https://www.howardliu.cn/the-builder-pattern/</id>
    <published>2020-03-22T10:11:21.000Z</published>
    <updated>2020-03-22T10:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/design-patterns/star-4903819_1920.jpg" alt="Design Patterns"></p><p>之前说过了<a href="https://www.howardliu.cn/singleton-pattern/">单例模式</a>，这周想说说建造者模式，它是另外一个比较常用的创建型设计模式。</p><p>每种设计模式的出现，都是为了解决一些编程不够优雅的问题，建造者模式也是这样。</p><p>维基百科解释是：建造者模式，Builder Pattern，又名生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p><a id="more"></a><h1 id="先上一个例子"><a href="#先上一个例子" class="headerlink" title="先上一个例子"></a>先上一个例子</h1><p>借用并改造下《Effective Java》中给出的例子：每种食品包装上都会有一个营养成分表，每份的含量、每罐的含量、每份卡路里、脂肪、碳水化合物、钠等，还可能会有其他N种可选数据，大多数产品的某几个成分都有值，该如何定义营养成分这个类呢？</p><h2 id="重叠构造器"><a href="#重叠构造器" class="headerlink" title="重叠构造器"></a>重叠构造器</h2><p>因为有多个参数，有必填、有选填，最先想到的就是定义多个有参构造器：第一个构造器只有必传参数，第二个构造器在第一个基础上加一个可选参数，第三个加两个，以此类推，直到最后一个包含所有参数，这种写法称为重叠构造器，有点像叠罗汉。还有一种常见写法是只写一个构造函数，包含所有参数。</p><p>代码如下：</p><pre><code class="java">public class Nutrition {    private int servingSize;// required    private int servings;// required    private int calories;// optional    private int fat;// optional    private int sodium;// optional    private int carbohydrate;// optional    public Nutrition(final int servingSize, final int servings) {        this(servingSize, servings, 0, 0, 0, 0);    }    public Nutrition(final int servingSize, final int servings, final int calories) {        this(servingSize, servings, calories, 0, 0, 0);    }    public Nutrition(final int servingSize, final int servings, final int calories, final int fat) {        this(servingSize, servings, calories, fat, 0, 0);    }    public Nutrition(final int servingSize, final int servings, final int calories, final int fat, final int sodium) {        this(servingSize, servings, calories, fat, sodium, 0);    }    public Nutrition(final int servingSize, final int servings, final int calories, final int fat, final int sodium, final int carbohydrate) {        this.servingSize = servingSize;        this.servings = servings;        this.calories = calories;        this.fat = fat;        this.sodium = sodium;        this.carbohydrate = carbohydrate;    }    // getter}</code></pre><p>这种写法还可以有效解决参数校验，只要在构造器中加入参数校验就可以了。</p><p>如果想要初始化实例，只需要<code>new</code>一下就行：<code>new Nutrition(100, 50, 0, 35, 0, 10)</code>。这种写法，不够优雅的地方是，当<code>calories</code>和<code>sodium</code>值为0的时候，也需要在构造函数中明确定义是0，示例中才6个参数，也能勉强接受。但是如果参数达到20个呢？可选参数中只有一个值不是0或空，写起来很好玩了，满屏全是0和null的混合体。</p><p>还有一个隐藏缺点，那就是如果同类型参数比较多，比如上面这个例子，都是<code>int</code>类型，除非每次创建实例的时候仔细对比方法签名，否则很容易传错参数，而且这种错误编辑器检查不出来，只有在运行时会出现各种诡异错误，排错的时候不知道要薅掉多少根头发了。</p><p>想要解决上面两个问题，不难想到，可以通过set方法一个个赋值就行了。</p><h2 id="set方式赋值"><a href="#set方式赋值" class="headerlink" title="set方式赋值"></a>set方式赋值</h2><p>既然构造函数中放太多参数不够优雅，还有缺点，那就换种写法，构造函数只保留必要字段，其他参数的赋值都用setter方法就行了。</p><p>代码如下：</p><pre><code class="java">public class Nutrition {    private final int servingSize;// required    private final int servings;// required    private int calories;// optional    private int fat;// optional    private int sodium;// optional    private int carbohydrate;// optional    public Nutrition(int servingSize, int servings) {        this.servingSize = servingSize;        this.servings = servings;    }    // getter and setter}</code></pre><p>这样就可以解决构造函数参数太多、容易传错参数的问题，只在需要的时候<code>set</code>指定参数就行了。</p><p>如果没有特殊需求，到这里可以解决大部分问题了。</p><p>但是需求总是多变的，总会有类似“五彩斑斓的黑”这种奇葩要求：</p><ol><li>如果必填参数比较多，或者大部分参数是必填参数。这个时候这种方式又会出现重叠构造器那些缺点。</li><li>如果把所有参数都用set方法赋值，那又没有办法进行必填项的校验。</li><li>如果非必填参数之间有关联关系，比如上面例子中，脂肪<code>fat</code>和碳水化合物<code>carbohydrate</code>有值的话，卡路里<code>calories</code>一定不会为0。但是使用现在这种设计思路，属性之间的依赖关系或者约束条件的校验逻辑就没有地方定义了。</li><li>如果想要把<code>Nutrition</code>定义成不可变对象的话，就不能使用<code>set</code>方法修改属性值。</li></ol><p>这个时候就该祭出今天的主角了。</p><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>先上代码</p><pre><code class="java">public class Nutrition {    private int servingSize;// required    private int servings;// required    private int calories;// optional    private int fat;// optional    private int sodium;// optional    private int carbohydrate;// optional    public static class Builder {        private final int servingSize;// required        private final int servings;// required        private int calories;// optional        private int fat;// optional        private int sodium;// optional        private int carbohydrate;// optional        public Builder(final int servingSize, final int servings) {            this.servingSize = servingSize;            this.servings = servings;        }        public Builder setCalories(final int calories) {            this.calories = calories;            return this;        }        public Builder setFat(final int fat) {            this.fat = fat;            return this;        }        public Builder setSodium(final int sodium) {            this.sodium = sodium;            return this;        }        public Builder setCarbohydrate(final int carbohydrate) {            this.carbohydrate = carbohydrate;            return this;        }        public Nutrition build() {            // 这里定义依赖关系或者约束条件的校验逻辑            return new Nutrition(this);        }    }    private Nutrition(Builder builder) {        servingSize = builder.servingSize;        servings = builder.servings;        calories = builder.calories;        fat = builder.fat;        sodium = builder.sodium;        carbohydrate = builder.carbohydrate;    }    // getter}</code></pre><p>想要创建对象，只要调用<code>new Nutrition.Builder(100, 50).setFat(35).setCarbohydrate(10).build()</code>就可以了。这种方式兼具前两种方式的优点：</p><ul><li>能够毫无歧义且明确<code>set</code>指定属性的值；</li><li>在<code>build</code>方法或<code>Nutrition</code>构造函数中定义校验方法，可以在创建对象过程中完成校验。</li></ul><p>建造者模式的缺点就是代码变多了（好像所有的设计模式都有这个问题），这个缺点可以借助<code>lombok</code>来解决，通过注解<code>@Builder</code>，可以在编译过程自动生成对象的<code>Builder</code>类，相当省事。</p><h1 id="再来一个例子"><a href="#再来一个例子" class="headerlink" title="再来一个例子"></a>再来一个例子</h1><p>接下来分析下《大话设计模式》中的一个例子，这个例子从代码结构上，和建造者模式有很大的出入，但是作者却把它归为建造者模式。下面我们就来看看究竟：现在需要画个小人，一个小人需要头、身体、左手、右手、左脚、右脚。</p><p>代码如下：</p><pre><code class="java">public class Person {    private String head;    private String body;    private String leftHand;    private String rightHand;    private String leftLeg;    private String rightLeg;    // getter/setter}public class PersonBuilder {    private Person person = new Person();    public PersonBuilder buildHead() {        person.setHead(&quot;头&quot;);        return this;    }    public PersonBuilder buildBody() {        person.setBody(&quot;身体&quot;);        return this;    }    public PersonBuilder buildLeftHand() {        person.setLeftHand(&quot;左手&quot;);        return this;    }    public PersonBuilder buildRightHand() {        person.setRightHand(&quot;右手&quot;);        return this;    }    public PersonBuilder buildLeftLeg() {        person.setLeftLeg(&quot;左腿&quot;);        return this;    }    public PersonBuilder buildRightLeg() {        person.setRightLeg(&quot;右腿&quot;);        return this;    }    public Person getResult() {        return this.person;    }}</code></pre><p>但是，如果有个方法忘记调用了，比如画右手的方法忘记调用了，那就成杨过大侠了。这个时候就需要在<code>PersonBuilder</code>之上加一个<code>Director</code>类，俗称监工。</p><pre><code class="java">public class PersonDirector {    private final PersonBuilder pb;    public PersonDirector(final PersonBuilder pb) {        this.pb = pb;    }    public Person createPerson() {        this.pb            .buildHead()            .buildBody()            .buildLeftHand()            .buildRightHand()            .buildLeftLeg()            .buildRightLeg();        return this.pb.getResult();    }}</code></pre><p>这个时候，对于客户端来说，只需要关注<code>Director</code>类就行了，就相当于在客户端调用构造器之间，增加一个监工，一个对接人，保证客户端能够正确使用<code>Builder</code>类。</p><p>细心的朋友可能会发现，我这里的<code>Director</code>类的构造函数增加了一个<code>Builder</code>参数，这是为了更好的扩展，比如，这个时候需要增加一个胖子<code>Builder</code>类，那就只需要定义一个<code>FatPersonBuilder</code>，继承<code>PersonBuilder</code>，然后只需要将新增加的类传入<code>Director</code>的构造函数即可。</p><p>这也是建造者模式的另一个优点：可以定义不同的<code>Builder</code>类实现不同的构建属性，比如上面的普通人和胖子两个<code>Builder</code>类。</p><h1 id="最后来个总结"><a href="#最后来个总结" class="headerlink" title="最后来个总结"></a>最后来个总结</h1><p>有的朋友会说，这两个例子结构差别很大，怎么能是同一个模式？</p><p>那我们来看看官方给出的建造者模式的类图：</p><p><img src="https://static.howardliu.cn/design-patterns/builder-pattern.jpg" alt="Builder Patter"></p><p>这样结构就比较清晰了，两个例子都包含<code>Product</code>类和<code>Builder</code>类(或子类)，区别是，第一个例子对象的完整性操作交给了客户端，第二个例子由<code>Director</code>类保障对象的完整。</p><p>我们来看看建造者的本质：构建<strong>状态完整</strong>、<strong>结构复杂</strong>的对象。</p><ul><li>结构复杂：如果只有几个属性，通过构造函数就能实现，只有属性多了，结构复杂，建造者模式才能体现价值，建议属性值超过6个时使用建造者模式。</li><li>状态完整：状态是否完整可以通过客户端或<code>Director</code>来管理，不会出现因为忘记调用<code>set</code>或其他方法，是对象少定义一个属性。</li></ul><p>从某种意义上说，建造者模式是为了弥补构造函数的不足出现的，主要优点是下面3项：</p><ol><li>将一个复杂对象的创建过程封装起来，向客户端隐藏产品内部表现</li><li>允许对象通过多个步骤来创建，并可以改变过程</li><li>产品的实现可以变换，因为客户端只能看到一个抽象的接口</li></ol><p>建造者模式作为一种比较实用的设计模式，应用场景主要是下面两个：</p><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li><li>当构造过程必须允许被构造的对象有不同的表示时</li></ul><p>碰到上面两种情况，不要犹豫，果断使用建造者模式就行。</p><p>因为疫情的影响，今年的招聘和应聘变得与往年大不一样，原本金三银四的时间可能会延长到5、6月份，这样大家可以有更多的时间准备。但是也有一个不利于应聘者的情况是，随着大家准备的时间延长，基本功是否扎实就会使面试者的表现拉开距离，设计模式就是基本功中的一种。所以准备在最近开启“面向面试之设计模式”的系列，希望能够夯实自己基础的同时，帮助到更多的人。</p><ul><li><a href="https://www.howardliu.cn/singleton-pattern/">单例模式</a></li><li><a href="https://www.howardliu.cn/the-builder-pattern/">建造者模式</a></li></ul><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/the-builder-pattern/">设计模式：建造者模式</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/105038711" target="_blank" rel="noopener">设计模式：建造者模式</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      建造者模式，又名生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
    
    </summary>
    
    
      <category term="design pattern" scheme="https://www.howardliu.cn/categories/design-pattern/"/>
    
    
      <category term="设计模式" scheme="https://www.howardliu.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从单体架构到微服务架构</title>
    <link href="https://www.howardliu.cn/from-monolith-to-microservice/"/>
    <id>https://www.howardliu.cn/from-monolith-to-microservice/</id>
    <published>2020-03-08T06:54:20.000Z</published>
    <updated>2020-03-08T06:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/microservice/beautiful-demoiselle-4825548_1920.jpg" alt="从单体架构到微服务架构"></p><p>微服务的优势众多，在现在如果有谁没有听过微服务架构，可以从<a href="https://www.howardliu.cn/what-is-microservice/">这里</a>了解一下。本文主要聊一聊是否值得花时间将单体架构重构为微服务架构？</p><a id="more"></a><p>微服务架构是一种架构风格，专注于软件研发效能，主要包括单位时间内实现更多功能，或者软件从想法到上线的整个持续交付的过程。在当前的互联网环境中，业务变化迅速，也促使了微服务架构的普及。这种架构迫使团队迅速反应，快速实施，在方案没有过期之前已经上线运行，经受市场考察和考验。</p><p>目前国内大多数公司正在运行的系统都是单体架构系统，不可否认，这些系统在公司发展过程中，发挥了不可替代的作用，保障了公司正常运行，创造了很多价值。但是，随着系统的日渐膨胀，集成的功能越来越多，开发效率变得越来越低，一个功能从想法到实现，需要花费越来越长的时间。更严重的是，由于代码模块纠结在一起，很多已经老化的架构或者废弃的功能，已经成为新功能的阻碍。</p><p>众所周知，单体架构随着功能增多，不可避免的是研发效能的降低：研发周期变长、研发资源占用增多。从而引发的情况是：新员工培训时间增多、员工加班时间变长、员工要求涨薪或者跳槽。到了这种情况就说明，单体架构已经不能够满足企业发展需要，这个时候，需要升级架构来提升研发效能，比如微服务架构。</p><p>想要说明微服务架构的好处，可以来一个比喻。我们建了一个空间站，为此，我们需要将人、货物和设备运输到空间站中，这个时候，运载火箭是比较好的选择，尽管运载火箭造价也比较高，但是几个月发射一次，也能够满足需求。随着空间站的扩大，火箭发射的间隔变短，运输成本高的离谱，而且越来越没法满足空间站运转需求。这个时候，可以尝试另外一种方式，比如，太空电梯。当然太空电梯的造价成本高于一次飞行的费用，但是只要建成，以后的成本就降低了很多。</p><p>这个比喻也是说明了微服务带来的美好期望，同时也说明一个问题，实施微服务架构会带来巨大的投资。所以，我们在建造太空电梯之前需要想好，我们真的需要这种投入，否则只能是一种浪费。</p><h1 id="to-be-or-not-to-be"><a href="#to-be-or-not-to-be" class="headerlink" title="to be or not to be"></a>to be or not to be</h1><p>决定从单体架构升级为微服务架构时，先问问自己下面几个问题：</p><ul><li>产品或系统是否经过市场考验</li><li>是否需要超过一个团队来保证产品发布</li><li>系统是否对可靠性、可伸缩性有较高要求</li></ul><h1 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h1><p>什么是微服务架构呢？Sam Newman认为是：“一组围绕业务领域建模的、小而自治的、彼此协同工作的服务。”</p><p>微服务架构中的服务，是根据业务能力抽取的业务模块，独立开发和部署，但是需要彼此配合完成整个业务功能。服务不是单纯的数据存储组件，那是数据库。也不是单纯的逻辑函单元，那是函数。只有同时包括数据+逻辑，才是真正意义上的服务。</p><h1 id="服务边界"><a href="#服务边界" class="headerlink" title="服务边界"></a>服务边界</h1><p>服务拆解过程中，DDD（领域驱动设计）可以作为微服务架构的指导方针。因为微服务是围绕业务功能定义服务，根据服务定义团队，这与DDD将业务域拆解为业务子域、定义限定上下文的方法论如出一辙，于是DDD作为微服务的指导方针，快速定义各个服务组件，完成从单体架构到微服务架构的迁移。</p><p>Alberto Brandolini提出识别服务上下文的方式叫做“Event Storming”。第一步是识别业务域中发生的事件，也就是说，我们的关注点是行为，不是数据结构。这样做的好处是，系统中不同服务之间是松散耦合关系，而且单个服务能够自治。</p><p>定义好了服务边界，还需要定义事务边界。过去，我们的服务在一个进程中，后面挂着一个数据库，事务可以选择强一致性事务，也就是ACID。当服务增多，彼此配合，这个时候可以使用最终一致性事务，也就是BASE。不同于ACID，BASE更加灵活，只要数据在最终能够保持一致就可以了。这个最终的时间范围，根据不同的业务场景不同，可能是分钟、小时、天，甚至是周或者月。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>微服务架构愿景美好，属于重型武器，优点众多，缺点也很明显。服务增多，运维难度增大，错误调试难度增大。所以需要自动化构建、配置、测试和部署，需要日志收集、指标监控、调用链监控等工具，也就是需要DevOps实践。<a href="https://www.howardliu.cn/the-three-ways-principles-underpinning-devops/">实现DevOps的三步工作法</a>中说明了实现DevOps文化的三个步骤。</p><p>除了上面提到的基础，还需要在早期确定服务之间如何集成和彼此调用方式，还需要确定数据体系，包括事务一致性和数据可靠性方法。随着服务增多，还需要配置管理、服务发现等众多组件。具体需要的基础组件可以参考<a href="https://www.howardliu.cn/the-base-of-microservice/">微服务的基建工作</a>。</p><p>这些基础的服务和设计，最好在早期定义，否则，后期需要花费更多的资源才能够完善架构。如果前期缺失，后期也没有补足，造成的后果就是微服务架构迁移失败，最后的系统也只是披着微服务外衣的单体架构。</p><h1 id="进化还是革命？"><a href="#进化还是革命？" class="headerlink" title="进化还是革命？"></a>进化还是革命？</h1><p>定义好服务边界之后，还有一个问题需要解决：是逐步进化更新系统、还是破釜沉舟重构整个系统。</p><p>第二种方式很诱人，比较符合大多数程序猿的思维，系统不行，推倒重来，名为重构。但是在大多数情况下，这种方式不能被允许，因为市场变化迅速、竞争激烈，大多数公司不会停止业务，去等待重构一个能够运行、只是有些缺点的系统。所以，逐步提取更新系统才是王道，大多数公司也能接受。这种方式又被称为绞杀模式。</p><h1 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h1><p>该如何逐步过渡到微服务架构？下面一步步进行展示：</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_0.png" alt="单体架构"></p><p>第一步，将用户视图层与服务层部分逻辑进行分离。业务逻辑委托给服务层，支持页面展示的查询定向到数据库。这个阶段，我们不修改数据库本身。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_1.png" alt="部分拆分视图和业务逻辑"></p><p>第二步，用户视图层与数据库完全分离，依赖于服务层操作数据库。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_2.png" alt="完全拆分视图和业务逻辑"></p><p>第三步，将用户视图层与服务层拆分为不同服务，并在服务层创建一个API层，用户视图层与服务层之间通信。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_3.png" alt="物理拆分视图和业务逻辑"></p><p>第四步，拆分数据库，将不同业务数据拆分到不同的数据库中，同时对应业务服务层拆分到不同的服务。用户视图层通过API网关与不同业务服务层的API组件通信。这个时候需要注意，如果团队没有微服务开发经验，可以首先抽取简单业务域服务，因为业务简单，实现简单，可以练手，积累经验。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_4.png" alt="业务服务层拆分、垂直拆分数据库"></p><p>最后一步，拆分用户视图层。</p><p><img src="https://static.howardliu.cn/microservice/from_monolith_to_microservice_5.png" alt="拆分用户视图层"></p><p>绞杀模式的优势就在于，我们可以随着业务变化随时调整方案，不会造成整个业务进化过程的停摆。</p><h1 id="成功标准"><a href="#成功标准" class="headerlink" title="成功标准"></a>成功标准</h1><p>当我们完成了整个升级过程，就需要检查一下我们是否达到了预期的结果。引入微服务的目的首先是改善开发流程，我们可以通过简单的指标来衡量：</p><ul><li>开发周期：从概念到上线持续的时间</li><li>开发效能：单位时间内团队或个人完成的功能或用户故事</li><li>系统可伸缩性</li><li>平均维修时间：查找和排除故障所需时间</li></ul><p>通过对比老架构和新架构的这些特性值，可以评估升级过程取得的效果。当然，升级过程中也要有这些指标的监控。</p><h1 id="最重要的事"><a href="#最重要的事" class="headerlink" title="最重要的事"></a>最重要的事</h1><p>作为攻城狮，我们为能够解决或改善周围世界而自豪，着迷于提供解决方案。同时，我们也要意识到，我们付出的每一份努力，都要有回报。如果不能带来任何回报的重构升级，都是浪费时间。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/from-monolith-to-microservice/">从单体架构到微服务架构</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/105038453" target="_blank" rel="noopener">从单体架构到微服务架构</a></p>]]></content>
    
    <summary type="html">
    
      微服务架构是一种架构风格，专注于软件研发效能，主要包括单位时间内实现更多功能，或者软件从想法到上线的整个持续交付的过程。在当前的互联网环境中，业务变化迅速，也促使了微服务架构的普及。这种架构迫使团队迅速反应，快速实施，在方案没有过期之前已经上线运行，经受市场考察和考验。目前国内大多数公司正在运行的系统都是单体架构系统，不可否认，这些系统在公司发展过程中，发挥了不可替代的作用，保障了公司正常运行，创造了很多价值。但是，随着系统的日渐膨胀，集成的功能越来越多，开发效率变得越来越低，一个功能从想法到实现，需要花费越来越长的时间。更严重的是，由于代码模块纠结在一起，很多已经老化的架构或者废弃的功能，已经成为新功能的阻碍。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="单体架构" scheme="https://www.howardliu.cn/tags/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    
      <category term="重构" scheme="https://www.howardliu.cn/tags/%E9%87%8D%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>别让非理性思维毁了你的人生</title>
    <link href="https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/"/>
    <id>https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/</id>
    <published>2020-02-23T08:07:46.000Z</published>
    <updated>2020-02-23T08:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.howardliu.cn/quantum-physics.jpg" alt="别让非理性思维毁了你的人生" title="别让非理性思维毁了你的人生"></p><blockquote><p>本文是盖瑞·马库斯的《怪诞脑科学:战胜焦虑、混乱、拖延的自控术》一书读后感，借用作者给出的13条建议，结合自己的理解分享给大家。</p></blockquote><p>我们的身体的精密程度远超机器可以比拟，大脑神经元复杂程度远远超过世界上任何已存在的机器，但是我们却没有最简单的机器那样精准计算和准确无误的存储。</p><p>我们的记忆会向我们所想要的那个方向发生偏差，比如很多嫌疑人都认为自己犯的错有情可原。我们会偶尔断片或者忘记刚放下的一个小东西，所以我们会忘带钥匙、找不到手机，或者忘了锁门。</p><p>机器就不会发生这些，只要是存储的资料，没有修改绝对不会改变，只要是设定好的程序，一定会按照预期产生相同且一致的结果。非理性思维，是产生这种情况的“罪魁祸首”，同时也是我们有别于机器的重要原因。</p><p>德国化学家厄恩斯特·费希尔（Ernst Fischer）曾陷入这样的沉思：“随着机器变得越来越完美高效，于是这就变得很清楚了——人类的伟大之处就在于他们身上存在不完美的地方。”一个由工程师设计出来的生物可能永远都不懂什么是爱，永远都学不会欣赏艺术或理解诗歌。以动物的理性来看，把时间花在创造和欣赏艺术上，还不如把其用来收集坚果，为过冬做好准备呢。而从人类的角度，艺术是生活乐趣的一部分。</p><p>尽管我们有着机器或者动物所没有的优势，但是我们大脑中那些非理性的部分，让我们固执、偏执，存在认知偏差等一系列不好的因素，阻碍了我们个人乃至我们整个人类种族的发展，所以无论如何，我们都应该做的更好。盖瑞·马库斯给出的13条建议，每一条都是建立在谨慎的实证研究基础之上的，同时，也是我们可以习得的一些好的习惯，有可能改变我们生活中各种的不如意。</p><a id="more"></a><h2 id="1-尽可能考虑有无其他可行的选项"><a href="#1-尽可能考虑有无其他可行的选项" class="headerlink" title="1. 尽可能考虑有无其他可行的选项"></a>1. 尽可能考虑有无其他可行的选项</h2><p>“一条道走到黑”、“不撞南墙不回头，不到黄河心不死”，有些时候这些行为不能证明我们多么的坚定，只能说明我们比较冲动。即使我们义无反顾的走到最后，也不一定能够得到我们所期望的结果，甚至我们会在“黑道”里面迷失，在“南墙”上撞得头破血流，在“黄河”的漩涡里沉底。</p><p>我们专注于一件事情是好事，不好的是我们只关注这件事情，这就是我们常说的钻牛角尖。</p><p>我们需要对自己最关注的事物之外的其他想法和可能性，投入的更多关注。在做出正确抉择之前，我们往往需要把不会采取的途径和最终选用的途径都加以考虑才行。</p><p>有可能，最终我们还是要走这条路，但是因为我们考虑过其他的情况，可能就从其他情况中找到一只手电筒，那这条路就更加清晰了。</p><h2 id="2-重新界定问题"><a href="#2-重新界定问题" class="headerlink" title="2. 重新界定问题"></a>2. 重新界定问题</h2><p>我们生活中常常会被别人误导。</p><p>一句话，不同的说法，可能会产生完全不一样的效果，比如，“我们还有10%的问题没有解决”和“我们已经解决了90%的问题”，或者“每满100减20”和“打8折”。</p><p>一件事，从不同的角度，会有不一样的想法，比如，“死刑是惩罚凡有重大过错的罪犯”和”死刑是为了警告那些可能犯重大过错的人“。</p><p>所以，当有人告诉你一个问题的时候，看能不能换个角度，重新界定问题。不一样的角度，世界可能就不同了。</p><h2 id="3-始终牢记：相关关系不等于因果关系"><a href="#3-始终牢记：相关关系不等于因果关系" class="headerlink" title="3. 始终牢记：相关关系不等于因果关系"></a>3. 始终牢记：相关关系不等于因果关系</h2><p>一件事情发生，另外一件事情紧跟着也发生，但是两件事可能没有因果关系。</p><p>《傻鹅皮杜妮》是一本绘本，皮杜妮一开始认为“有书有爱书的人就有智慧”，于是天天带着捡来的书，越来越骄傲，给农场的动物们造成了各种麻烦，直到最后酿成大错，才领悟到，虽然她每天带着书，爱惜书，但是没有读过书，不可能会有智慧。</p><p>跳水运动员身材都是那种很完美的三角形身材，跳水运动员与三角形身材有很高的相关性，但不会因为有三角形身材就能够称为跳水运动员，那需要经过日复一日的辛苦训练习得的。</p><p>那些成功人士都有一项比较擅长的体育运动，成功人士与体育运动有很高的相关性，但不会因为一个人擅长某项体育运动，就能够称为成功人士。</p><p>我们很容易将相关关系和因果关系混为一谈，忽略一件事情的本质，也就会影响到我们最终做的决定。</p><h2 id="4-用于别忘了控制样本的大小"><a href="#4-用于别忘了控制样本的大小" class="headerlink" title="4. 用于别忘了控制样本的大小"></a>4. 用于别忘了控制样本的大小</h2><p>任何单一事件都可能是随机的，但同一模式的反复出现就不大可能是一个偶发事件了。从数学上考虑，样本数量越大，统计结果就越准确。</p><p>一种新型药物从研发到上市，需要经过漫长的临床试验期，尽可能多的在动物和人身上测试使用效果。没有任何一种药物，在一个人身上其效果，就认为这种药物对所有人都有效。</p><p>所以我们做的任何决定，都不要被少数人的结论而左右。你身边有10个人玩股票赚钱了，如果你就认为股票一定赚钱，那极有可能会倾家荡产。</p><p>如果你的同学同事都是大学生，你就认为咱们国家的大学生比率已经很高了，那就大错特错。我国大学生比例9.5%，即使将范围限制在21岁这个范围，大学生比例也不过才28.2%（如果不含大专是13%）。</p><p>所以，不以大量样本为基础得出的结论，都是耍流氓。</p><h2 id="5-预知自己的冲动并事先约束"><a href="#5-预知自己的冲动并事先约束" class="headerlink" title="5. 预知自己的冲动并事先约束"></a>5. 预知自己的冲动并事先约束</h2><p>相信大家都有过冲动消费，比如双十一，因为有满减、红包、返现等各种优惠，就买了一堆没用甚至只用一次的东西。我们饥饿的时候，通常会购买高热量的食物。我们减肥过程中，刚完成一次高运动量的健身，很有可能会吃的比平时多。这些都是冲动。</p><p>我们可以在看到优惠之前，想好自己要购买的商品；感到饥饿，计划好自己晚餐要吃什么，然后严格按照计划执行。</p><p>离我们最近的还有抖音或快手这些小视频APP，每个小视频1分钟以内，如果不加以控制，几个小时就一晃没了。我们可以设置一个青少年锁，到了一个小时，会弹出密码输入解密，这个时候关掉抖音，该干嘛就去干嘛，别等着时间过去之后，再唉声叹气的后悔什么都没做。</p><h2 id="6-别只是设定目标，要制定应变方案"><a href="#6-别只是设定目标，要制定应变方案" class="headerlink" title="6. 别只是设定目标，要制定应变方案"></a>6. 别只是设定目标，要制定应变方案</h2><p>仅有目标不能保证目标的效果，得在理性的那一刻制定理性的方案，才有可能更理性的执行。</p><p>在很多时候，人们都几乎不可能完成一个表达模糊的目标，比如“我要减肥”。喊着这句话减肥的人，都是在喊完之后，该吃吃，该喝喝。设置是“我要减1斤”，这种目标更加明确的口号，也不能保证一定能够实现，我们需要制定更加详细严格的计划。</p><p>心理学家彼得·葛尔韦泽（Peter Gollwitzer）的研究表明：要是给希望实现的目标制订细致的应变方案，采取“如果X，就Y”的形式，就能极大地提高成功的概率。还是减肥这件事，我们的计划是，如果看到薯条，就走开；如果主食超过半碗米饭，就要多跑1000米；如果聚餐时候喝啤酒了，就要多运动HIIT半小时。。。</p><blockquote><p>根据这条建议，也是找到自己一直减肥失败的原因了。</p></blockquote><h2 id="7-在任何时候，如果你已经疲惫或心里还在考虑其他事情，就尽可能不去做重要决定"><a href="#7-在任何时候，如果你已经疲惫或心里还在考虑其他事情，就尽可能不去做重要决定" class="headerlink" title="7. 在任何时候，如果你已经疲惫或心里还在考虑其他事情，就尽可能不去做重要决定"></a>7. 在任何时候，如果你已经疲惫或心里还在考虑其他事情，就尽可能不去做重要决定</h2><p>身心疲惫（或精神涣散）之时进行思考，这和醉酒之后开车没有多大的差别。因为疲惫之后（或精神涣散时），我们更多是依赖我们的反射系统，而非慎思系统。</p><p>几乎所有大额的交易都是在最疲劳的时候，大型商务谈判都是采用疲劳战，长时间谈判，谈到最后总会有人崩溃，谁崩溃谁就会让步。能够进行大型商务谈判的，都是有强健体魄和坚定意志的。</p><h2 id="8-随时在收益和代价之间进行权衡比较"><a href="#8-随时在收益和代价之间进行权衡比较" class="headerlink" title="8. 随时在收益和代价之间进行权衡比较"></a>8. 随时在收益和代价之间进行权衡比较</h2><p>这一条看似是连小孩都懂的道理，实际上却需要我们认真思考。</p><p>举个例子，点外卖的时候，经常会碰到满减优惠，满减和商品定价，都是商家经过计算设置的，选择了合适的量之后，发现再加8块，就能多减7块，还能多一份沙拉。理性的讲，没有这份沙拉，你也可以吃饱，而且不用额外多花1块钱。但是，很多人会因为多的这份沙拉，多花一块钱。这个也算是前面讲到的冲动，放在这一条里面，就是没有权衡收益和代价。</p><p>做出合理判断的前提显然是权衡利弊，然而除非我们提高警惕，否则我们的性格和情绪往往会成为理性判断的绊脚石。</p><h2 id="9-设想你的决定可能会被抽查"><a href="#9-设想你的决定可能会被抽查" class="headerlink" title="9. 设想你的决定可能会被抽查"></a>9. 设想你的决定可能会被抽查</h2><p>老话说：“举头三尺有神明”。有时候，我们做的决定受非理性思维影响，是因为我们不需要为这个决定负责任。假设，我们经常设想，如果有人看着我们，我们做的决定还是这个吗？</p><p>根据研究，如果我们需要跟别人解释我们的理由，我们就会更加公正客观的做决定。也就是，当我们需要对决定负责任时，我们就会投入更多的精力，进行更周到的研究，做更精细的调查，然后做出更加负责的决策。</p><h2 id="10-和自己保持距离"><a href="#10-和自己保持距离" class="headerlink" title="10. 和自己保持距离"></a>10. 和自己保持距离</h2><blockquote><p>写到这一条，突然发现，这里很多的建议都有益于减少冲动消费。</p></blockquote><p>我们购物的时候，看到一件东西在打折，而且折扣很诱人，我们就会设想，在将来，我们会用到这件东西，到时候再买，就得多花xxx，于是就买了，然后，这件东西的归宿要么是吃灰，要么是丢弃。</p><p>我们的大脑对于远近的考虑机制几乎是以完全不同的方式建立起来的：（对大脑而言）近，是明确具体的概念；而远，则是抽象的概念。不是任何时候以抽象的概念来考虑问题都会得到更好的结果，因为我们会对未来设定很多设想。</p><p>在任何时候，我们都应当问问自己，未来的我会对现在的这个决定产生什么感受？认识到我们的处理方式在此时此刻和将来会有所不同，并尽量平衡和利用好即时和远期两种思维模式。这样一来，我们就不会因为把选择完全建立在即时所想的基础上而深受其害。</p><p>研究表明，非理性行为会随着时间流逝而淡化，越是复杂的决定，越需要有足够时间斟酌。当意识到我们冲动了，只要一个方法：明天再说。</p><h2 id="11-要当心生动化、个性化和逸闻趣事"><a href="#11-要当心生动化、个性化和逸闻趣事" class="headerlink" title="11. 要当心生动化、个性化和逸闻趣事"></a>11. 要当心生动化、个性化和逸闻趣事</h2><p>我们大脑会被生动个性的东西所吸引，这是源于我们的祖先，对鲜艳的东西敏感，可以更快的找到成熟的果实。于是这个基因一直延续到现在，我们对于鲜艳的、生动的、个性化的等一系列不那么死气沉沉的东西更加敏感，更加信任。</p><p>蒂莫西·威尔逊做的关于在校大学生和避孕套品牌的研究，得出了一个经典结论，即“照我说的做，而不是照我做的做”。在实验中，受试者得到两个消息来源：一个来自《消费者报告》上数据充分的结论，它推荐的是避孕套A；另一个则来自一则逸闻趣事（据说是另一个学生写的），它推荐的是避孕套B，理由是有人使用避孕套A在“嘿咻”过程中不慎破裂，从而让当事人极为焦虑，担心自己可能怀孕。几乎所有大学生原则上都认为《消费者报告》上的结论更可靠，并希望自己的朋友在挑选避孕套时不要受那个逸闻趣事的影响。但当问及他们自己的选择时，差不多有1/3（31%）的大学生仍然相信了那则生动的逸闻趣事，从而选择了避孕套B。</p><p>换句话说，越是吸引你的，越应该小心，比如广告。所谓的蛊惑人心，不外如是。</p><p>我们需要做的就是，通过对客观且科学的事物加以特别关注，来克服我们易受生动性影响的弱点。</p><h2 id="12-挑选重点"><a href="#12-挑选重点" class="headerlink" title="12. 挑选重点"></a>12. 挑选重点</h2><p>我们大脑做复杂决定的时候，需要消耗大量能量，这也是为什么我们做重大决策之后，会感觉的疲惫。所以，为了减少这种消耗，把能量留给更需要的事情。</p><p>《布里丹之驴》（Buridan’s Ass）的故事：驴子虽然面临着两堆同样远近、同样诱人的干草，最后却活活饿死了。显然，吃哪堆干草，根本不是需要做复杂决定的事情，随便选一堆，吃完再吃另外一堆。</p><p>小事随性，大事随心。</p><h2 id="13-尽量理性"><a href="#13-尽量理性" class="headerlink" title="13. 尽量理性"></a>13. 尽量理性</h2><p>这条建议基本上起的是告诫作用，属于咒语系。告诫自己要理性就能产生作用的重要原因之一在于：你这样做的时候，就能够自动启发自己在生活实践当中使用前面曾经介绍过的种种技巧。仅仅告诉自己要理性可能还不够，但这样做的同时，再配合使用其他技巧，就能看到这方面的效果了。</p><blockquote><p>想要完整的《怪诞脑科学:战胜焦虑、混乱、拖延的自控术》，掌控自己的大脑，可以搜索微信公众号 kanshanshuo，回复“怪诞”，获取电子书。</p></blockquote><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/dont-let-irrational-thinking-ruin-your-lift/">别让非理性思维毁了你的人生</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/104469326" target="_blank" rel="noopener">别让非理性思维毁了你的人生</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      尽可能考虑有无其他可行的选项；重新界定问题；始终牢记：相关关系不等于因果关系；用于别忘了控制样本的大小；预知自己的冲动并事先约束；别只是设定目标，要制定应变方案；在任何时候，如果你已经疲惫或心里还在考虑其他事情，就尽可能不去做重要决定；随时在收益和代价之间进行权衡比较；设想你的决定可能会被抽查；和自己保持距离；要当心生动化、个性化和逸闻趣事；挑选重点；尽量理性。
    
    </summary>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/categories/%E9%97%B2%E8%81%8A/"/>
    
    
      <category term="闲聊" scheme="https://www.howardliu.cn/tags/%E9%97%B2%E8%81%8A/"/>
    
      <category term="非理性" scheme="https://www.howardliu.cn/tags/%E9%9D%9E%E7%90%86%E6%80%A7/"/>
    
      <category term="认知偏差" scheme="https://www.howardliu.cn/tags/%E8%AE%A4%E7%9F%A5%E5%81%8F%E5%B7%AE/"/>
    
      <category term="自控术" scheme="https://www.howardliu.cn/tags/%E8%87%AA%E6%8E%A7%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>实现DevOps的三步工作法</title>
    <link href="https://www.howardliu.cn/the-three-ways-principles-underpinning-devops/"/>
    <id>https://www.howardliu.cn/the-three-ways-principles-underpinning-devops/</id>
    <published>2020-02-04T02:29:33.000Z</published>
    <updated>2020-02-04T02:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/devops/mariposa-2382020_1920.jpg" alt="实现DevOps的三步工作法"></p><p>《凤凰项目-一个IT运维的传奇故事》是一本比较神奇的书，用讲故事的方式，展现了IT团队（开发、测试、运维）在开发效能低、系统交付慢的情况下，通过实践三步工作法，在团队中实现加快系统交付、提升开发效能，使团队走上DevOps之路。而且本书有一个值得称道的地方是，通过类比制造业的工作流程，可以直观发现技术团队工作过程中隐藏的问题。</p><p>这里需要提醒一下开发人员，看书的时候一定要佛系，因为这个故事是以运维角度展开的，有一些大骂开发的情节。如果是想找具体的DevOps工具的，建议不要看了，里面没有具体的工具介绍，是以最朴素的方式，讲述DevOps的优势和实践。</p><p>先说一下概念：</p><ul><li>价值流：一个组织基于客户的需求所执行的一系列有序的交付活动。或者，为了给客户设计、生产和提供产品或服务所需从事的一系列活动，它包含了信息流和物料流的双重价值。</li><li>技术价值流：把业务构想转化为向客户交付价值的、有技术驱动的服务所需要的流程。流程的输入是需求，由开发部门完成开发，进行整体测试，部署到生产环境正常运行，并为客户提供服务，以产生价值。</li><li>前置时间：从需求确认（开发接收需求）开始计时，到工作完成时结束</li><li>处理时间：从实际开始处理工作开始计时，到工作完成结束</li><li>等待时间：从需求确认（开发接收需求）开始计时，到实际开始处理工作时结束</li><li>在制品/半成品：价值流里没有彻底完成的工作、处于队列中的工作。部分完成的工作会逐渐过期，随着时间推移到最终失去价值。</li><li>约束点：价值流中的瓶颈，即整个价值流流速的上限点。</li></ul><a id="more"></a><h1 id="第一步：流动原则"><a href="#第一步：流动原则" class="headerlink" title="第一步：流动原则"></a>第一步：流动原则</h1><p><img src="https://static.howardliu.cn/devops/3-ways-first-way.png" alt="first way"></p><p>第一步流动原则是为了打通技术价值流通道，实现开发到运维的工作快速从左到右流动。通过加速技术价值流的流速，缩短满足客户需求的前置时间，提高工作质量和产量，并使企业具有更强的竞争力。相关实践包括：持续构建、集成、测试和部署，按需搭建环境，限制在制品数量，构建能够安全实施变更的系统和组织。</p><p>通过持续加强工作内容的可视化，减小批次大小和等待间隔，内建质量以防止缺陷向下游传递，</p><h2 id="使工作可视"><a href="#使工作可视" class="headerlink" title="使工作可视"></a>使工作可视</h2><p>在制造业，原料或半成品的堆积、订单积压都是直观可见，产生阻塞的地方，就是约束点。但是在技术价值流中，很多问题是隐藏的，没有办法很明显的看到阻塞和约束点。同时，因为信息的不可见或者彼此信息不全，可能将问题传递到下一环节，甚至上线时才出现问题，或者根本没法交付。这就需要尽可能的将工作可视化，用来识别工作在哪里流动、排队、停滞。</p><p>一般，可以使用Kanban管理（来自日语，就是看板）或Sprint计划板作为工具。</p><p><img src="https://static.howardliu.cn/devops/kanban.png" alt="Kanban管理"></p><p>可视化管理中有一个需要注意的地方，要着眼全局目标，而不是局部目标。全局目标是增加系统质量，提升开发效能，局部目标是开发的完成率、测试的缺陷数、系统的可用性等。不是说局部目标不重要，这些局部目标需要其他方式来优化，我们现在需要提升整体的效率，一旦我们陷入细节中，就是一叶障目不见泰山，没有办法把握全局了。也就是吉恩•金所说的“不允许局部优化造成整体性能下降”。</p><h2 id="限制在制品数"><a href="#限制在制品数" class="headerlink" title="限制在制品数"></a>限制在制品数</h2><p>工作可视化之后，就可以开始有素质的找茬了。</p><p>第一步，限制并行任务。为什么？因为如果有并行任务，我们就需要花时间切换任务。有一种说法，如果同时进行两个任务，会有20%的时间用于切换任务，比如理清思路、进入状态、恢复工作环境等。如果是三个，那就会有40%的时间用于切换任务。并行任务越多，用于切换任务所花费的时间越多，造成的人力浪费越多。并行任务减少之后，浪费的时间减少，花费在工作上的时间就增加了，整体的交付效率也相应的提升。如果是用的是看板管理，可以通过限制每一列或每个工作中心在制品（并行任务）数量，并把卡片数量的上限标记在每一列上。</p><h2 id="减小批量大小"><a href="#减小批量大小" class="headerlink" title="减小批量大小"></a>减小批量大小</h2><p>这个就是敏捷中提倡的小步快跑，先交付，先尝试，就可以先试错，先改错，有问题可以及早暴露，不至于最后集成一个大疙瘩，无力回天。</p><p>这里不得不提持续部署，相信很多团队在使用持续部署工具，比如Jenkins，代码提交之后，触发Jenkins工作流，开始进行编译、测试、部署和发布。我们要做的就是小批次的提交代码，这部分代码被编译、测试，如果有问题，能够尽早发现，如果没有问题，经过测试发布到正式环境，就能够及早的呈现给客户。</p><p><img src="https://static.howardliu.cn/devops/large-batches-single-piece-flow.png" alt="减小批量大小"></p><h2 id="减少交接次数"><a href="#减少交接次数" class="headerlink" title="减少交接次数"></a>减少交接次数</h2><p>在传统的IT团队中，代码从开发完成到部署上线需要经过N多个部门，每个部门有自己的KPI，有自己的任务排期，不同部门沟通需要成本，工单审批需要时间，这样就造成了交付时间的延长。另外，不同部门对于一个功能的认知有自己的认知陷阱，开发认为理所当然的时期，运维可能根本不了解。信息的隔离，可能造成一些已知的缺陷没有及时传递到下游，出现各种返工的情况。</p><p>为了减少这种交接，可以引入自动化方式完成大部分的操作，或者调整架构，让团队尽量少的依赖于其他人。</p><p><img src="https://static.howardliu.cn/devops/devops-self-service-operations.png" alt="减少交接次数"></p><h2 id="持续识别和改善约束点"><a href="#持续识别和改善约束点" class="headerlink" title="持续识别和改善约束点"></a>持续识别和改善约束点</h2><p>约束点就是瓶颈，如果整个团队中存在约束点，交付工作流就会有瓶颈。随着工作的优化，约束点之前的工作会堆积到约束点，而约束点之后的角色因为任务还没有到达，可能出现等待的情况。想要提升整体的效能，必须找到约束点，并进行拓宽，才能增加任务的吞吐量，任何不针对约束点进行的优化都是假象。</p><p>一般按照下面的步骤拓宽约束：</p><ol><li>识别约束点，任务队列最长的角色，就是约束点；</li><li>根据找到的约束点，找到拓宽约束点的方式；</li><li>根据2中的决定，考虑全局工作；</li><li>改善系统的约束点；</li><li>如果约束已经拓宽，整个工作流中会出现新的约束点，重复上面的步骤。</li></ol><h2 id="消除价值流中的困境和浪费"><a href="#消除价值流中的困境和浪费" class="headerlink" title="消除价值流中的困境和浪费"></a>消除价值流中的困境和浪费</h2><p>想要提升交付效率，除了开源，还需要节流。减少任何超出客户需求和他们愿意支付范围的任何材料和资源：</p><ul><li>半成品：价值流里没有彻底完成的工作、处于队列中的工作。部分完成的工作会逐渐过期，随着时间推移到最终失去价值。比如没有确认的需求、等待评审的变更。</li><li>额外工序：在交付过程中执行的、并未给客户增值的额外工作。比如对下游没有使用过的文档，或者对输出结果没有增值的评审。</li><li>额外功能：在交付过程中构建那些组织和客户完全不需要的功能，还没有到镀金阶段，却要浪费时间在镀金上，镀金的功能会增加功能测试和管理的复杂度和工作量。</li><li>任务切换：将人员分配到多个项目或价值流中，因为会出现任务切换，会在价值流中耗费额外的工作流和时间。</li><li>等待：由于资源竞争产生的等待，这将增加周期时间，延迟向客户交付。比如等待其他部门配合。</li><li>移动：信息或数据在工作中心之间移动的工作量。比如对于那种需要频繁沟通的人员不在一地办公，人员移动就产生浪费了。或者工作交接也会产生移动浪费，需要额外沟通。</li><li>缺陷：由于信息、材料或产品的错误、残缺或模糊，需要一定的工作量来确认。缺陷的产生和被检测出来的时间间隔越长，解决问题就越困难。</li><li>非标准或手工操作：需要依赖其他人的非标准或手动的工作，比如手动部署系统</li><li>填坑侠：为了实现组织目标，不得不把有些人和团队置于不太合理的处境。</li></ul><p>只有解决了上面的八种浪费，系统的改进，减轻或消除这些负担，实现快速流动的目标。</p><h1 id="第二步：反馈原则"><a href="#第二步：反馈原则" class="headerlink" title="第二步：反馈原则"></a>第二步：反馈原则</h1><p><img src="https://static.howardliu.cn/devops/3-ways-second-way.png" alt="second way"></p><p>第一步工作法是为了使工作能够在价值流能够从左向右流动，第二步工作法是创建从右到左的每个阶段能够快速、持续获得工作反馈的机制。该方法通过放大反馈环防止问题复发，并能够缩短问题检测周期，实现快速修复故障。我们的目标是从源头控制质量，并在流程中嵌入相关知识；创造更安全的工作系统，在故障或事故发生前检测到并解决它；最终建立安全和可靠的工作系统。</p><p>一般来说，发现和纠正问题最好的时机是发生故障时，只有发现问题，才能够解决问题。通过在整个工作流和组织中建立高质量的反馈机制，就可以在规模比较小、成本比较低的情况下修复系统。在灾难发生前消除问题，并创造出组织性学习氛围。</p><h2 id="在复杂系统中安全地工作"><a href="#在复杂系统中安全地工作" class="headerlink" title="在复杂系统中安全地工作"></a>在复杂系统中安全地工作</h2><p>复杂系统的一个重要特征是无法将系统视为一个整体，系统中的各个组件之间通常是紧耦合且紧密关联的，不能仅仅依据组件的行为解释系统的行为。复杂系统中故障存在且不可避免，所以我们需要设计一个安全的工作系统，可以让工程师们在系统中无所畏惧的开展工作，也就是各种折腾，这样才能在灾难发生前，快速检测出错误。可以采取下面4项措施让负载系统更加安全：</p><ul><li>管理复杂的工作，从中识别设计和操作的问题</li><li>群策群力解决问题，从而快速构建新知识</li><li>在整个组织中，将区域性的新知识应用到全局范围</li><li>领导者要持续培养有以上才能的人</li></ul><h2 id="及时发现问题"><a href="#及时发现问题" class="headerlink" title="及时发现问题"></a>及时发现问题</h2><p>想要及时发现问题，一般有两种做法：被动等待、主动试错。</p><p>通常，我们会搭建监控系统、设置多维度指标，对系统进行监控，当系统发生故障时，相关人员会收到报警信息，针对报警信息开始定位解决问题。这种方式属于被动等待的做法，因为要等待故障发生，故障发生的时机不可控，可能发生在上班的时候，更有可能发生在晚上睡觉时、周末休息时、休假旅游时，还有的会在结婚交拜的时，但是这种方式又不能没有，被动等待所搭建的监控系统是主动试错的基础。</p><p>主动试错就是在安全的工作系统中，不断对设计和假设进行验证，这种方式两个关键词是主动、安全。如果我们验证过程中把生产系统弄瘫了，那就笑话了。这样做的目标是更早、更快、以最低的成本、从尽可能多的维度增加系统的信息流，并尽可能清晰的确定问题的前因后果。能排除的假设越多，定位和解决问题的速度就越快。同时，这个过程也是练兵的过程，能很好的学习和创新。</p><h2 id="群策群力，战胜问题获取新知"><a href="#群策群力，战胜问题获取新知" class="headerlink" title="群策群力，战胜问题获取新知"></a>群策群力，战胜问题获取新知</h2><p>这个是承接“及时发现问题”的，因为发现问题之后，需要解决问题，我们需要发动所有相关人员，群策群力，解决问题。出现问题的时候，最忌讳的是绕开问题或者用“时间不够”这类理由搪塞。我们要做的是不惜全面停产，也要把问题解决。</p><p>至于为什么要相关人员都参与到解决问题中，理由如下：</p><ul><li>相关人员参与定位和处理问题，能够让大家更深入的理解系统，把无法规避、早期无知阶段变成学习的过程。</li><li>能够防止把问题带入下游环节，一旦进入下游环节，修复成本和工作量将呈指数增加，还会欠下技术债</li><li>阻止启动新的工作，问题不解决，就开始新的功能，就会引入新的问题</li><li>不解决问题，故障就会再次发生，修复成本更高</li></ul><p><img src="https://static.howardliu.cn/devops/pdca.jpg" alt="PDCA环"></p><h2 id="在源头保障质量"><a href="#在源头保障质量" class="headerlink" title="在源头保障质量"></a>在源头保障质量</h2><p>这点主要是针对QA和开发两个部门，有点类似国家政策：“谁污染谁治理”。在日常工作中，我们需要价值流中的每个人在他们的控制领域内发现并解决问题，通过这种方式，可以把质量控制、安全责任和决策制定都置于开展工作的场景里，而不是依赖于外围高层管理者的审批。</p><p>比如开发人员开发过程中，可以使用自动化测试，不依赖于测试团队，这样，开发人员就能够在任何需要的时候快速测试自己的代码，经过完善的自动化测试，就可以把代码部署到正式环境中。这样，自己对自己负责，同时也是对他人负责。</p><h2 id="为下游工作进行优化"><a href="#为下游工作进行优化" class="headerlink" title="为下游工作进行优化"></a>为下游工作进行优化</h2><p>这点负责的是精益原则：我们最重要的客户是我们的下游，为下游优化我们的工作，需要我们对他们有同理心，更好的识别可能阻碍快速平滑流动的设计问题。比如开发需要为运维优化自己的工作，比如架构、性能、稳定性、可测试性、可配置性、安全性等一系列特性，这些优化工作，和给客户提供功能同样重要。</p><h1 id="第三步：持续学习与实验原则"><a href="#第三步：持续学习与实验原则" class="headerlink" title="第三步：持续学习与实验原则"></a>第三步：持续学习与实验原则</h1><p><img src="https://static.howardliu.cn/devops/3-ways-third-way.png" alt="third way"></p><p>第一步建立从左到右的工作流，第二步建立从右到左的反馈机制，第三步就是要建立持续学习与实验的文化，通过提升个人技能，进而转化为团队和组织的财富。</p><p>这一步的核心是建立高度信任的文化，这种文化强调每个人都是持续学习者，在日常工作中，主动承担风险；通过安全的方法改进工作和开发产品，从成功或失败中积累经验，从而识别有价值的想法，摒弃无价值的想法。个人的努力带动整体的进化，帮助整个团队尝试和实践新技术、新方法。</p><p>必要的做法包括营造一种勇于创新、敢于冒险（相对于畏惧或盲目服从命令）以及高信任度（相对于低信任度和命令控制）的文化，把至少20%的开发和IT运维周期划拨给非功能性需求，并且不断鼓励进行改进</p><h2 id="建立学习型组织和安全文化"><a href="#建立学习型组织和安全文化" class="headerlink" title="建立学习型组织和安全文化"></a>建立学习型组织和安全文化</h2><p>在复杂系统中，精确预测出结果是不现实的。也就是说，无论我们怎么小心，故障总是会发生。</p><p>Westrum模型提出组织文化的三种类型：</p><ul><li>病态型组织的特点是大量的恐惧和威胁，倾向于隐藏失败。</li><li>官僚型组织的特点是严格的规则和流程，每个部门各扫门前雪，在这种组织中，通过评判系统处理事故，采用恩威并施的手段。</li><li>生机型组织是积极探索和分享信息，在这种组织中，整个团队所有员工共同承担责任，对事故积极反思并找到根本原因。</li></ul><p>第三步推崇的就是生机型组织，在故障发生时，团队关注的是如何设计安全的系统，防止事故复发，而不是追究人的问题。正如Etsy的工程师拜塞尼•马克里说的：“不指责，就没有恐惧；没有恐惧，就能够坦诚；坦诚能够有效的预防事故。”</p><h2 id="将日常工作的改进制度化"><a href="#将日常工作的改进制度化" class="headerlink" title="将日常工作的改进制度化"></a>将日常工作的改进制度化</h2><p>在技术价值流中，为了防止灾难性事故的发生，团队会陷入实施各种临时解决方案的工作中，这样就没有时间去完成那些有价值的工作。所以，用临时方案解决问题的模式，会导致问题和技术债务的累积。所以，我们需要在日常工作中留出时间来改善日常工作，比如偿还技术债务、修复bug、重构和优化代码等，这就要求我们的团队在开发间歇中预留一段时间，可以让团队成员解决问题。一件事情的果总会是另一件事情的因。我们在把日常问题解决了，有助于发现和解决潜在风险，或者有更多的精力去做更多有意义的事情。</p><h2 id="把局部发现转化为全局优化"><a href="#把局部发现转化为全局优化" class="headerlink" title="把局部发现转化为全局优化"></a>把局部发现转化为全局优化</h2><p>局部发现转化为全局优化就是说要在团队中做到先富带动后富。单个团队或个人获得了某种独有的知识或经验，应该把这种隐性知识（难以通过文档或沟通方式传递的知识）转换为显性知识，建立全局知识库，形成集体智慧。当其他人做类似的工作时，只需要在知识库中搜索，就能够很快找到前辈的经验。</p><h2 id="在日常工作中注入弹性模式"><a href="#在日常工作中注入弹性模式" class="headerlink" title="在日常工作中注入弹性模式"></a>在日常工作中注入弹性模式</h2><p>这样做的目标是为了给团队或系统增加弹力，提升抗脆弱性。想要抗脆弱，就要知道脆弱点在哪。根据前人的经验，我们可以通过缩短部署实践、提高测试覆盖率、缩短测试执行时间、系统解耦等方式，提升系统的弹力。我们可以通过故障演练，比如随机的拔网线、关电源、杀进程（比如Netflix的Chaos Monkey）等，能够验证系统的恢复能够力。我们还可以通过压测（单接口、全链路）来测试系统的瓶颈和上限。</p><p><img src="https://static.howardliu.cn/devops/chaos-monkey.jpg" alt="Netflix Chaos Monkey"></p><h2 id="领导层强化学习文化"><a href="#领导层强化学习文化" class="headerlink" title="领导层强化学习文化"></a>领导层强化学习文化</h2><p>这点是说给领导听的，优秀的领导力不是体现在做出所有的决定都是正确的，而是能够为团队创造条件，让团队在日常工作中感受到这种卓越。因为领导者不会亲自参与到一线工作，一线工作者也不了解大的组织环境或者不具备工作领域以外做出改变的权利，所以领导者与一线工作者之间是互补关系，必须互相尊重。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>DevOps三步工作法作为支撑DevOps的基础原则，也衍生出了DevOps的行为和模式。相信很多团队已经开始走DevOps之路了，下面列出来4个阶段：</p><ol><li>只有Dev没有Ops，所有的事情开发自己搞定。</li><li>有Dev也有Ops，他们相互独立，Ops承接了开发代码之外所有的工作。</li><li>Dev+Ops，Ops做了一些自动化的工具提升效率，但主要是给自己去用，开发不用。</li><li>DevOps，在上游工作的开发愿意使用下游的运维提供的系统或平台，通过API自助、自动的完成相应的工作。</li></ol><p>可以看下自己处于那种阶段，如果没有达到，可以参考上面的三步工作法，一步一步的实现DevOps。要是一步一步，脚踏实地。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/the-three-ways-principles-underpinning-devops/">实现DevOps的三步工作法</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/104242451" target="_blank" rel="noopener">实现DevOps的三步工作法</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      实现DevOps的三步工作法：流动原则、反馈原则、持续学习与实验原则。
    
    </summary>
    
    
      <category term="devops" scheme="https://www.howardliu.cn/categories/devops/"/>
    
    
      <category term="DevOps" scheme="https://www.howardliu.cn/tags/DevOps/"/>
    
      <category term="Phoenix" scheme="https://www.howardliu.cn/tags/Phoenix/"/>
    
  </entry>
  
  <entry>
    <title>微服务中服务注册和发现的可行性方案</title>
    <link href="https://www.howardliu.cn/service-registry-and-discovery/"/>
    <id>https://www.howardliu.cn/service-registry-and-discovery/</id>
    <published>2020-01-28T08:57:09.000Z</published>
    <updated>2020-01-28T08:57:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://www.howardliu.cn/the-base-of-microservice/">微服务的基建工作</a> 中提到过，在云原生、微服务时代，如果还是手动修改服务地址，是几乎不可完成的工作，需要一种机制完成自动上报和获取服务地址的支撑组件，可以保障服务的快速上线和下线，这就是服务注册/发现组件。</p><a id="more"></a><blockquote><p>为了表述方便，从系统规模定义几个阶段：</p><ul><li>巨型应用架构时期：很多应用都是一个巨型服务，一个应用包含所有功能，部署在小型机和大型机上，或者直接部署在物理服务器上。</li><li>单体架构时期：应用体量缩小，服务增多，而且出现虚拟化技术，物理服务器被连接成虚拟化平台，应用部署在虚拟机中。</li><li>SOA架构时期：应用通用功能逐渐沉淀，业务应用借助沉淀的通用组件逐渐解耦，微服务的很多组件也是从这个时期开始成型。</li><li>微服务架构时期：这个时期承接模块化时期，甚至有一种说法是微服务只是SOA的一种特殊形式。系统进一步解耦，根据业务角色不同，应用以业务为分界，缩小为业务单元。</li><li>函数架构时期：应用进一步分割为函数，实现serverless架构，不需要具体的服务器概念，只需要执行函数的服务即可。目前来看，这个时期是比较理想的时期，因为不同人相互协作定义的函数，可能重复或者冲突，不利于架构的演进。</li></ul></blockquote><p>随着大家对在微服务或者函数架构中趟坑，很多人开始提出回归单体应用架构，这应该也是架构螺旋进步的一种方式。</p><p>在微服务中，还有一种角色是根据调用关系定义的：</p><ul><li>客户端服务（简称客户端）：调用其他服务的实例</li><li>服务端服务（简称服务端）：被其他服务实例调用的实例</li></ul><blockquote><p>微服务中客户端和服务端只对一个调用定义的，客户端在其他调用关系中，角色可能会转变为服务端。</p></blockquote><h1 id="服务注册表"><a href="#服务注册表" class="headerlink" title="服务注册表"></a>服务注册表</h1><p>说到服务发现时，必须要说一个重要组件：<strong>服务注册表</strong>，它是服务发现的核心，是一个包含了所有服务实例的网络位置和监控状态的数据库，通过服务注册组件将信息写入服务注册表，通过服务发现组件获取有效的服务实例的网络位置信息。目前常用的服务注册表有：Eureka、etcd、Consul、Zookeeper，Kibernetes等镜像调度服务没有明确的服务注册表组件，是通过内置的服务注册功能实现。对于比如F5和Nginx这种代理器，其中的upstream配置也属于服务注册表。</p><h1 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h1><p>在微服务架构中，服务之间通过轻量级协议互相调用，一般是HTTP请求，为了完成一次请求，服务需要知道目标服务实例的网络位置（IP和端口）。</p><p>在巨型应用架构时期，配置一个符合要求的服务器环境需要花费大量的时间，也就意味着服务地址发生变动的概率和频率都非常低，而且很多应用部署在一台小型机或者大型机上。到了单体架构时期，应用体量大数量少，发生地址变动所需要修改的地方就比较少，所以对于服务发现也就没有那么强的需求。换句话说，在单体架构之前，服务实例的相对位置固定，变动频率低，可以通过硬编码到代码中。</p><p>但是到了云时代，服务器环境配置变得简单，数量逐渐增多，扩展和迁移逐渐频繁。而且，随着虚拟化和容器的应用，服务器地址都是根据规则动态分配，由于服务升级、扩展、失败回滚等情况增多，服务的网络位置甚至不可预知。这个时候必须使用服务发现机制保证客户端服务能够自动获取服务端服务的地址。</p><p>通常，服务发现有两种模式：客户端发现模式、服务端发现模式。</p><h2 id="客户端发现模式"><a href="#客户端发现模式" class="headerlink" title="客户端发现模式"></a>客户端发现模式</h2><p>客户端发现模式<strong>通过客户端组件根据负载均衡算法决定相应服务实例的网络位置</strong>，也就是说，客户端组件保存有服务端所有实例的服务注册表，调用发生时，根据负载均衡算法，从服务注册表中选择一个网络位置，向服务端发起请求，完成调用。由于网络的不可靠性，有的客户端组件还会实现访问失败重试、访问超时时间设定等功能。</p><p>这种模式的架构如图：</p><p><img src="https://static.howardliu.cn/microservice/service_discovery_client_mode.png" alt="客户端发现模式"></p><p>具体的过程为：</p><ol><li>服务实例向服务注册器上报网络位置，即注册</li><li>客户端服务发现组件定时拉取服务注册器中服务实例的网络位置信息及健康状态，保存在服务注册表中</li><li>客户端服务调用服务端服务时，通过客户端服务发现组件，根据负载均衡算法，选取可用一个服务实例，发起调用</li></ol><p>在Spring Cloud（或者说是Netflix开源组件）中，组件Eureka Server组件相当于服务注册器，Eureka Client组件实现了服务注册表，Ribbon实现了负载均衡算法和重试策略。</p><p>客户端发现模式优缺点兼备。优点是对已有服务友好，除了客户端组件外，其他部分无需改动。而且，客户端存有所有服务实例信息，可以有针对性的定义负载均衡算法。缺点是客户端与服务注册器绑定，需要针对每种语言实现不同的客户端组件。</p><h2 id="服务端发现模式"><a href="#服务端发现模式" class="headerlink" title="服务端发现模式"></a>服务端发现模式</h2><p>服务端发现模式是<strong>有一个单独的服务发现组件，这个实例持有服务注册表，同时也起到负载均衡器的作用</strong>，客户端调用服务端时，直接调用服务发现实例，通过服务实例代理到后端服务实例中，所以服务端发现模式也被称为<strong>代理模式</strong>。</p><p>这种模式的架构如图：</p><p><img src="https://static.howardliu.cn/microservice/service_discovery_server_mode.png" alt="服务端发现模式"></p><p>具体的过程为：</p><ol><li>服务实例向服务注册器上报网络位置，即注册</li><li>服务发现实例定时通过某种机制获取服务注册器中服务实例的网络位置信息及健康状态，保存在服务注册表中</li><li>客户端服务调用服务端服务时，直接调用服务发现实例，服务发现实例根据内部实现，查询服务注册表，将请求代理到后端服务实例</li></ol><p>服务端发现模式中的服务发现组件有两种实现方式：</p><ul><li>第一种，集中式代理，服务发现组件是单独的服务实例，这个实例是高可用高吞吐的系统组件，代理后端服务实例，代表性的是F5和Nginx。</li><li>第二种，主机进程代理，服务发现组件由系统环境提供，集成在主机上或者集成在操作系统中，代表性的是Istio ServiceMesh。</li></ul><p>两种实现方式的优点是语言无关，客户端不需要关心任何服务发现的细节，只需要将原有的调用实例的请求修改为向服务发现实例发送请求。集中式代理的缺点是，存在单点问题，需要单独部署一个高可用、高吞吐的系统服务，由原来的一次调用增加为两次调用，有性能开销。主机进程代理的缺点是运维复杂，需要能力强的运维团队做支持。</p><h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p>服务注册是将服务实例的网络信息和健康状态写入服务注册表中，有两种方式：自注册模式、第三方注册模式。</p><h2 id="自注册模式"><a href="#自注册模式" class="headerlink" title="自注册模式"></a>自注册模式</h2><p>这种模式是服务实例主动向服务注册表上报网络位置和健康状态，有的实现中，服务实例还会通过心跳保障注册信息不会过期。</p><p><img src="https://static.howardliu.cn/microservice/service_registry_self_registration_pattern.png" alt="自注册模式"></p><p>Eureka就是采用的这种方式，服务实例通过Eureka Client组件主动上报自己的网络位置信息和健康状态。</p><p>这种模式实现相对简单，但是把服务实例和服务注册表耦合，优缺点明显。</p><h2 id="第三方注册模式"><a href="#第三方注册模式" class="headerlink" title="第三方注册模式"></a>第三方注册模式</h2><p>第三方注册模式是服务实例不需要直接向服务注册表注册信息，而是借助被称为注册器的组件进行注册。服务注册器是通过扫描部署环境或者订阅事件的方式，跟踪服务实例的变更。当监测到服务实例有变化，会向服务注册表上报变化信息。</p><p><img src="https://static.howardliu.cn/microservice/service_registry_side_registration_pattern.png" alt="第三方注册模式"></p><p>这种方式可以将服务实例与服务注册表解耦，同时也引入另外的问题。即注册器需要内置在部署环境中，增加了运维复杂性。或者注册器需要部署一个集中式的管理组件，成为系统约束点。</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>在微服务中，服务实例的运行环境会动态变化，实例网络位置也是如此，因此，客户端为了访问服务必须要使用服务发现机制。</p><p>服务发现有客户端发现模式和服务端发现模式，服务注册有自注册模式和第三方注册模式。服务发现和服务注册通过服务注册表链接在一起。</p><p>后面有时间，会再补充目前比较常用的服务发现、服务注册的相关组件。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/service-registry-and-discovery/">微服务中服务注册和发现的可行性方案</a><br>CSDN主页: <a href="https://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">https://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/104108544" target="_blank" rel="noopener">微服务中服务注册和发现的可行性方案</a></p>]]></content>
    
    <summary type="html">
    
      在[微服务的基建工作](https://www.howardliu.cn/the-base-of-microservice/)中提到过，在云原生、微服务时代，如果还是手动修改服务地址，是几乎不可完成的工作，需要一种机制完成自动上报和获取服务地址的支撑组件，可以保障服务的快速上线和下线，这就是服务注册/发现组件。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java中的单例模式（完整篇）</title>
    <link href="https://www.howardliu.cn/singleton-pattern/"/>
    <id>https://www.howardliu.cn/singleton-pattern/</id>
    <published>2020-01-24T07:44:18.000Z</published>
    <updated>2020-08-23T12:24:08.475Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/design-patterns/physalis-4770292_1920.jpg" alt="Java中的单例模式（完整篇）"></p><p>个人认为单例模式是设计模式中最简单也是最常用的一种，是对有限资源合理利用的一种方式。这个模式看似简单，但是其中蕴含了关于并发、类加载、序列化等一系列深层次的知识，如果理解不够深，就有可能在高并发时遇到难以预期的异常，或者会造成资源浪费。</p><p>所以本文会从将目前Java领域最常用的几种单例模式列出来，供大家参考。</p><a id="more"></a><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h2><p>维基百科给出了解释、实现的思路以及应该注意的地方:</p><blockquote><p>单例模式，也叫单子模式，是一种常用的软件设计模式，属于创建型模式的一种。在应用这个模式时，单例对象的类必须保证只有一个实例存在。</p><p>实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。</p><p>单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例唯一的原则。 解决这个问题的办法是为指示类是否已经实例化的变量提供一个互斥锁(虽然这样会降低效率)。</p></blockquote><p>类图是：</p><p><img src="https://static.howardliu.cn/java/Singleton_UML_class_diagram.png" alt="singleton pattern"></p><h2 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h2><p>正如定义所说，单例模式就是整个内存模型中，只有一个实例。实例少了，内存占用就少。同时，只有一个实例，也就只需要构建一个对象，计算就少。对于构造过程中需要大量计算或者占用大量资源的对象，只创建一次，就减少了资源占用和内存占用。</p><h2 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式是最简单的一种实现，在类装载过程中，完成实例化，避免多线程问题。</p><h4 id="实现一：静态实例参数与静态代码块"><a href="#实现一：静态实例参数与静态代码块" class="headerlink" title="实现一：静态实例参数与静态代码块"></a>实现一：静态实例参数与静态代码块</h4><pre><code class="java">public class EagerSingleton {    private static final EagerSingleton INSTANCE = new EagerSingleton();    private EagerSingleton() {    }    public static EagerSingleton getInstance() {        return INSTANCE;    }}</code></pre><p>根据java的特性，饿汉式还可以变种写法，有的地方称为静态代码块方式：</p><pre><code class="java">public class EagerSingleton {    private static EagerSingleton INSTANCE = null;    static {        INSTANCE = new EagerSingleton();    }    private EagerSingleton() {    }    public static EagerSingleton getInstance() {        return INSTANCE;    }}</code></pre><p>这两种方式只是在写法上的区别，优缺点没有区别，只是借助Java语言特性的不同写法，所以归为一类。</p><p>饿汉式有两个明显的缺点：</p><ol><li>类装载过程即完成实例化，如果整个应用生命周期内，实例没有使用，也就是浪费资源了。</li><li>因为没有办法向构造函数传递不同的参数，如果需要通过个性化参数定制实例时，这种方式就不支持了。</li></ol><h3 id="实现二：静态内部类"><a href="#实现二：静态内部类" class="headerlink" title="实现二：静态内部类"></a>实现二：静态内部类</h3><p>针对饿汉式第一个缺点，我们可以借助静态内部类的方式，将对象实例化的时间延后。</p><pre><code class="java">public class EagerSingleton {    private EagerSingleton() {    }    private static class EagerSingletonInstance {        private static final EagerSingleton INSTANCE = new EagerSingleton();    }    public static EagerSingleton getInstance() {        return EagerSingletonInstance.INSTANCE;    }}</code></pre><p>但是，依然不能很好的解决第二个缺点，如果需要根据不同的参数实现不同的实例，可以采用下面说的懒汉式实现。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式比饿汉式的一个优点，就是能够在使用的时候再进行实例化。但是，馅饼总是要伴随着陷阱，懒汉式写法有更多的坑，一不小心就摔着了。</p><h4 id="错误一：单线程实现"><a href="#错误一：单线程实现" class="headerlink" title="错误一：单线程实现"></a>错误一：单线程实现</h4><pre><code class="java">public class LazySingleton {    private static LazySingleton INSTANCE = null;    private LazySingleton() {    }    public static LazySingleton getInstance() {        if (INSTANCE == null) {            INSTANCE = new LazySingleton();        }        return INSTANCE;    }}</code></pre><p>之所以定义为单线程实现，是因为<code>INSTANCE == null</code>这个判断，一个线程通过这个判断，开始进行对象实例化，但是还没有实例化完成，另一个线程又来了，这个时候，对象还没有实例化，就也会开始进行实例化，造成不必要的浪费。</p><h4 id="错误二：同步方法"><a href="#错误二：同步方法" class="headerlink" title="错误二：同步方法"></a>错误二：同步方法</h4><pre><code class="java">public class LazySingleton {    private static LazySingleton INSTANCE = null;    private LazySingleton() {    }    public static synchronized LazySingleton getInstance() {        if (INSTANCE == null) {            INSTANCE = new LazySingleton();        }        return INSTANCE;    }}</code></pre><p>这种方式解决了多线程的问题，但是也引入了新的性能问题：太慢。<code>synchronized</code>把整个方法包起来，也就是每个线程进入的时候，都需要等待其他线程结束调用，才能拿到实例，在性能敏感的场景，是比较致命的。</p><h4 id="错误三：同步代码块之单次检查"><a href="#错误三：同步代码块之单次检查" class="headerlink" title="错误三：同步代码块之单次检查"></a>错误三：同步代码块之单次检查</h4><pre><code class="java">public class LazySingleton {    private static LazySingleton INSTANCE = null;    private LazySingleton() {    }    public static LazySingleton getInstance() {        if (INSTANCE == null) {            synchronized (LazySingleton.class) {                INSTANCE = new LazySingleton();            }        }        return INSTANCE;    }}</code></pre><p>这种写法看似将同步代码缩小，但也缩小了多线程保障，也犯了第一种写法的错误，属于没有对多线程有基本了解写出的低级错误代码。</p><h4 id="错误四：同步代码块之双重检查"><a href="#错误四：同步代码块之双重检查" class="headerlink" title="错误四：同步代码块之双重检查"></a>错误四：同步代码块之双重检查</h4><pre><code class="java">public class LazySingleton {    private static LazySingleton INSTANCE = null;    private LazySingleton() {    }    public static LazySingleton getInstance() {        if (INSTANCE == null) {            synchronized (LazySingleton.class) {                if (INSTANCE == null) {                    INSTANCE = new LazySingleton();                }            }        }        return INSTANCE;    }}</code></pre><p>这种写法在一定程度上属于正确的写法，双重判断可以很好的实现线程安全和延迟加载。如果到这里就结束，那就是谬以千里的毫厘之差。</p><p>双重检查和同步代码块都没有问题，问题出在<code>INSTANCE = new LazySingleton()</code>这句话。在JVM中，为了充分利用CPU计算能力，会进行重排序优化，<code>INSTANCE = new LazySingleton()</code>做了三件事：</p><ol><li>为 INSTANCE 初始化栈空间</li><li>为 LazySingleton 分配内存空间，实例化对象</li><li>INSTANCE 指向 LazySingleton 实例分配的内存空间</li></ol><p>因为重排序优化的存在，真正执行的过程中，可能会出现1-2-3的顺序，也可能出现1-3-2的顺序。如果是1-3-2，INSTANCE 指向了 LazySingleton 实例分配的内存空间后，就不是null，另外一个线程进入判断null时，就会直接返回 INSTANCE，但是这个时候 LazySingleton 实例化还没有完成，就可能出现意想不到的异常。</p><h4 id="正确：双重检查-阻止重排序"><a href="#正确：双重检查-阻止重排序" class="headerlink" title="正确：双重检查+阻止重排序"></a>正确：双重检查+阻止重排序</h4><pre><code class="java">public class LazySingleton {    private static volatile LazySingleton INSTANCE = null;    private LazySingleton() {    }    public static LazySingleton getInstance() {        if (INSTANCE == null) {            synchronized (LazySingleton.class) {                if (INSTANCE == null) {                    INSTANCE = new LazySingleton();                }            }        }        return INSTANCE;    }}</code></pre><p>这种写法比上面那种，就差在<code>volatile</code>这个关键字。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>懒汉式和饿汉式都能够适用于多线程并发场景，但是通过反序列化或反射可以实例化对象，这样依然不能满足单例模式的要求，所以可以借助枚举实现，枚举可以完美避免多线程并发问题，而且可以防止反序列化和反射创建新对象。第一次看到这样定义单例模式，是在《Effective Java》中，多读经典书还是挺好的。</p><pre><code class="java">public enum EnumSingleton {    INSTANCE;    public void method1() {        // do something    }    public Object method2() {        // do something and return something else        return new Object();    }}</code></pre><p>在开发实践中，枚举可以满足绝大部分场景，而且写法简单，定义单例的逻辑只需要三行代码，简洁而不简单，三行代码可以保证线程安全。同时枚举的反序列化只是通过name查找对象，不会产生新的对象；根据JVM规范，通过反射创建枚举对象时，会抛出<code>IllegalArgumentException</code>异常。这样，相当于通过语法糖防止反序列化和反射破坏单例。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li><strong>无状态工具类</strong>：这种工具类不需要记录状态，只保证正确的应用就行，可以通过单例模式来定义。</li><li><strong>数据共享</strong>：即多个不相关的两个线程或者进程之间实现通信。因为是一个实例，如果它的属性或者变量值被修改，所有引用都是同时修改的，当然需要 volatile 来定义变量。比如网站的计数器。</li><li><strong>日志应用</strong>：通常应用会向日志文件写日志信息，为了实时向文件写，通常会使用单例模式，保证有一个实例持有文件，然后进行操作。</li><li><strong>数据库连接池</strong>：数据库连接是一种数据库资源，使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，通过单例模式来维护，就可以大大降低这种损耗。</li><li><strong>Web应用的配置对象</strong>：读取文件需要消耗时间，如果读取大文件，消耗的时间和资源更久，所以通过单例模式可以大大降低消耗。</li><li>。。。</li></ol><p>单例模式的场景还是比较多的，这里只是列出里几个简单的应用场景，算是抛砖引玉，如果看官们有什么其他应用场景，可以在留言区回复。</p><ul><li><a href="https://www.howardliu.cn/singleton-pattern/">单例模式</a></li><li><a href="https://www.howardliu.cn/the-builder-pattern/">建造者模式</a></li></ul><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/singleton-pattern/">Java中的单例模式（完整篇）</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/104084369" target="_blank" rel="noopener">Java中的单例模式（完整篇）</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      个人认为单例模式是设计模式中最简单也是最常用的一种，是对有限资源合理利用的一种方式。这个模式看似简单，但是其中蕴含了关于并发、类加载、序列化等一系列深层次的知识，如果理解不够深，就有可能在高并发时遇到难以预期的异常，或者会造成资源浪费。
    
    </summary>
    
    
      <category term="java" scheme="https://www.howardliu.cn/categories/java/"/>
    
      <category term="design pattern" scheme="https://www.howardliu.cn/categories/java/design-pattern/"/>
    
    
      <category term="设计模式" scheme="https://www.howardliu.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>微服务的基建工作</title>
    <link href="https://www.howardliu.cn/the-base-of-microservice/"/>
    <id>https://www.howardliu.cn/the-base-of-microservice/</id>
    <published>2020-01-04T03:24:54.000Z</published>
    <updated>2020-08-25T13:44:51.109Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://static.howardliu.cn/microservice/antlered-deer-animator-antlers.jpg" alt="微服务的基建工作"></p><p>前文说了一下<a href="https://www.howardliu.cn/what-is-microservice/">《六字说出微服务的本质》</a>，在文末提到，初创团队不建议直接使用微服务，对于初创团队，最根本的是活下去，而想要使用微服务，需要有很多基础建设。本文就来说下，微服务都需要哪些基础建设。</p><blockquote><p>需要说明的是，下面这些组件，都是基于服务太多这个前提。</p></blockquote><p>微服务的出现是为了研发效能的提升：相同的人数可以处理更多的需求、维护更多的产品，可以更快的交付产品。基于这点，微服务的基础组件，就从解放人力，减少人为失误出发。</p><p>下面给出一张微服务基础组件的图片：</p><p><img src="https://static.howardliu.cn/microservice/microservice-architecture.png" alt="微服务架构"></p><a id="more"></a><h2 id="1-容器"><a href="#1-容器" class="headerlink" title="1 容器"></a>1 容器</h2><h3 id="1-1-运行容器"><a href="#1-1-运行容器" class="headerlink" title="1.1 运行容器"></a>1.1 运行容器</h3><p>服务运行的容器是支持服务提供对外访问的基础，根据微服务的要求，每个服务单独运行的独立进程中，所需要的运行容器就需要小巧灵活，运行容器可以集成在运行环境中，或者能够集成在服务可执行包中。</p><p>在Java领域，各大厂商都有自己的web容器：WebLogic、JBoss、Tomcat、Jetty等。SpringBoot内嵌了Tomcat和Jetty，默认打包方式是FatJar，jar保证包含了服务运行所有的基础，可以支持微服务部署的基本要求。</p><h3 id="1-2-部署容器"><a href="#1-2-部署容器" class="headerlink" title="1.2 部署容器"></a>1.2 部署容器</h3><p>部署容器是服务运行的加成组件，容器的好处在于一套镜像可以支撑测试和生成部署。这样做可以避免测试环境没有问题，生产环境各种报错的情况。但是想要实现一套镜像到处运行，还需要集中配置的支持。</p><p>而且对于部署容器，最好有一套容器调度平台，这样能够更有效的使用资源。如果没有，可能用部署容器和普通部署方式，区别不是很大。</p><h2 id="2-服务注册-发现"><a href="#2-服务注册-发现" class="headerlink" title="2 服务注册/发现"></a>2 服务注册/发现</h2><p>服务注册/发现是两个组件，彼此没有必然关系，但一般这两个组件会成对出现，解决同一个问题：服务地址动态变化的配置问题。</p><p>在单体架构时代，企业内部只有几个大系统，想要调用其他服务，只需要提前指定IP地址就行了。但是到了云原生时代，服务实例的网络地址都是动态分配的，想要提前指定IP是比较困难的。而且，在部署过程中，还会出现动态扩展、服务迁移、服务死亡等情况，服务实例也是动态变化。如果还是靠手工，不仅浪费时间，而且容易出错。</p><p>最好的办法就是，服务自己或通过代理人上报位置，然后客户端想要调用服务时，只需要从注册器中拿到一个可用的服务地址，直接调用，这就是服务注册/发现组件。</p><p><img src="https://static.howardliu.cn/microservice/service_registry_discovery.png" alt="服务注册/发现"></p><h2 id="3-网关"><a href="#3-网关" class="headerlink" title="3 网关"></a>3 网关</h2><p>在单体架构中，通常只有一组冗余或负载均衡的服务。在微服务架构中，每个服务都提供了一组细粒度的服务。对于一个普通的应用，可能需要调用多个不同的微服务，来获取全部的数据。这样做有三个缺点：</p><ol><li>调用服务太多，将应用于后端服务捆绑，同时也造成第二个缺点</li><li>服务难以重构，随着时间推移，服务可能会出现合并或者拆分的情况，应用于服务捆绑在一起，就难以重构</li><li>后端服务对外暴露的协议不一致，可能对web不友好。虽然微服务要求服务之间使用轻量级通信，但是并没有强调必须使用HTTP协议。</li></ol><p>这个时候，就需要有一个统一的出入口，来解耦应用于微服务，并且屏蔽内部细节，接收所有调用者请求。</p><p>目前在网关上有很多优秀的实践，将反向路由、安全认证、限流熔断、日志监控、灰度发布等功能放在网关上，将功能前置，简化微服务功能，让微服务团队可以更加专心于业务。</p><p><img src="https://static.howardliu.cn/microservice/api_gateway.png" alt="API网关"></p><h2 id="4-授权认证"><a href="#4-授权认证" class="headerlink" title="4 授权认证"></a>4 授权认证</h2><p>安全第一，什么行业都是安全第一。</p><p>授权认证是两个概念：用户授权和安全认证。用户授权是指给指定用户授权访问资源，然后某个用户访问资源的时候，认证用户是否有访问资源的权限。两者配合，共同完成资源的安全保护。业界比较常用的是使用OAuth2协议实现授权认证。</p><p><img src="https://static.howardliu.cn/microservice/iam.jpg" alt="授权认证"></p><h2 id="5-配置管理"><a href="#5-配置管理" class="headerlink" title="5 配置管理"></a>5 配置管理</h2><p>配置管理和前面说的服务注册/发现一样，都是为了解决服务太多，人工出差这个痛点的。</p><p>通常开发人员把配置放在配置文件中，这样配置不够规范，配置项追溯都比较麻烦。比较危险的是，涉及到用户名密码等一些安全性配置的，又不符合审计要求。而且，一旦需要大规模修改配置，改动时间长，改动之后就需要重新部署，可能对整个产品造成影响。所以就需要一个集中的配置管理服务。</p><h2 id="6-日志收集"><a href="#6-日志收集" class="headerlink" title="6 日志收集"></a>6 日志收集</h2><p>日志是记录服务运行情况的主要来源，也可以在发生异常情况时还原现场。但是随着服务的增多，日志分布在许多的服务器中，如果不进行聚合，在排查问题的时候，难上加难。</p><h2 id="7-监控告警"><a href="#7-监控告警" class="headerlink" title="7 监控告警"></a>7 监控告警</h2><p>监控告警不是微服务的专利，当服务集群或服务器达到一定规模，想要做到7*24不停机、不宕机提供服务，就需要监控告警。因为微服务的服务规模比较大，会将监控的必要性放大。</p><h3 id="7-1-指标"><a href="#7-1-指标" class="headerlink" title="7.1 指标"></a>7.1 指标</h3><p>通常监控指标是会从系统、应用、业务等几个维度进行：</p><ol><li>系统监控：主要是监控物理机、虚拟机、操作系统的运行情况，主要指标包括CPU、内存、磁盘、网络等，其他的一些相关的数据包括物理机运行时间、操作系统版本、操作系统内核，这些也是排查问题的一些基本依据。这里还需要重点说一下网络，微服务都是通过网络调用或被调用，一旦网络出现问题，整个微服务集群都是不可用的，所以网络监控需要细化到流量、数据包、丢包、错报、连接数等指标。</li><li>应用监控：主要是监控应用的运行情况，包括应用运行时间、http服务端口、服务url、http服务响应码、http服务响应时间、SQL、缓存命中、TPS、QPS等。对于Java应用，还需要包括JVM运行情况：JDK版本、内存使用（堆内存、非堆内存等）、GC等Java虚拟机运行情况。</li><li>业务监控：主要是监控一些核心业务执行情况，对业务有一定的侵入性，各个服务的指标不同，各家监控方式也不同，通常是埋码。比如监控登录注册、商品信息、库存情况、下单、支付、发货等各个业务。</li></ol><h3 id="7-2-健康"><a href="#7-2-健康" class="headerlink" title="7.2 健康"></a>7.2 健康</h3><p>一般健康检查是通过心跳检测进行的，通常会分为两种：</p><ol><li>一种是建立TCP链接，执行ping/pong调用。这种方式需要服务中与监控系统建立TCP链接，需要在服务中嵌入监控组件，对服务有侵入。但是因为其执行效率高，而且针对性强，不会出现漏报的情况。</li><li>一种是监听服务端口，这种方式只需要在容器内或者虚拟机增加监控插件，对服务没什么侵入，但是由于端口可用和服务可用不是一个概念，所以会出现漏报的情况。</li></ol><h3 id="7-3-调用链"><a href="#7-3-调用链" class="headerlink" title="7.3 调用链"></a>7.3 调用链</h3><p>微服务之间彼此调用，整个的调用链路彼此交错，如果不加管理，很有可能演变成请求风暴。</p><p>调用链监控是为了分析系统依赖、请求耗时、请求瓶颈的一种方式。目前，市面上多数调用链监控组件都是基于Google Dapper开发的。下面给出调用链监控的原理示意图（因为调用链监控的内容比较多，所以会在后面单独开一章）：</p><p><img src="https://static.howardliu.cn/microservice/trace.png" alt="Trace"></p><h3 id="7-4-异常收集"><a href="#7-4-异常收集" class="headerlink" title="7.4 异常收集"></a>7.4 异常收集</h3><p>异常分成两种，逻辑异常和行为异常。逻辑异常是说代码中存在异常逻辑，比如常见的NPE；行为异常时用户行为不可预期而出现的异常，这两种情况对系统都有一定危害。所以需要收集这些异常情况，并且能够定位异常发生的位置。异常信息收集主要是为了定位问题，所以上报的信息一定要全面而且容易定位。所以上报信息中需要保护异常码，可以自定义一定长度的字符串，便于定位位置。然后是要上报参数，用于还原现场。还要上报异常信息，用来分析异常情况。</p><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8 最后"></a>8 最后</h2><p>上面提到的组件，都是为了更好的管理微服务，减少人肉运维，减少人为失误。寥寥数语，难以道尽上述组件的优点，每个组件都需要单独细聊，这里就当是个引子。</p><hr><p>个人主页: <a href="https://www.howardliu.cn">https://www.howardliu.cn</a><br>个人博文: <a href="https://www.howardliu.cn/the-base-of-microservice/">微服务的基建工作</a><br>CSDN主页: <a href="http://blog.csdn.net/liuxinghao" target="_blank" rel="noopener">http://blog.csdn.net/liuxinghao</a><br>CSDN博文: <a href="https://blog.csdn.net/liuxinghao/article/details/103845612" target="_blank" rel="noopener">微服务的基建工作</a></p><p><img src="http://static.howardliu.cn/about/kanshanshuo.png" alt="公众号：看山的小屋"></p>]]></content>
    
    <summary type="html">
    
      微服务的出现是为了研发效能的提升，相同的人数可以接受/处理更多的需求、维护更多的产品，可以更快的研发、交付，做到这两点，团队效能已经不容小视。
    
    </summary>
    
    
      <category term="microservice" scheme="https://www.howardliu.cn/categories/microservice/"/>
    
    
      <category term="微服务" scheme="https://www.howardliu.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="架构" scheme="https://www.howardliu.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
</feed>
